<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Програмски језик Prolog</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/activecode.css" />
    <link rel="stylesheet" type="text/css" href="../_static/codemirror.css" />
    <link rel="stylesheet" type="text/css" href="../_static/qchoice.css" />
    <link rel="stylesheet" type="text/css" href="../_static/clickable.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pytutor.css" />
    <link rel="stylesheet" type="text/css" href="../_static/modal-basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/datafile.css" />
    <link rel="stylesheet" type="text/css" href="../_static/dragndrop.css" />
    <link rel="stylesheet" type="text/css" href="../_static/fitb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/matrixeq.css" />
    <link rel="stylesheet" type="text/css" href="../_static/parsons.css" />
    <link rel="stylesheet" type="text/css" href="../_static/lib/prettify.css" />
    <link rel="stylesheet" type="text/css" href="../_static/poll.css" />
    <link rel="stylesheet" type="text/css" href="../_static/showEval.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tabbedstuff.css" />
    <link rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/video.css" />
    <link rel="stylesheet" type="text/css" href="../_static/webgldemo.css" />
    <link rel="stylesheet" type="text/css" href="../_static/webglinteractive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/karel.css" />
    <link rel="stylesheet" type="text/css" href="../_static/notes.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/associations.css" />
    <link rel="stylesheet" type="text/css" href="../_static/editor.css" />
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/user-highlights.css" type="text/css" />
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.1/css/all.css" type="text/css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-4.0.0-dist/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/flatly.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/petlja-course.css" type="text/css" />
    <link rel="stylesheet" href="../_static/nbstyle.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/runestonebase.js"></script>
    <script src="../_static/skulpt.min.js"></script>
    <script src="../_static/skulpt-stdlib.js"></script>
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/jquery.highlight.js"></script>
    <script src="../_static/bookfuncs.js"></script>
    <script src="../_static/codemirror.js"></script>
    <script src="../_static/xml.js"></script>
    <script src="../_static/css.js"></script>
    <script src="../_static/python.js"></script>
    <script src="../_static/htmlmixed.js"></script>
    <script src="../_static/javascript.js"></script>
    <script src="../_static/jquery_i18n/CLDRPluralRuleParser.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.messagestore.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.fallbacks.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.language.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.parser.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.emitter.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.emitter.bidi.js"></script>
    <script src="../_static/activecode-i18n.en.js"></script>
    <script src="../_static/activecode-i18n.sr-Cyrl.js"></script>
    <script src="../_static/activecode.js"></script>
    <script src="../_static/clike.js"></script>
    <script src="../_static/timed_activecode.js"></script>
    <script src="../_static/animationbase.js"></script>
    <script src="../_static/mchoice.js"></script>
    <script src="../_static/timedmc.js"></script>
    <script src="../_static/timed.js"></script>
    <script src="../_static/mchoice-i18n.en.js"></script>
    <script src="../_static/mchoice-i18n.sr-Cyrl.js"></script>
    <script src="../_static/clickable.js"></script>
    <script src="../_static/timedclickable.js"></script>
    <script src="../_static/d3.v2.min.js"></script>
    <script src="../_static/jquery.ba-bbq.min.js"></script>
    <script src="../_static/jquery.jsPlumb-1.3.10-all-min.js"></script>
    <script src="../_static/pytutor.js"></script>
    <script src="../_static/codelens.js"></script>
    <script src="../_static/skulpt.min.js"></script>
    <script src="../_static/skulpt-stdlib.js"></script>
    <script src="../_static/datafile.js"></script>
    <script src="../_static/dragndrop.js"></script>
    <script src="../_static/timeddnd.js"></script>
    <script src="../_static/dragndrop-i18n.en.js"></script>
    <script src="../_static/dragndrop-i18n.sr-Cyrl.js"></script>
    <script src="../_static/fitb.js"></script>
    <script src="../_static/timedfitb.js"></script>
    <script src="../_static/fitb-i18n.en.js"></script>
    <script src="../_static/fitb-i18n.sr-Cyrl.js"></script>
    <script src="../_static/matrixeq.js"></script>
    <script src="../_static/lib/prettify.js"></script>
    <script src="../_static/lib/hammer.min.js"></script>
    <script src="../_static/parsons.js"></script>
    <script src="../_static/parsons-i18n.en.js"></script>
    <script src="../_static/parsons-i18n.sr-Cyrl.js"></script>
    <script src="../_static/timedparsons.js"></script>
    <script src="../_static/poll.js"></script>
    <script src="../_static/reveal.js"></script>
    <script src="../_static/shortanswer.js"></script>
    <script src="../_static/timed_shortanswer.js"></script>
    <script src="../_static/showEval.js"></script>
    <script src="../_static/tabbedstuff.js"></script>
    <script src="../_static/runestonevideo.js"></script>
    <script src="../_static/webglinteractive.js"></script>
    <script src="../_static/FileSaver.min.js"></script>
    <script src="../_static/Blob.js"></script>
    <script src="../_static/karelCorner.js"></script>
    <script src="../_static/karelRobot.js"></script>
    <script src="../_static/karelWorld.js"></script>
    <script src="../_static/karelChat.js"></script>
    <script src="../_static/karelRobotDrawer.js"></script>
    <script src="../_static/karelUI.js"></script>
    <script src="../_static/karel.js"></script>
    <script src="../_static/karel-i18n.en.js"></script>
    <script src="../_static/karel-i18n.sr-Cyrl.js"></script>
    <script src="../_static/notes.js"></script>
    <script src="../_static/pygamelib-init.js"></script>
    <script src="../_static/gallery.js"></script>
    <script src="../_static/associations.js"></script>
    <script src="../_static/associations-i18n.en.js"></script>
    <script src="../_static/associations-i18n.sr-Cyrl.js"></script>
    <script src="../_static/editor.js"></script>
    <script src="../_static/jszip.js"></script>
    <script src="../_static/editor-i18n.en.js"></script>
    <script src="../_static/editor-i18n.sr-Cyrl.js"></script>
    <script src="../_static/translations.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/jquery-ui-1.10.3.custom.min.js"></script>
    <script src="../_static/jquery-fix.js"></script>
    <script src="../_static/bootstrap-4.0.0-dist/js/bootstrap.min.js"></script>
    <script src="../_static/bootstrap-4.0.0-dist/js/bootstrap.bundle.min.js"></script>
    <script src="../_static/bootstrap-sphinx.js"></script>
    <script src="../_static/waypoints.min.js"></script>
    <script src="../_static/rangy-core.js"></script>
    <script src="../_static/rangy-textrange.js"></script>
    <script src="../_static/rangy-cssclassapplier.js"></script>
    <script src="../_static/user-highlights.js"></script>
    <script src="../_static/jquery.idle-timer.js"></script>
    <script src="../_static/processing-1.4.1.min.js"></script>
    <script src="../_static/jquery.hotkey.js"></script>
    <script src="../_static/jquery-migrate-1.2.1.min.js"></script>
    <script src="../_static/course-errors.js"></script>
    <script src="../_static/petlja.js"></script>
    <script src="../_static/require.js"></script>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
    <meta content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' name='viewport' />
    <link rel="shortcut icon" href="../_static/favicon.ico" type="image/ico" />
    <script type="text/javascript">
      eBookConfig = {};
      eBookConfig.host = 'http://127.0.0.1:8000' ? 'http://127.0.0.1:8000' : 'http://127.0.0.1:8000';
      eBookConfig.app = eBookConfig.host + '/runestone';
      eBookConfig.ajaxURL = eBookConfig.app + '/ajax/';
      eBookConfig.course = 'paradigme';
      eBookConfig.logLevel = '0';
      eBookConfig.loginRequired = 'false';
      eBookConfig.build_info = "";
      eBookConfig.isLoggedIn = false;
      eBookConfig.useRunestoneServices = false;
      eBookConfig.python3 = true;
      eBookConfig.basecourse = 'paradigme';
      eBookConfig.runestone_version = '';
      eBookConfig.imagesDir = '../_images/';
      eBookConfig.staticDir = '../_static/';
      if (typeof (Sk) != "undefined")
        Sk.imgPath = eBookConfig.imagesDir;
    </script>

  </head>

  <body>



<div id="navbar" class="content-header">
  <div class="right-side-nav">
    
    <div id="usefulLinksToggle" class="useful-links-toggle">
        <a class="dropdown-toggle dropdown-toggle-burger" role="button" href="#" id="usefulLinksDropdown" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-bars fa-2x"></i>
        </a>
        <div class="dropdown-menu dropdown-nav-links shadow-lg" aria-labelledby="usefulLinksDropdown" x-placement="bottom-start" style="position: absolute; transform: translate3d(-55px, 32px, 0px); top: 0px; left: 0px; will-change: transform;">
          <div class="links-title"> Корисни линкови</div>
          <div class="useful-link">
            <a href="https://www.haskell.org/ghc/" target="_blank">Glasgow haskell compiler</a></div>
          <div class="useful-link">
            <a href="https://www.haskell.org/hugs/" target="_blank">Hugs Haskell interpreter</a></div>
          <div class="useful-link">
            <a href="https://replit.com/languages/haskell" target="_blank">Haskell online (repl.it)</a></div>
          <div class="useful-link">
            <a href="https://www.swi-prolog.org/" target="_blank">SWI Prolog</a></div>
          <div class="useful-link">
            <a href="https://swish.swi-prolog.org/" target="_blank">SWI Prolog online</a></div>
          
        </div>
    </div>

    
</div>

<div class="left-side-nav">
  <div class="course-logo-nav">
      <a target="_blank" href="https://petlja.org">
          <img src="../_static/img/petlja-logo-wt.svg" alt="petlja.org" id="lightPetljaLogo">
      </a>
  </div>
  <div class="course-logo-nav-kabinet">
      <a target="_blank" href="https://petlja.org/net.kabinet">
          <img src="../_static/img/netkabinet-logo-strelica-wt.svg" alt="petlja.org" id="lightNetKabinetLogo">
      </a>
  </div>
</div>


<div class="content-header-label" id = "content-header-label" href="../">Увод у програмске парадигме, логичко и функционално програмирање за четврти разред специјализованих ИТ одељења</div>

</div>




<div class="petljaCourseContainer">

<div class="petljaCourseContent">
  
           <div class="tableOfContent">
            <h5> Садржај </h5>
            </div>
           <div>
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-01%20paradigme>
                    <h5>О програмским парадигмама</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../01%20paradigme/01_o_paradigmama.html><div class="studioLecture" id=activity-01%20paradigme-01_o_paradigmama><i class="fas fa-file-alt activity-icon"></i>О програмским језицима и парадигмама</div></a>
                <a href=../01%20paradigme/02_imperativna.html><div class="studioLecture" id=activity-01%20paradigme-02_imperativna><i class="fas fa-file-alt activity-icon"></i>Императивна парадигма</div></a>
                <a href=../01%20paradigme/03_oop.html><div class="studioLecture" id=activity-01%20paradigme-03_oop><i class="fas fa-file-alt activity-icon"></i>Објектнооријентисана парадигма</div></a>
                <a href=../01%20paradigme/04_skript.html><div class="studioLecture" id=activity-01%20paradigme-04_skript><i class="fas fa-file-alt activity-icon"></i>Скрипт парадигма</div></a>
                <a href=../01%20paradigme/05_o_paradigmama_quiz.html><div class="studioLecture" id=activity-01%20paradigme-05_o_paradigmama_quiz><i class="far fa-question-circle activity-icon"></i>Квиз</div></a>
                </div>
            </div>
                
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-02%20funkcionalna>
                    <h5>Функционална парадигма</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../02%20funkcionalna/01_funkcionalna.html><div class="studioLecture" id=activity-02%20funkcionalna-01_funkcionalna><i class="fas fa-file-alt activity-icon"></i>О функционалној парадигми</div></a>
                <a href=../02%20funkcionalna/01a_funkcionalna_quiz.html><div class="studioLecture" id=activity-02%20funkcionalna-01a_funkcionalna_quiz><i class="far fa-question-circle activity-icon"></i>Квиз</div></a>
                <a href=../02%20funkcionalna/02_haskell.html><div class="studioLecture" id=activity-02%20funkcionalna-02_haskell><i class="fas fa-file-alt activity-icon"></i>Haskell - изрази и функције</div></a>
                <a href=../02%20funkcionalna/02b_haskell_liste.html><div class="studioLecture" id=activity-02%20funkcionalna-02b_haskell_liste><i class="fas fa-file-alt activity-icon"></i>Haskell - листе</div></a>
                <a href=../02%20funkcionalna/02c_haskell_tipovi.html><div class="studioLecture" id=activity-02%20funkcionalna-02c_haskell_tipovi><i class="fas fa-file-alt activity-icon"></i>Haskell - алгебарски типови података</div></a>
                <a href=../02%20funkcionalna/02e_haskell_main.html><div class="studioLecture" id=activity-02%20funkcionalna-02e_haskell_main><i class="fas fa-file-alt activity-icon"></i>Haskell - улаз, излаз, главни програм</div></a>
                <a href=../02%20funkcionalna/02z_haskell_vezba.html><div class="studioLecture" id=activity-02%20funkcionalna-02z_haskell_vezba><i class="fas fa-file-alt activity-icon"></i>Haskell - задаци за вежбу</div></a>
                <a href=../02%20funkcionalna/02d_haskell_primeri.html><div class="studioLecture" id=activity-02%20funkcionalna-02d_haskell_primeri><i class="fas fa-file-alt activity-icon"></i>Haskell - пример већег програма</div></a>
                </div>
            </div>
                
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-03%20logicka>
                    <h5>Логичка парадигма</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../03%20logicka/01_logicka.html><div class="studioLecture" id=activity-03%20logicka-01_logicka><i class="fas fa-file-alt activity-icon"></i>О логичкој парадигми</div></a>
                <a href=../03%20logicka/01_iskazna_logika.html><div class="studioLecture" id=activity-03%20logicka-01_iskazna_logika><i class="fas fa-file-alt activity-icon"></i>Исказна логика</div></a>
                <a href=../03%20logicka/01_sat.html><div class="studioLecture" id=activity-03%20logicka-01_sat><i class="fas fa-file-alt activity-icon"></i>SAT решавачи</div></a>
                <a href=../03%20logicka/01a_iskazna_logika_quiz.html><div class="studioLecture" id=activity-03%20logicka-01a_iskazna_logika_quiz><i class="far fa-question-circle activity-icon"></i>Исказна логика - квиз</div></a>
                <a href=../03%20logicka/02_predikatska_logika.html><div class="studioLecture" id=activity-03%20logicka-02_predikatska_logika><i class="fas fa-file-alt activity-icon"></i>Предикатска логика</div></a>
                <a href=../03%20logicka/02_atp.html><div class="studioLecture" id=activity-03%20logicka-02_atp><i class="fas fa-file-alt activity-icon"></i>Аутоматски доказивачи теорема</div></a>
                <a href=../03%20logicka/02a_predikatska_logika_quiz.html><div class="studioLecture" id=activity-03%20logicka-02a_predikatska_logika_quiz><i class="far fa-question-circle activity-icon"></i>Предикатска логика - квиз</div></a>
                <a href=../03%20logicka/03_prolog.html><div class="studioLecture" id=activity-03%20logicka-03_prolog><i class="fas fa-file-alt activity-icon"></i>Prolog - база знања и правила извођења</div></a>
                <a href=../03%20logicka/03_prolog_secenje.html><div class="studioLecture" id=activity-03%20logicka-03_prolog_secenje><i class="fas fa-file-alt activity-icon"></i>Prolog - дрво извођења, сечење</div></a>
                <a href=../03%20logicka/03_prolog_aritmetika.html><div class="studioLecture" id=activity-03%20logicka-03_prolog_aritmetika><i class="fas fa-file-alt activity-icon"></i>Prolog - аритметичка израчунавања</div></a>
                <a href=../03%20logicka/03_prolog_liste.html><div class="studioLecture" id=activity-03%20logicka-03_prolog_liste><i class="fas fa-file-alt activity-icon"></i>Prolog - листе</div></a>
                <a href=../03%20logicka/03_prolog_zagonetke.html><div class="studioLecture" id=activity-03%20logicka-03_prolog_zagonetke><i class="fas fa-file-alt activity-icon"></i>Prolog - решавање логичких загонетки</div></a>
                <a href=../03%20logicka/03z_prolog_zadaci.html><div class="studioLecture" id=activity-03%20logicka-03z_prolog_zadaci><i class="fas fa-file-alt activity-icon"></i>Prolog - задаци за самостални рад</div></a>
                </div>
            </div>
                </div>
</div>



<div class="lectureContent">

  <div id="errors">
  </div>
  
  <div class="lectureContentMaterial">
  
    <div id="main-content">
    
  <section id="prolog">
<h1>Програмски језик Prolog<a class="headerlink" href="#prolog" title="Permalink to this heading">¶</a></h1>
<p>Најзначајнији представник логичке парадигме је програмски језик
Prolog.</p>
<p>Prolog је декларативни, логички програмски језик који је развијен
током 1970-их година, намењен пре свега решавању задатака симболичке
природе. Творцима овог језика сматрају се Алан Колмерауер и Филип
Русел на Универзитету у Марсељу и Роберт Ковалски са Универзитета у
Единбургу. На развој пролога значајно је утицао метод резолуције који
је развио Алан Робертсон 1965.</p>
<p>Осамдесетих година прошлог века постојала је група научника која се
бавила рачунарством, која је веровала да је логичко програмирање
најбољи начин да се превазиђе сложеност и непоузданост императивних
језика. У Јапану, који је у то доба био у великој технолошкој
експанзији, направљен је велики пројекат развоја
рачунара 5. генерације, заснованих на логичком програмирању и
Prolog-у. Ипак, логичко програмирање није заживело колико и остале
парадигме, пре свега јер програми написани у логичком програмском
језику нису довољно ефикасни као програми написани у неком
еквивалентном императивном језику, као и зато што је област примене
релативно мала (коришћен је углавном у домену аутоматског доказивања
теорема, у имплементацији експертских система, презаписивању термова,
аутоматском планирању).</p>
<p>Постоје савремене надоградње основног језика Prolog које су веома
ефикасне у решавању неких специјализованих проблема (на пример,
B-Prolog је веома ефикасан систем за решавање проблема задовољења
ограничења, eng. <em>constraint programming</em>).</p>
<section id="id1">
<h2>Развојно окружење<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h2>
<p>Програмски језик Prolog може и да се интерпретира и да се компилира,
мада се чешће интерпретира. Популарне савремене имплементације су
SWI-Prolog и GNU-Prolog. Ми вам препоручујемо коришћење онлјан
окружења за SWI-Prolog (<a class="reference external" href="https://swish.swi-prolog.org/">https://swish.swi-prolog.org/</a>).</p>
</section>
<section id="id2">
<h2>Основни појмови језика<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h2>
<p>Логичко програмирање и језик Prolog су у тесној вези са математичком
логиком. Prolog програм се задаје помоћу <strong>базе знања</strong>, која садржи
чињенице и правила закључивања. Чињенице су атомичке формуле облика:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nv">P</span><span class="p">(</span><span class="s s-Atom">c1</span><span class="p">,</span> <span class="p">...,</span> <span class="s s-Atom">cn</span><span class="p">).</span>
</pre></div>
</div>
<p>Ово одговара атомичкој формули <span class="math notranslate nohighlight">\(P(c_1, \ldots, c_n)\)</span> у којој
је предикат <span class="math notranslate nohighlight">\(P\)</span> примењен на низ константи <span class="math notranslate nohighlight">\(c_1\)</span> до
<span class="math notranslate nohighlight">\(c_n\)</span>. На пример, једна чињеница у бази знања може бити:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">grk</span><span class="p">(</span><span class="s s-Atom">sokrat</span><span class="p">).</span>
</pre></div>
</div>
<p>Приметимо да су и име предиката <code class="docutils literal notranslate"><span class="pre">grk</span></code> и име <code class="docutils literal notranslate"><span class="pre">sokrat</span></code> написани
малим словима (што није правописно исправно), јер се називи свих
предиката и називи свих константи морају писати малим словима.</p>
<p>Правила извођења су облика</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nv">H</span> <span class="p">:-</span> <span class="nv">B1</span><span class="p">,</span> <span class="p">...,</span> <span class="nv">Bn</span><span class="p">.</span>
</pre></div>
</div>
<p>где су и <code class="docutils literal notranslate"><span class="pre">H</span></code> и <code class="docutils literal notranslate"><span class="pre">B1</span></code> до <code class="docutils literal notranslate"><span class="pre">Bn</span></code> атомичке формуле облика</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nv">Bi</span><span class="p">(</span><span class="s s-Atom">t1</span><span class="p">,</span> <span class="p">...,</span> <span class="s s-Atom">tm</span><span class="p">)</span>
</pre></div>
</div>
<p>у којима су термови <code class="docutils literal notranslate"><span class="pre">t1</span></code> до <code class="docutils literal notranslate"><span class="pre">tm</span></code> обично променљиве (мада могу бити
и константе).</p>
<p>Свако правило извођења одговара импликацији <span class="math notranslate nohighlight">\(B_1 \wedge \ldots
\wedge B_n \Rightarrow H\)</span>, тј. клаузули <span class="math notranslate nohighlight">\(\neg B_1 \vee \ldots
\wedge \neg B_n \vee H\)</span> (обратите пажњу на необичан смер импликације,
тј. на запис <span class="math notranslate nohighlight">\(H \Leftarrow B_1 \wedge \ldots \wedge
B_n\)</span>. Формула <code class="docutils literal notranslate"><span class="pre">H</span></code> се назива <strong>глава</strong> правила, конјункција формула
<code class="docutils literal notranslate"><span class="pre">B1</span></code> до <code class="docutils literal notranslate"><span class="pre">Bn</span></code> <strong>тело</strong>, а симбол <code class="docutils literal notranslate"><span class="pre">:-</span></code> се назива <strong>врат</strong> и он
представља наопако записану импликацију, тј. логички везник
<span class="math notranslate nohighlight">\(\Leftarrow\)</span>.</p>
<p>Све променљиве су имплицитно универзално квантификоване. На пример,
правила</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">covek</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">grk</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
<span class="nf">smrtan</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">covek</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>означавају реченице <span class="math notranslate nohighlight">\((\forall X)(\mathrm{grk}(X) \Rightarrow
\mathrm{covek}(X))\)</span>, тј. <em>сви Грци су људи</em> и <span class="math notranslate nohighlight">\((\forall
x)(\mathrm{covek}(X) \Rightarrow \mathrm{smrtan}(X))\)</span> тј., <em>сви људи су
смртни</em>.</p>
<p>Поред базе знања, последњи део Prolog програма је <strong>упит</strong> који је
облика</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nv">A1</span><span class="p">,</span> <span class="p">...,</span> <span class="nv">An</span>
</pre></div>
</div>
<p>где су <code class="docutils literal notranslate"><span class="pre">A1</span></code> до <code class="docutils literal notranslate"><span class="pre">An</span></code> предикати облика:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nv">Ai</span><span class="p">(</span><span class="s s-Atom">t1</span><span class="p">,</span> <span class="p">...,</span> <span class="s s-Atom">tm</span><span class="p">)</span>
</pre></div>
</div>
<p>Упит одговара клаузули <span class="math notranslate nohighlight">\(\neg A_1 \vee \ldots \vee \neg A_n\)</span>.
која је негација формуле <span class="math notranslate nohighlight">\(A_1 \wedge \ldots \wedge A_n\)</span>. Та
формула је логичка последица базе знања ако и само ако се додавањем
клаузуле упита међу клаузуле базе знања може добити празна формула.</p>
<p>На пример, циљ може бити:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">smrtan</span><span class="p">(</span><span class="s s-Atom">sokrat</span><span class="p">).</span>
</pre></div>
</div>
<p>На овај упит Prolog одговара са <code class="docutils literal notranslate"><span class="pre">true</span></code>, што значи да је та формула
логичка последица базе знања. Заиста, ако је Сократ Грк, ако су сви
Грци људи и ако су сви људи смртни, тада је и Сократ смртан.</p>
<p>Дакле Prolog програм (база знања и упит) представља скуп клаузула
специјалног облика. Такве клаузуле се називају <strong>Хорнове клаузуле</strong> и
за њих је карактеристично да имају највише један позитиван и све
остале негативне литерале. Prolog методом резолуције, уз коришћење
унификације изводи празну клаузулу и, ако успе, показује вредности
променљивих које су до тога довеле. Захваљујући специјалној структури
Хорнових клаузула механизам резолуције је много ефикаснији него у
случају коришћења клаузула произвољног облика. Са друге стране,
наравно, не може се било која логичка формула изразити у клаузалној
форми коришћењем искључиво Хорнових клаузула.</p>
<p>У нашем примеру, клаузуле нашег програма</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">grk</span><span class="p">(</span><span class="s s-Atom">sokrat</span><span class="p">).</span>
<span class="nf">covek</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">grk</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
<span class="nf">smrtan</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">covek</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
<span class="s s-Atom">?-</span> <span class="nf">smrtan</span><span class="p">(</span><span class="s s-Atom">sokrat</span><span class="p">).</span>
</pre></div>
</div>
<p>су</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{grk}(\mathrm{sokrat})\\
\neg \mathrm{grk}(X) \vee \mathrm{covek}(X)\\
\neg \mathrm{covek}(X) \vee \mathrm{smrtan}(X)\\
\neg \mathrm{smrtan}(\mathrm{sokrat})\end{split}\]</div>
<p>Резолуцијом средње две клаузуле добија се клаузула <span class="math notranslate nohighlight">\(\neg
\mathrm{grk}(X) \vee \mathrm{smrtan}(X)\)</span>, која се онда може
резолвирати са првом и четвртом клаузулом (након инстанцијације
унификатором <span class="math notranslate nohighlight">\(X=\mathrm{sokrat}\)</span>) и тако извести празна
клаузула.</p>
<p>Обратите пажњу на то да Prolog закључке изводи искључиво на основу
чињеница и правила, која су екплицитно кодирана кроз базу знања. На
пример, одговор на упит</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">smrtan</span><span class="p">(</span><span class="s s-Atom">platon</span><span class="p">).</span>
</pre></div>
</div>
<p>је <code class="docutils literal notranslate"><span class="pre">false</span></code>, јер се додавањем клаузуле <span class="math notranslate nohighlight">\(\neg
\mathrm{smrtan}(\mathrm{platon})\)</span> из базе знања не може извести празна
клаузула (јер се на основу наше базе знања не може закључити да је
Платон Грк).</p>
<p>Ако упит садржи променљиве, Prolog исписује и вредности тих
променљивих које доводе до извођења празне клаузуле. На пример, на
упит</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">smrtan</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>Prolog одговара са <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">sokrat</span></code>. Ако после затражимо друга решења,
добићемо одговор <code class="docutils literal notranslate"><span class="pre">false</span></code>, јер друга решења не постоје. Ако би база
знања садржала и чињеницу</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">grk</span><span class="p">(</span><span class="s s-Atom">platon</span><span class="p">).</span>
</pre></div>
</div>
<p>Добили бисмо решења <code class="docutils literal notranslate"><span class="pre">X=sokrat</span></code>, <code class="docutils literal notranslate"><span class="pre">X=platon</span></code> и након тога одговор
<code class="docutils literal notranslate"><span class="pre">false</span></code>, што значи да, осим ових, нема више решења.</p>
<p>Опишимо и процедуру коју Prolog систем спроводи током израчунавања
решења упита <code class="docutils literal notranslate"><span class="pre">?-</span> <span class="pre">smrtan(X)</span></code>. Током решавања текућег упита Prolog
покушава да пронађе или чињеницу или главу неког правила која је
једнака или се може унификовати са тим упитом. У нашој бази знања се
налази правило <code class="docutils literal notranslate"><span class="pre">smrtan(X)</span> <span class="pre">:-</span> <span class="pre">covek(X).</span></code>, па се упит даље своди на
проналажење <code class="docutils literal notranslate"><span class="pre">X</span></code> за које важи <code class="docutils literal notranslate"><span class="pre">covek(X)</span></code> тј. на подупит
<code class="docutils literal notranslate"><span class="pre">?-</span> <span class="pre">covek(X)</span></code> (овим је заправо направљен један корак
резолуције). Поново се претражује база знања и проналази се правило
<code class="docutils literal notranslate"><span class="pre">covek(X)</span> <span class="pre">:-</span> <span class="pre">grk(X).</span></code>, па се упит своди на проналажење <code class="docutils literal notranslate"><span class="pre">X</span></code> за које
важи <code class="docutils literal notranslate"><span class="pre">grk(X)</span></code> тј. подупит <code class="docutils literal notranslate"><span class="pre">?-</span> <span class="pre">grk(X)</span></code> (овим је направљен још један
корак резолуције). Новом претрагом базе се проналази да се тај упит
може унификовати са чињеницом <code class="docutils literal notranslate"><span class="pre">grk(sokrat)</span></code> уз унификатор <code class="docutils literal notranslate"><span class="pre">X=sokrat</span></code>.
Подсетимо се, унификацијом се проналази замена променљивих вредностима
тако да два израза постану једнака – у овом случају се након замене
<code class="docutils literal notranslate"><span class="pre">X=sokrat</span></code> упит <code class="docutils literal notranslate"><span class="pre">?-</span> <span class="pre">grk(X)</span></code> и чињеница <code class="docutils literal notranslate"><span class="pre">grk(sokrat)</span></code>
изједначавају. И овим је направљен један корак резолуције и добијена
је празна клаузула. Зато је упит успешно решен и приказује се решење
<code class="docutils literal notranslate"><span class="pre">X=sokrat</span></code>.</p>
<p>Тражење наредног решења захтева да се вратимо корак уназад (да урадимо
бектрекинг) и да потражимо друго решење за упит <code class="docutils literal notranslate"><span class="pre">?-</span> <span class="pre">grk(X)</span></code>. Ако у
бази постоји чињеница <code class="docutils literal notranslate"><span class="pre">grk(platon)</span></code> она се може унификовати са овим
упитом, уз унификатор <code class="docutils literal notranslate"><span class="pre">X=platon</span></code>, па се тако проналази и друго
решење.  Након захтева за трећим решењем, примећује се да не постоји
трећа чињеница нити глава правила извођења која се може унификовати са
<code class="docutils literal notranslate"><span class="pre">grk(X)</span></code>. Зато се враћамо корак уназад, примећујемо да не постоји
неко друго правило закључивања нити чињеница која би се могла
унификовати са упитом <code class="docutils literal notranslate"><span class="pre">?-</span> <span class="pre">covek(X)</span></code>, након чега се исто закључује и
за полазни упит <code class="docutils literal notranslate"><span class="pre">?-</span> <span class="pre">smrtan(X)</span></code> и тако се установљава да нема других
решења.</p>
</section>
<section id="id3">
<h2>Пример: породично стабло<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h2>
<p>Кодирајмо за почетак које особе чине ужу породицу Симпсон (све су
представљене константама) и ког су пола.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">musko</span><span class="p">(</span><span class="s s-Atom">homer</span><span class="p">).</span>
<span class="nf">zensko</span><span class="p">(</span><span class="s s-Atom">mardz</span><span class="p">).</span>
<span class="nf">musko</span><span class="p">(</span><span class="s s-Atom">bart</span><span class="p">).</span>
<span class="nf">zensko</span><span class="p">(</span><span class="s s-Atom">liza</span><span class="p">).</span>
<span class="nf">zensko</span><span class="p">(</span><span class="s s-Atom">megi</span><span class="p">).</span>
</pre></div>
</div>
<p>Дефинишимо правила којима закључујемо ко су особе у породици Симпсон.
Мушке особе су особе и женске особе су особе. Додајемо зато следећа
два правила извођења.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% osobe u porodici Simpson su ili muske ili zenske osobe</span>
<span class="nf">osoba</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">musko</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
<span class="nf">osoba</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">zensko</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>Не заборавимо да импликација важи здесна налево, тј. овде су дата
правила <span class="math notranslate nohighlight">\((\forall X)(\mathrm{musko}(X) \Rightarrow
\mathrm{osoba}(X))\)</span> и <span class="math notranslate nohighlight">\((\forall X)(\mathrm{zensko}(X)
\Rightarrow \mathrm{osoba}(X))\)</span>. Уместо два правила могуће је навести
и једно правило:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% osobe u porodici Simpson su ili muske ili zenske osobe</span>
<span class="nf">osoba</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">musko</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">;</span> <span class="nf">zensko</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>Оператор <code class="docutils literal notranslate"><span class="pre">;</span></code> је оператор дисјункције, па је овим задана импликација
<span class="math notranslate nohighlight">\((\forall X)(\mathrm{musko}(X) \vee \mathrm{zensko}(X)
\Rightarrow \mathrm{osoba}(X))\)</span>, која приликом превођења у клаузалну
форму даје потпуно исте две клаузуле <span class="math notranslate nohighlight">\(\neg \mathrm{musko}(X)
\vee \mathrm{osoba}(X)\)</span> и <span class="math notranslate nohighlight">\(\neg \mathrm{zensko}(X) \vee
\mathrm{osoba}(X)\)</span>, као и када се особа опише помоћу два независна
правила.</p>
<p>Коректност овог правила можемо проверити постављањем упита</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">osoba</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>Ако је све како треба, требало би да добијемо пет одговора
<code class="docutils literal notranslate"><span class="pre">X=homer</span></code>, <code class="docutils literal notranslate"><span class="pre">X=mardz</span></code>, <code class="docutils literal notranslate"><span class="pre">X=bart</span></code>, <code class="docutils literal notranslate"><span class="pre">X=liza</span></code>, <code class="docutils literal notranslate"><span class="pre">X=megi</span></code> и затим
одговор <code class="docutils literal notranslate"><span class="pre">false</span></code>, који означава да су ово једина решења.</p>
<p>Проширимо базу знања односима родитељ-дете</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">roditelj</span><span class="p">(</span><span class="s s-Atom">homer</span><span class="p">,</span> <span class="s s-Atom">bart</span><span class="p">).</span>
<span class="nf">roditelj</span><span class="p">(</span><span class="s s-Atom">homer</span><span class="p">,</span> <span class="s s-Atom">liza</span><span class="p">).</span>
<span class="nf">roditelj</span><span class="p">(</span><span class="s s-Atom">homer</span><span class="p">,</span> <span class="s s-Atom">megi</span><span class="p">).</span>
<span class="nf">roditelj</span><span class="p">(</span><span class="s s-Atom">mardz</span><span class="p">,</span> <span class="s s-Atom">bart</span><span class="p">).</span>
<span class="nf">roditelj</span><span class="p">(</span><span class="s s-Atom">mardz</span><span class="p">,</span> <span class="s s-Atom">liza</span><span class="p">).</span>
<span class="nf">roditelj</span><span class="p">(</span><span class="s s-Atom">mardz</span><span class="p">,</span> <span class="s s-Atom">megi</span><span class="p">).</span>
</pre></div>
</div>
<p>Дефинишимо на основу овога предикате <code class="docutils literal notranslate"><span class="pre">otac</span></code>, <code class="docutils literal notranslate"><span class="pre">majka</span></code>, <code class="docutils literal notranslate"><span class="pre">sin</span></code> и
<code class="docutils literal notranslate"><span class="pre">cerka</span></code>.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% osnovna pravila izvodjenja za uzu porodicu</span>
<span class="nf">otac</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">musko</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nf">majka</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">zensko</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nf">sin</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">musko</span><span class="p">(</span><span class="nv">Y</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nf">cerka</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">zensko</span><span class="p">(</span><span class="nv">Y</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
</pre></div>
</div>
<p>Прво правило се може тумачити као импликација</p>
<div class="math notranslate nohighlight">
\[(\forall X)(\forall Y)(\mathrm{musko}(X) \wedge \mathrm{roditelj}(X, Y) \Rightarrow \mathrm{otac}(X, Y))\]</div>
<p>тј. <em>ако је X мушко и родитељ је особи Y онда је X отац особи
Y</em>. Остала правила се тумаче аналогно.</p>
<p>Можемо проверити ова правила постављањем разних упита. На пример,
ко су Хомерове ћерке</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">cerka</span><span class="p">(</span><span class="s s-Atom">homer</span><span class="p">,</span> <span class="nv">X</span><span class="p">)</span>
</pre></div>
</div>
<p>Prolog проналази два решења <code class="docutils literal notranslate"><span class="pre">X=liza</span></code> и <code class="docutils literal notranslate"><span class="pre">X=megi</span></code>.</p>
<p>Покушајмо да дефинишемо сада релације брат и сестра.  Особа X је брат
особи Y ако је X мушко и ако имају заједничког родитеља. Желимо,
дакле, да кодирамо импликацију</p>
<div class="math notranslate nohighlight">
\[(\forall x)(\forall y)(\mathrm{musko}(x) \wedge ((\exists z)\mathrm{roditelj}(z, x) \wedge \mathrm{roditelj}(z, y)) \Rightarrow \mathrm{brat}(x, y))\]</div>
<p>Она није у Хорновом облику, али се лако може проверити да је
еквивалентна следећој импликацији, која јесте у Хорновом облику.</p>
<div class="math notranslate nohighlight">
\[(\forall x)(\forall y)(\forall z)(\mathrm{musko}(x) \wedge \mathrm{roditelj}(z, x) \wedge \mathrm{roditelj}(z, y) \Rightarrow \mathrm{brat}(x, y))\]</div>
<p>На основу овога долазимо до следећих правила:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">brat</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">musko</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">X</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nf">sestra</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">zensko</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">X</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
</pre></div>
</div>
<p>Покушајмо да тестирамо ова правила тиме што ћемо проверити коме је све
Барт брат. Постављамо упит</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">brat</span><span class="p">(</span><span class="s s-Atom">bart</span><span class="p">,</span> <span class="nv">X</span><span class="p">)</span>
</pre></div>
</div>
<p>Prolog проналази тачне одговоре <code class="docutils literal notranslate"><span class="pre">X=liza</span></code> и <code class="docutils literal notranslate"><span class="pre">X=megi</span></code>, али проналази
и нетачан одговор <code class="docutils literal notranslate"><span class="pre">X=bart</span></code>, што значи да је Барт сам свој
брат. Заиста, то се потпуно уклапа у наше правило (Барт је мушко и има
заједничког родитеља као Барт). Да бисмо избегли овај погрешан
одговор, потребно је да додамо услов да су променљиве <code class="docutils literal notranslate"><span class="pre">X</span></code> и <code class="docutils literal notranslate"><span class="pre">Y</span></code>
различите. То можемо изразити помоћу <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">\=</span> <span class="pre">Y</span></code>. Негација и
различитост у Prolog-у су веома суптилна места и треба их добро
разумети да се не би правиле грешке, али ћемо се том темом посебно
бавити касније. У овом контексту исправно је предикате дефинисати на
следећи начин.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">brat</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">musko</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">X</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">),</span>  <span class="nv">X</span> <span class="s s-Atom">\=</span> <span class="nv">Y</span><span class="p">.</span>
<span class="nf">sestra</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">zensko</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">X</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">),</span> <span class="nv">X</span> <span class="s s-Atom">\=</span> <span class="nv">Y</span><span class="p">.</span>
</pre></div>
</div>
<p>Приметимо да се решење <code class="docutils literal notranslate"><span class="pre">X=liza</span></code> проналази два пута и да се решење
<code class="docutils literal notranslate"><span class="pre">X=megi</span></code> такође проналази два пута. То је због тога што се у оба
случаја проналази једном заједнички родитељ Хомер, а у другом
заједнички родите Марџ (променљива <code class="docutils literal notranslate"><span class="pre">Z</span></code> може да узме две различите
вредности, што се не види, јер се на крају исписују само вредности
променљиве <code class="docutils literal notranslate"><span class="pre">Y</span></code>).</p>
<p>Проширимо сада базу знања чињеницама о Абрахаму и Мони, Хомеровим ма,
и Кленсију и Жаклин, Марџиним родитељима.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% baza znanja za babe i dede (po ocu)</span>
<span class="nf">musko</span><span class="p">(</span><span class="s s-Atom">abraham</span><span class="p">).</span>
<span class="nf">roditelj</span><span class="p">(</span><span class="s s-Atom">abraham</span><span class="p">,</span> <span class="s s-Atom">homer</span><span class="p">).</span>
<span class="nf">zensko</span><span class="p">(</span><span class="s s-Atom">mona</span><span class="p">).</span>
<span class="nf">roditelj</span><span class="p">(</span><span class="s s-Atom">mona</span><span class="p">,</span> <span class="s s-Atom">homer</span><span class="p">).</span>
<span class="c1">% baza znanja za babe i dede (po majci)</span>
<span class="nf">musko</span><span class="p">(</span><span class="s s-Atom">klensi</span><span class="p">).</span>
<span class="nf">roditelj</span><span class="p">(</span><span class="s s-Atom">klensi</span><span class="p">,</span> <span class="s s-Atom">mardz</span><span class="p">).</span>
<span class="nf">zensko</span><span class="p">(</span><span class="s s-Atom">zeklin</span><span class="p">).</span>
<span class="nf">roditelj</span><span class="p">(</span><span class="s s-Atom">zeklin</span><span class="p">,</span> <span class="s s-Atom">mardz</span><span class="p">).</span>
</pre></div>
</div>
<p>Добијамо упозорење да су чињенице које се односе на предикате
<code class="docutils literal notranslate"><span class="pre">musko</span></code>, <code class="docutils literal notranslate"><span class="pre">zensko</span></code> и <code class="docutils literal notranslate"><span class="pre">roditelj</span></code> раштркане по програму. Да бисмо
ово упозорење избегли, можемо или да групишемо све чињенице за исти
предикат, или да издамо наредбу:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="p">:-</span> <span class="s s-Atom">discontiguous</span> <span class="s s-Atom">musko</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span> <span class="s s-Atom">zensko</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span> <span class="s s-Atom">roditelj</span><span class="o">/</span><span class="mf">2.</span>
</pre></div>
</div>
<p>Сада једноставно можемо да дефинишемо предикате деда и баба.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">deda</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">otac</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Z</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nf">baba</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">majka</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Z</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
</pre></div>
</div>
<p>Међутим, још интересантније су дефиниције предиката којима се описују
преци и потомци, јер су те дефиниције у суштини рекурзивне. Довољно је
да дефинишемо, на пример, релацију предак, јер се релација потомак
може веома једноставно дефинисати преко релације предак (то јој је
заправо супротна релација).</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">potomak</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">predak</span><span class="p">(</span><span class="nv">Y</span><span class="p">,</span> <span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>Приметимо да је ова дефиниција исправна без обзира на то што још није
дефинисана релација <code class="docutils literal notranslate"><span class="pre">predak</span></code>. Чим она буде дефинисана, моћи ћемо да
користимо и дефиницију релације <code class="docutils literal notranslate"><span class="pre">potomak</span></code>. Наиме, базу знања у
идеалном случају треба схватити као скуп правила чијим се коришћењем
изводе закључци и редослед навођења правила не би требало да утиче на
резултат рада програма (видећемо касније да се од овог идеалног
случаја често одступа, да би се постигла већа ефикасност).</p>
<p>Родитељ неке особе јој је сигурно предак. Такође, било који предак
њеног родитеља јој је такође предак.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">predak</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nf">predak</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">),</span> <span class="nf">predak</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Z</span><span class="p">).</span>
</pre></div>
</div>
<p>Прво правило, наравно, можемо да тумачимо као</p>
<div class="math notranslate nohighlight">
\[(\forall X)(\forall Y)(\mathrm{roditelj}(X, Y) \Rightarrow \mathrm{predak}(X, Y))\]</div>
<p>док друго правило можемо да тумачимо као</p>
<div class="math notranslate nohighlight">
\[(\forall X)(\forall Y)(\forall Z)(\mathrm{roditelj}(Z, Y) \wedge \mathrm{predak}(X, Z) \Rightarrow \mathrm{predak}(X, Y))\]</div>
<p>али и еквивалентно као</p>
<div class="math notranslate nohighlight">
\[(\forall X)(\forall Y)(((\exists Z)\mathrm{roditelj}(Z, Y) \wedge \mathrm{predak}(X, Z)) \Rightarrow \mathrm{predak}(X, Y))\]</div>
<p>Наравно, претходна два правила можемо објединити коришћењем дисјункције.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">predak</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">;</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">),</span> <span class="nf">predak</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Z</span><span class="p">).</span>
</pre></div>
</div>
<p>На овај начин можемо да сазнамо, на пример, све Мегине претке. На упит</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">predak</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="s s-Atom">megi</span><span class="p">)</span>
</pre></div>
</div>
<p>добијамо одговоре <code class="docutils literal notranslate"><span class="pre">X=homer</span></code>, <code class="docutils literal notranslate"><span class="pre">X=mardz</span></code>, <code class="docutils literal notranslate"><span class="pre">X=klensi</span></code>,
<code class="docutils literal notranslate"><span class="pre">X=zeklin</span></code>, <code class="docutils literal notranslate"><span class="pre">X=abraham</span></code> и <code class="docutils literal notranslate"><span class="pre">X=mona</span></code>, при чему редослед одговора
зависи од редоследа навођења чињеница у бази знања.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Проширите, за вежбу, базу знања чињеницама о Хомеровом брату и
Марџиним сестрама и дефинишите предикате стриц, тетка и ујак.</p>

    </div></div>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>Нагласимо још једном декларативну природу претходних програма. Ни у
једном тренутку није било потребе да описујемо начин извођења
закључака. Довољно је било да опишемо услове који треба да важе, а
систем је тај који својим уграђеним алгоритмима проналази вредности
које задовољавају дате услове. За логичко програмирање се каже да
алгоритам обједињава <strong>логику</strong> и <strong>контролу</strong>, при чему програмер
задаје логику, а контролу извршава систем. Систем може да примени
различите стратегије извршавања (доказивања теорема) да би што
ефикасније дошао до решења.</p>

    </div></div>
</section>
<section id="id4">
<h2>Функције<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h2>
<p>За разлику од функционалних, али и императивних и
објектно-оријентисаних језика, где програмери углавном дефинишу
функције које на основу задатих аргумената израчунавају резултате,
основу PrologA чине предикати, тј. релације. Писање функција није
директно подржано. Ипак, већ смо видели да се релације постављањем
одговарајућих упита могу користити и као функције. На пример, у
функционалном језику написали бисмо функцију <code class="docutils literal notranslate"><span class="pre">brat(X)</span></code> која би као
параметар примала особу, а као резултат враћала њеног брата.  У
прологу смо дефинисали предикат <code class="docutils literal notranslate"><span class="pre">brat(X,</span> <span class="pre">Y)</span></code>, а затим смо, на
пример, помоћу упита <code class="docutils literal notranslate"><span class="pre">brat(X,</span> <span class="pre">liza)</span></code> могли да „израчунамо“ да је
Лизин брат Барт. Могли смо заправо и више од тога. Упитом <code class="docutils literal notranslate"><span class="pre">brat(bart,</span>
<span class="pre">X)</span></code> могли смо да израчунамо чији је све брат Барт. Дакле, једна
релација, у зависности од тога како се упит поставља нам омогућава
више израчунавања, тј. у себи крије више функција. Видећемо да ово
често може да буде изненађујуће, тј. да добијамо „гратис“ могућност
неких израчунавања која нисмо имали у виду када смо дефинисали
релацију.</p>
<p>Дакле, уместо дефинисања функција облика</p>
<div class="math notranslate nohighlight">
\[y = f(x_1, \ldots, x_n)\]</div>
<p>Prolog допушта дефинисање релација облика</p>
<div class="math notranslate nohighlight">
\[R(x_1, \ldots, x_n, y)\]</div>
<p>које се онда могу користити као функције тако што се аргументи
<span class="math notranslate nohighlight">\(x_1\)</span> до <span class="math notranslate nohighlight">\(x_n\)</span> фиксирају у упиту, а <cite>y</cite> се зада као
променљива чија се вредност аутоматски одређује. При том, сви
аргументи релације су симетрични и могуће је да било који од њих (па и
више њих истовремено) буду задати као променљиве чије се вредности
одређују.</p>
</section>
<section id="id5">
<h2>Негација као неуспех<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h2>
<p>Сви предикати са десне стране правила су задавани у позитивном облику
(ако изузмемо пример различитости две променљиве, што је негативни
облик). Prolog даје подршку за негацију, али је та негација специфична
и не понаша се исто као класична логичка негација. Тај облик негације
се назива <strong>негација као неуспех</strong> (енг. <em>negation as failure</em>).</p>
<p>Покушајмо да дефинишемо предикат женско, као негацију предиката мушко.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% Negacija kao neuspeh</span>
<span class="nf">zensko</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="o">not</span><span class="p">(</span><span class="nf">musko</span><span class="p">(</span><span class="nv">X</span><span class="p">)).</span>
</pre></div>
</div>
<p>Очекујемо да се ово може тумачити као импликација <span class="math notranslate nohighlight">\((\forall
X)(\neg \mathrm{musko}(X) \Rightarrow \mathrm{zensko}(X))\)</span>. Међутим,
упити показују на неуобичајено понашање.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">zensko</span><span class="p">(</span><span class="s s-Atom">homer</span><span class="p">).</span>  <span class="c1">% false</span>
<span class="s s-Atom">?-</span> <span class="nf">zensko</span><span class="p">(</span><span class="s s-Atom">mardz</span><span class="p">).</span>  <span class="c1">% true</span>
<span class="s s-Atom">?-</span> <span class="nf">zensko</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>      <span class="c1">% false</span>
</pre></div>
</div>
<p>Prolog успешно одређује да Хомер није женско, да Марџ јесте женско,
међутим, када се упита да наброји женске особе, добија се да не
постоји ни једна. Понашање операције <code class="docutils literal notranslate"><span class="pre">not</span></code> је такво да она успева
ако и само ако јој аргумент не успева.</p>
<ul class="simple">
<li><p>Упит <code class="docutils literal notranslate"><span class="pre">zensko(homer)</span></code> се своди на упит <code class="docutils literal notranslate"><span class="pre">not(musko(homer))</span></code>. Пошто
упит <code class="docutils literal notranslate"><span class="pre">musko(homer)</span></code> успева, упит <code class="docutils literal notranslate"><span class="pre">zensko(homer)</span></code> не успева и
исправно се враћа резултат <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
<li><p>Упит <code class="docutils literal notranslate"><span class="pre">zensko(mardz)</span></code> се своди на упит <code class="docutils literal notranslate"><span class="pre">not(musko(mardz))</span></code>. Пошто
упит <code class="docutils literal notranslate"><span class="pre">musko(mardz)</span></code> не успева, упит <code class="docutils literal notranslate"><span class="pre">zensko(mardz)</span></code> успева и
исправно се враћа резултат <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
<li><p>Упит <code class="docutils literal notranslate"><span class="pre">zensko(X)</span></code> се своди на упит <code class="docutils literal notranslate"><span class="pre">not(musko(X))</span></code>. Упит
<code class="docutils literal notranslate"><span class="pre">musko(X)</span></code> успева, при чему се добија вредност <code class="docutils literal notranslate"><span class="pre">X=homer</span></code>.
Међутим, пошто подупит <code class="docutils literal notranslate"><span class="pre">musko(X)</span></code> успева, упит <code class="docutils literal notranslate"><span class="pre">not(musko(X))</span></code>,
по дефиницији негације, не успева, па самим тим <code class="docutils literal notranslate"><span class="pre">zensko(X)</span></code> враћа
неисправан резултат <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
</ul>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>Негација у Prolog-у има другачије понашање од класичне логичке
негације!</p>

    </div></div>
<p>Третман негације се може сматрати једном од слабих тачака језика
Prolog, јер се у случају употребе негације значење програма не
изражава више помоћу јасних правила класичне математичке логике.</p>
</section>
</section>


    </div>
    
    <div>
<div class="lecture-prev-next-toggle">
  <a  href="02a_predikatska_logika_quiz.html" id="prevLectureLink" class="lecture-toggler-arrows"><i class="fas fa-arrow-left fa"></i> <span> Претходна лекција </span> </a>
  
  <a id="nextLectureLink" class="lecture-toggler-arrows"><span> Следећа лекција</span>  <i class="fas fa-arrow-right fa"></i> </a>
</div>

<script type="text/javascript">
  $('#relations-prev').tooltip({'placement':'right', 'selector': '', 'delay': { show: 100, hide: 50}});
  $('#relations-next').tooltip({'placement':'left', 'selector': '', 'delay': { show: 100, hide: 50}});
</script>
</div>

    
  </div>
</div>

<div class="petljadoc-resources">
  <span class="pull-left">(Created using  <a href="https://pypi.org/project/Sphinx/">Swinx</a>, <a href="http://runestoneinteractive.org/">RunestoneComponents</a> and <a href="https://github.com/Petlja/PetljaDoc">PetljaDoc</a>) <br> © 2022 Petlja</span>
</div>


<div class="lectureToolbox">

  <label class="font-size-toggle" id="fontSizeToggle">

      <i class="fas fa-font"></i><label>Слова</label>
  </label>
  <div class="font-change d-none" id="fontChangeModal">
      <span class="dec-letter-icon" id="decLetterIcon">A-</span>
      <label id="currentFontSize">16</label>
      <span class="inc-letter-icon" id="incLetterIcon">A+</span>
  </div>
</div>

</div>

  </body>
</html>