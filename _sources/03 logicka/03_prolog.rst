Програмски језик PROLOG
=======================

Најзначајнији представник логичке парадигме је програмски језик
PROLOG.

Кратак историјат развоја
------------------------

Пролог (Prolog) је декларативни, логички програмски језик који је
развијен током 1970-их година, намењен пре свега решавању задатака
симболичке природе.Творцима овог језика сматрају се Алаин Колмерауер
(енгл. Alain Colmerauer) и Филипе Роусел (енгл. Philippe Roussel) на
Универзитету у Марсељу (енгл. University of Aix-Marseille) и Роберт
Ковалски (енгл. Robert Kowalski) са Универзитета у Единбургу
(енгл. University of Edinburgh). На развој пролога значајно је утицао
метод резолуције који је развио Алан Робертсон 1965.

Осамдесетих година прошлог века је постојала група научника која се
бавила рачунарством, која је веровала да је логичко програмирање
најбољи начин да се превазиђе сложеност и непоузданост императивних
језика. У Јапану који је у то доба био у великој технолошкој
експанзији направљен је велики пројекат развоја
рачунара 5. генерације, заснованих на логичком програмирању и
PROLOG-у. Ипак, логичко програмирање није заживело колико и остале
парадигме, пре свега јер програми написани у логичком програмском
језику нису довољно ефикасни као програми написани у неком
еквивалентном императивном језику, као и зато што је област примене
релативно мала (коришћен је углавном у домену аутоматског доказивања
теорема, у имплементацији експертских система, презаписивању термова,
аутоматском планирању).

Постоје савремене надоградње основног језика PROLOG које су веома
ефикасне у решавању неких специјализованих проблема (на пример,
B-PROLOG је веома ефикасан систем за решавање проблема задовољења
ограничења, engl. constraint programming).

Развојно окружење
-----------------

Програмски језик PROLOG може и да се интерпретира и да се компилира,
мада се чешће интерпретира. Популарне савремене имплементације су
SWI-Prolog и GNU-Prolog. Ми вам препоручујемо коришћење онлјан
окружења за SWI-Prolog (https://swish.swi-prolog.org/).

Основни појмови језика
----------------------

Логичко програмирање и језик PROLOG су у тесној вези са математичком
логиком. PROLOG програм се задаје помоћу **базе знања** која садржи
чињенице и правила закључивања. Чињенице су атомичке формуле облика:

.. code-block:: prolog

   P(c1, ..., cn).

Ово одговара атомичкој формули :math:`P(c_1, \ldots, c_n)` у којој
је предикат :math:`P` примењен на низ константи :math:`c_1` до
:math:`c_n`. На пример, једна чињеница у бази знања може бити:

.. code-block:: prolog

   grk(sokrat).

Приметимо да су и име предиката ``grk`` и име ``sokrat`` написани
малим словима (што није правописно исправно), јер се називи свих
предиката и називи свих константи морају писати малим словима.

Правила извођења су облика

.. code-block:: prolog

   H :- B1, ..., Bn.

где су и ``H`` и ``B1`` до ``Bn`` атомичке формуле облика

.. code-block:: prolog

   Bi(t1, ..., tm)

у којима су ``t1`` до ``tm`` обично променљиве (мада могу бити и
константе).
   
Свако правило извођења одговара импликацији :math:`B_1 \wedge \ldots
\wedge B_n \Rightarrow H` тј. клаузули :math:`\neg B_1 \vee \ldots
\wedge \neg B_n \vee H` (обратите пажњу на необичан смер импликације
тј. на запис :math:`H \Leftarrow B_1 \wedge \ldots \wedge
B_n`. Формула ``H`` се назива глава правила, формуле ``B1`` до ``Bn``
тело, а симбол ``:-`` се назива врат и он представља наопако записану
импликацију тј. логички везник :math:`\Leftarrow`.

Све променљиве су имплицитно универзално квантификоване. На пример,
правила

.. code-block:: prolog

   covek(X) :- grk(X).
   smrtan(X) :- covek(X).

означавају реченице :math:`(\forall X)(\mathrm{grk}(X) \Rightarrow
\mathrm{covek}(X))` тј. *сви Грци су људи* и :math:`(\forall
x)(\mathrm{covek}(X) \Rightarrow \mathrm{smrtan}(X))` тј. *сви људи су
смртни*.

Поред базе знања, последњи део PROLOG програма је **упит** који је
облика

.. code-block:: prolog

   ?- A1, ..., An                

где су ``A1`` до ``An`` предикати облика:

.. code-block:: prolog

   Ai(t1, ..., tm)

Упит одговара клаузули :math:`\neg A_1 \vee \ldots \vee \neg A_n`.
која је негација формуле :math:`A_1 \wedge \ldots \wedge A_n`. Та
формула је логичка последица базе знања акко и само ако се додавањем
клаузуле упита међу клаузуле базе знања може добити празна формула.

На пример, циљ може бити:

.. code-block:: prolog

   ?- smrtan(sokrat).

На овај упит PROLOG одговара са ``true``, што значи да је та формула
логичка последица базе знања. Заиста, ако је Сократ Грк, ако су сви
Грци људи и ако су сви људи смртни, тада је и сократ смртан.

Дакле PROLOG програм (база знања и упит) представља скуп клаузула
специјалног облика. Такве клаузуле се називају **Хорнове клаузуле** и
за њих је карактеристично да имају највише један позитиван и све
остале негативне литерале. PROLOG методом резолуције изводи празну
клаузулу и ако успе показује вредности променљивих које су до тога
довеле. Захваљујући специјалној структури Хорнових клаузула механизам
резолуције је много ефикаснији него у случају коришћења клаузула
произвољног облика. Са друге стране, наравно, не може се било која
логичка формула изразити у клаузалној форми коришћењем искључиво
Хорнових клаузула.

У нашем примеру, клаузуле нашег програма

.. code-block:: prolog

   grk(sokrat).
   covek(X) :- grk(X).
   smrtan(X) := covek(X).
   ?- smrtan(sokrat).

су

.. math::

   \mathrm{grk}(\mathrm{sokrat})\\
   \neg \mathrm{grk}(X) \vee \mathrm{covek}(X)\\
   \neg \mathrm{covek}(X) \vee \mathrm{smrtan}(X)\\
   \neg \mathrm{smrtan}(\mathrm{sokrat})
   
Резолуцијом средње две клаузуле добија се клаузула :math:`\neg
\mathrm{grk}(X) \vee \mathrm{smrtan}(X)`, која се онда може
резолвирати са првом и четвртом клаузулом (након инстанцијације
:math:`X=\mathrm{sokrat}`) и тако извести празна клаузула.

Обратите пажњу на то да PROLOG закључке изводи искључиво на основу
чињеница и правила које су екплицитно кодирани кроз базу знања. На
пример, одговор на упит

.. code-block:: prolog

   ?- smrtan(platon).

је ``false``, јер се додавањем клаузуле :math:`\neg
\mathrm{smrtan}(\mathrm{platon})` из базе знања не може извести празна
клаузула (јер се на основу наше базе знања не може закључити да је
Платон Грк).

Ако упит садржи променљиве, PROLOG исписује и вредности тих
променљивих које доводе до извођења празне клаузуле. На пример, на
упит

.. code-block:: prolog

   ?- smrtan(X).

PROLOG одговара са ``X = sokrat``. Ако после затражимо друга решења,
добићемо одговор ``false``, јер друга решења не постоје. Ако би база
знања садржала и чињеницу

.. code-block:: prolog

   grk(platon).

Добили бисмо решења ``X=sokrat``, ``X=platon`` и након тога одговор
``false``, што значи да осим ових нема више решења.

Пример: породично стабло
------------------------

Кодирајмо за почетак које особе чине ужу породицу Симпсон (све су
представљене константама) и ког су пола.

.. code-block:: prolog
   
   musko(homer).
   zensko(mardz).
   musko(bart).
   zensko(liza).
   zensko(megi).

Дефинишимо правила којима закључујемо ко су особе у породици Симпсон.
Мушке особе су особе и женске особе су особе. Додајемо зато следећа
два правила извођења.
   
.. code-block:: prolog

   % osobe u porodici Simpson su ili muske ili zenske osobe
   osoba(X) :- musko(X).
   osoba(X) :- zensko(X).

Не заборавимо да импликација тече здесна налево тј. овде су дата
правила :math:`(\forall X)(\mathrm{musko}(X) \Rightarrow
\mathrm{osoba}(X))` и :math:`(\forall X)(\mathrm{zensko}(X)
\Rightarrow \mathrm{osoba}(X))`. Уместо два правила могуће је навести
и једно правило:

.. code-block:: prolog

   % osobe u porodici Simpson su ili muske ili zenske osobe
   osoba(X) :- musko(X) ; zensko(X).

Оператор ``;`` је оператор дисјункције, па је овим задана импликација
:math:`(\forall X)(\mathrm{musko}(X) \vee \mathrm{zensko}(X)
\Rightarrow \mathrm{osoba}(X))`, која приликом превођења у клаузалну
форму даје потпуно исте две клаузуле :math:`\neg \mathrm{musko}(X)
\vee \mathrm{osoba}(X)` и :math:`\neg \mathrm{zensko}(X) \vee
\mathrm{osoba}(X)` као и када се особа опише помоћу два независна
правила.

Коректност овог правила можемо проверити постављањем упита

.. code-block:: prolog

   ?- osoba(X).

Ако је све како треба, требало би да добијемо пет одговора
``X=homer``, ``X=mardz``, ``X=bart``, ``X=liza``, ``X=megi`` и затим
одговор ``false`` који означава да су ово једина решења.

Прошириом базу знања односима родитељ-дете

.. code-block:: prolog
   
   roditelj(homer, bart).
   roditelj(homer, liza).
   roditelj(homer, megi).
   roditelj(mardz, bart).
   roditelj(mardz, liza).
   roditelj(mardz, megi).

Дефинишимо на основу овога предикате ``otac``, ``majka``, ``sin`` и
``cerka``.
   
.. code-block:: prolog

   % osfalsevna pravila izvodjenja za uzu porodicu
   otac(X, Y) :- musko(X), roditelj(X, Y).
   majka(X, Y) :- zensko(X), roditelj(X, Y).
   sin(X, Y) :- musko(Y), roditelj(X, Y).
   cerka(X, Y) :- zensko(Y), roditelj(X, Y).

Прво правило се може тумачити као импликација

.. math::

   (\forall X)(\forall Y)(\mathrm{musko}(X) \wedge \mathrm{roditelj}(X, Y) \Rightarrow \mathrm{otac}(X, Y))

тј. *ако је X мушко и родитељ је особи Y онда је X отац особи
Y*. Остала правила се тумаче аналогно.

Можемо проверити ова правила постављањем разних упита. На пример,
ко су Хомерове ћерке

.. code-block:: prolog

   ?- cerka(homer, X)

PROLOG проналази два решења ``X=liza`` и ``X=megi``.

Покушајмо да дефинишемо сада релације брат и сестра.  Особа X је брат
особи Y ако је X мушко и ако имају заједничког родитеља. Желимо,
дакле, да кодирамо импликацију

.. math::

   (\forall x)(\forall y)(\mathrm{musko}(x) \wedge ((\exists z)\mathrm{roditelj}(z, x) \wedge \mathrm{roditelj}(z, y)) \Rightarrow \mathrm{brat}(x, y))

Она није у Хорновом облику, али се лако може проверити да је
еквивалентна следећој импликацији, која јесте у Хорновом облику.

.. math::

   (\forall x)(\forall y)(\forall z)(\mathrm{musko}(x) \wedge \mathrm{roditelj}(z, x) \wedge \mathrm{roditelj}(z, y) \Rightarrow \mathrm{brat}(x, y))

На основу овога долазимо до следећих правила:
   
.. code-block:: prolog

   brat(X, Y) :- musko(X), roditelj(Z, X), roditelj(Z, Y).
   sestra(X, Y) :- zensko(X), roditelj(Z, X), roditelj(Z, Y).

Покушајмо да тестирамо ова правила тиме што ћемо проверити коме је све
Барт брат. Постављамо упит

.. code-block:: prolog

   ?- brat(bart, X)

PROLOG пронаалази тачне одговоре ``X=liza`` и ``X=megi``, али
проналази и нетачан одговор ``X=bart`` што значи да је Барт сам свој
брат. Заиста, то се потпуно уклапа у наше правило (Барт је мушко и има
заједничког родитеља као Барт). Да бисмо избегли овај погрешан
одговор, потребно је да додамо услов да су променљиве ``X`` и ``Y``
различите. То можемо изразити помоћу ``X \= Y``. Негација и
различитост у PROLOG-у су веома суптилна места и треба их добро
разумети да се не би правиле грешке, али ћемо се том темом посебно
бавити касније. У овом контексту исправно је предикате дефинисати на
следећи начин.
   
   
.. code-block:: prolog
   
   brat(X, Y) :- musko(X), roditelj(Z, X), roditelj(Z, Y),  X \= Y.
   sestra(X, Y) :- zensko(X), roditelj(Z, X), roditelj(Z, Y), X \= Y.

Приметимо да се решење ``X=liza`` проналази два пута и да се решење
``X=megi`` такође проналази два пута. То је због тога што се у оба
случаја проналази једном заједнички родитељ Хомер, а у другом
заједнички родите Марџ (променљива ``Z`` може да узме две различите
вредности, што се не види, јер се на крају исписују само вредности
променљиве ``Y``).

Проширимо сада базу знања чињеницама о Абрахану и Мони који су
Хомерови родитељи и Кленсију и Жеклин који су Марџини родитељи.

.. code-block:: prolog

   % baza znanja za babe i dede (po ocu)
   musko(abraham).
   roditelj(abraham, homer).
   zensko(mona).
   roditelj(mona, homer).
   % baza znanja za babe i dede (po majci)
   musko(klensi).
   roditelj(klensi, mardz).
   zensko(zeklin).
   roditelj(zeklin, mardz).
   

Добијамо упозорење да су чињенице које се односе на предикате
``musko``, ``zensko`` и ``roditelj`` раштркане по програму. Да бисмо
ово упозорење избегли можемо или да групишемо све чињенице за исти
предикат, или да издамо наредбу:

.. code-block:: prolog

   :- discontiguous musko/1, zensko/1, roditelj/2.

Сада једноставно можемо да дефинишемо предикате деда и баба.

.. code-block:: prolog

   deda(X, Y) :- otac(X, Z), roditelj(Z, Y).
   baba(X, Y) :- majka(X, Z), roditelj(Z, Y).

Међутим, још интересантније су дефиниције предиката којима се описују
преци и потомци, јер су те дефиниције у суштини рекурзивне. Довољно је
да дефинишемо, на пример, релацију предак, јер се релација потомак
може веома једноставно дефинисати преко релације предак (то јој је
заправо супротна релација).

.. code-block:: prolog
                
   potomak(X, Y) :- predak(Y, X).

Приметимо да је ова дефиниција исправна без обзира на то што још није
дефинисана релација ``predak``. Чим она буде дефинисана, моћи ћемо да
користимо и дефиницију релације ``potomak``. Наиме, базу знања у
идеалном случају треба схватити као скуп правила чијим се коришћењем
изводе закључци и редослед навођења правила не би требало да утиче на
резултат рада програма (видећемо касније да се од овог идеалног
случаја често одступа, да би се постигла већа ефикасност).

Родитељ неке особе јој је сигурно предак. Такође, било који предак
њеног родитеља јој је такође предак.

.. code-block:: prolog

   predak(X, Y) :- roditelj(X, Y).
   predak(X, Y) :- roditelj(Z, Y), predak(X, Z).

Прво правило, наравно, можемо да тумачимо као

.. math::

   (\forall X)(\forall Y)(\mathrm{roditelj}(X, Y) \Rightarrow \mathrm{predak}(X, Y))

док друга правило можемо да тумачимо као

.. math::

   (\forall X)(\forall Y)(\forall Z)(\mathrm{roditelj}(Z, Y) \wedge \mathrm{predak}(X, Z) \Rightarrow \mathrm{predak}(X, Y))

али и еквивалентно као

.. math::

   (\forall X)(\forall Y)(((\exists Z)\mathrm{roditelj}(Z, Y) \wedge \mathrm{predak}(X, Z)) \Rightarrow \mathrm{predak}(X, Y))


Наравно, претходна два правила можемо објединити коришћењем дисјункције.

.. code-block:: prolog

   predak(X, Y) :- roditelj(X, Y) ; roditelj(Z, Y), predak(X, Z).

На овај начин можемо да сазнамо, на пример, све Мегине претке. На упит

.. code-block:: prolog

   ?- predak(X, megi)

добијамо одговоре ``X=homer``, ``X=mardz``, ``X=klensi``,
``X=zeklin``, ``X=abraham`` и ``X=mona``, при чему редослед одговора
зависи од редоследа навођења чињеница у бази знања.

Проширите, за вежбу, базу знања чињеницама о Хомеровом брату и
Марџиним сестрама и дефинишите предикате стриц, тетка и ујак.

.. infonote::
   
   Нагласимо још једном декларативну природу претходних програма. Ни у
   једном тренутку није било потребе да описујемо начин извођења
   закључака. Довољно је било опишемо услове који треба да важе, а
   систем је тај који својим уграђеним алгоритмима проналази вредности
   које задовољавају дате услове. За логичко програмирање се каже да
   алгоритам обједињава **логику** и **контролу**, при чему програмер
   задаје логику, а контролу извршава систем. Систем може да примени
   различите стратегије извршавања (доказивања теорема) да би што
   ефикасније дошао до решења.


Дрво извођења
-------------

Задатак програмера је да кроз базу знања опише чињенице и правила
закључивања, а задатак PROLOG система је да провери да ли је дати упит
логичка последица базе знања. Иако програмер не би требало да води
рачуна о томе како се та провера врши (рекли смо да се у основи крије
механизам резолуције), често се ипак тај механизам представља дрветом
које помаже да се разуме шта се у позадини дешава.

Функције
--------

За разлику од функционалних, али и императивних и
објектно-оријентисаних језика где програмери углавном дефинишу
функције које на основу задатих аргумената израчунавају резултате,
основу PROLOGA чине предикати тј. релације. Писање функција није
директно подржано. Ипак, већ смо видели да се релације постављањем
одговарајућих упита могу користити и као функције. На пример, у
функционалном језику написали бисмо функцију ``brat(X)`` која би као
параметар примала особу, а као резултат враћала њеног брата.  У
прологу смо дефинисали предикат ``brat(X, Y)``, а затим смо, на
пример, помоћу упита ``brat(X, liza)`` могли да "израчунамо" да је
Лизин брат Барт. Могли смо заправо и више од тога. Упитом ``brat(bart,
X)`` могли смо да израчунамо чији је све брат Барт. Дакле, једна
релација, у зависности од тога како се упит поставља нам омогућава
више израчунавања тј. у себи крије више функција. Видећемо да ово
често може да буде изненађујуће, тј. да добијамо "гратис" могућност
неких израчунавања која нисмо имали у виду када смо дефинисали
релацију.

Дакле, уместо дефинисања функција облика

.. math::

   y = f(x_1, \ldots, x_n)


PROLOG допушта дефинисање релација облика

.. math::

   R(x_1, \ldots, x_n, y)

које се онда могу користити као функције тако што се аргументи
:math:`x_1` до :math:`x_n` фиксирају у упиту, а `y` се зада као
променљива чија се вредност аутоматски одређује. При том, сви
аргументи релације су симетрични и могуће је да било који од њих (па и
више њих истовремено) буду задати као променљиве чије се вредности
одређују.

Негација као неуспех
--------------------

Сви предикати са десне стране правила су задавани у позитивном облику
(ако изузмемо пример различитости две променљиве, што је негативни
облик). PROLOG даје подршку за негацију, али је та негација специфична
и не понаша се исто као класична логичка негација. Тај облик негације
се назива **негација као неуспех** (енгл. negation as failure).

Покушајмо да дефинишемо предикат женско, као негацију предиката мушко.

.. code-block:: prolog
                
   % Negacija kao neuspeh
   zensko(X) :- falset(musko(X)).

Очекујемо да се ово може тумачити као импликација :math:`(\forall
X)(\neg \mathrm{musko}(X) \Rightarrow \mathrm{zensko}(X))`. Међутим,
упити показују на неуобичајено понашање.
   
.. code-block:: prolog

   ?- zensko(homer).  % false
   ?- zensko(mardz).  % true
   ?- zensko(X).      % false

PROLOG успешно одређује да Хомер није женско, да Марџ јесте женско,
међутим, када се упита да наброји женске особе, добија се да не
постоји ни једна. Понашање операције ``falset`` је такво да она успева
ако и само ако јој аргумент не успева.

- Упит ``zensko(homer)`` се своди на упит ``falset(musko(homer))``. Пошто
  упит ``musko(homer)`` успева, упит ``zensko(homer)`` не успева и
  исправно се враћа резултат ``false``.

- Упит ``zensko(mardz)`` се своди на упит ``falset(musko(mardz))``. Пошто
  упит ``musko(mardz)`` не успева, упит ``zensko(mardz)`` успева и
  исправно се враћа резултат ``false``.

- Упит ``zensko(X)`` се своди на упит ``falset(musko(X))``. Упит
  ``musko(X)`` успева, при чему се добија вредност ``X=homer``.
  Међутим, пошто подупит ``musko(X)`` успева, упит ``falset(musko(X))``,
  по дефиницији негације, не успева, па самим тим ``zensko(X)`` враћа
  неисправан резултат ``false``.

.. infonote::

   Негација у PROLOG-у има другачије понашање од класичне логичке
   негације!

Аритметичка израчунавања
------------------------

Иако је PROLOG заснован на математичкој логици и његову основу, као
што смо видели чини симболичко израчунавање, програмирање се не може
замислити без нумеричког израчунавања тј. рада са бројевима. PROLOG
подржава рад и са целим и са реалним бројевима, али jе често за то
потребно користити посебну подршку.

Кренимо од употребе релацијских оператора. Дефинишимо предикате којима
се одређује агрегатно стање воде.

.. code-block:: prolog

   cvrsto(X) :- X < 0.
   tecno(X) :- X >= 0, X < 100.
   gasovito(X) :- X >= 100.                

Ови предикати су коректно дефинисани и дају исправан резултат за сваку
проверу.

Интересантан је и следећи пример. У бази знања памтимо почетак и крај
владавине неколико краљева из династије Немањића. Затим дефинишемо да
је неко био краљ током дате године, ако је та година унутар интервала
његове владавине.

.. code-block:: prolog

   kralj_od_do(stefan, 1217, 1228).
   kralj_od_do(radoslav, 1228, 1233).
   kralj_od_do(vladislav, 1234, 1243).
   kralj_od_do(uros, 1243, 1276).
   kralj_od_do(dragutin, 1276, 1282).
   kralj(Ime, Godina) :- kralj_od_do(Ime, GodinaOd, GodinaDo),
                         GodinaOd =< Godina, Godina =< GodinaDo.
   
Сада можемо да питамо и ко је био краљ током 1250. године.

.. code-block:: prolog

   ?- kralj(Ime, 1250).

Систем исправно изводи закључак да је једини краљ током те године био
Урош.
                         
Релацијски оператори се, дакле, на први поглед понашају прилично
очекивано. Међутим, PROLOG неће успети да нам одговори током којих је
све година Стефан био краљ.


.. code-block:: prolog

   ?- kralj(stefan, Godina).

На овај упит добијамо odgovor

::

   Arguments are not sufficiently instantiated
   In:
   [2] 1217 =< _1702
   [1] kralj(stefan,_1756) at  line 7

који нам одговара да није могуће да се релацијски оператор примени на
променљиву којој још није одређена вредност (у нашем случају то је
променљива ``Godina``).
   
Размотримо сада следећи пример предиката који користи операцију
сабирања.

.. code-block:: prolog

   zbir(X, Y, Z) :- Z == X + Y.

Ова дефиниција је синтаксички исправна, што значи да PROLOG зна нешто
о сабирању и једнакости. Међутим, ако поставимо следећи упит:

.. code-block:: prolog

   ?- zbir(3, 5, 8).

неочекивано добијамо неисправан одговор ``false``. И на упит

.. code-block:: prolog

   ?- zbir(3, 5, X).

добијамо одговор ``false``. Међутим, ако поставимо упит


.. code-block:: prolog

   ?- zbir(3, 5, 3 + 5).

Добијамо одговор ``true``.

Нешто очигледно није како треба. Покушајмо да променимо дефиницију
предиката ``zbir`` и да уместо оператора ``==`` употребимо оператор
``=``.

.. code-block:: prolog

   zbir(X, Y, Z) :- Z = X + Y.

И ова дефиниција је синтаксички исправна, што значи да PROLOG користи
и оператор ``==`` и ``=`` (и видећемо да они означавају различите
ствари). Међутим, ако поставимо следећи упит:

.. code-block:: prolog

   ?- zbir(3, 5, 8).

поново добијамо неисправан одговор ``false``. Са друге стране, на упит

.. code-block:: prolog

   ?- zbir(3, 5, X).

сада добијамо одговор ``3+5``, што је делимично тачно (јер, наравно,
очекујемо одговор ``8``). Поново на упит

.. code-block:: prolog

   ?- zbir(3, 5, 3 + 5).

добијамо тачан одговор ``true``.

Шта се заправо овде догађа? Оператор ``==`` је **оператор провере
једнакости** два терма и он враћа вредност тачно ако и само ако су
термови идентични.

- Упит ``?- zbir(3, 5, 8)`` се своди на ``8 == 3+5``. Проверава се да ли
  су терм са леве и десне стране идентични, они то нису и добија се
  одговор ``false``.

- Упит ``?- zbir(3, 5, X)`` се своди на ``X == 3+5``. Проверава се да ли
  су терм са леве и десне стране идентични, они то нису и добија се
  одговор ``false``.

- Упит ``?- zbir(3, 5, 3+5)`` се своди на ``3+5 == 3+5``. Проверава се да
  ли су терм са леве и десне стране идентични, они јесу идентични и
  добија се одговор ``true``.

Оператор ``=`` је **оператор унификације** и он враћа вредност тачно
ако и само ако се термови могу унификовати тј. ако се променљивама
доделити вредности тако да два термови постану једнаки након те
доделе.

- Упит ``?- zbir(3, 5, 8)`` се своди на ``8 = 3+5``. Пошто се термови не
  могу унификовати (у њима се ни не јављају променљиве) добија се
  одговор ``false``.

- Упит ``?- zbir(3, 5, X)`` се своди на ``X = 3+5``. Термови са леве и
  десне стране се могу унификовати тако што се променљивој ``X``
  додели вредност ``3+5``, па упит успева уз резултат ``X=3+5``.

- Упит ``?- zbir(3, 5, 3+5)`` се своди на ``3+5 == 3+5``. Термови са леве
  и десне стране су идентични (па се самим тим могу и унификовати) и
  као резултат се добија ``true``.

Објаснили смо операторе ``==`` и ``=``, међутим ни један од њих нам не
одговара у потпуности. Да би се извршило сабирање (или било која друга
аритметичка операција), потребно је да се употреби оператор ``is``.
Њиме се проверава да ли се термови са леве и десне стране могу
унификовати, али тек након што се терм са десне стране израчуна.

.. code-block:: prolog

   zbir(X, Y, Z) :- Z is X + Y.
   
- Упит ``?- zbir(3, 5, 8)`` се своди на ``8 is 3+5``. Када се израчуна
  вредност терма са десне стране, добија се вредност 8, па пошто су
  лева и десна страна тада једнаке, добија се исправан резултат
  ``true``.

- Упит ``?- zbir(3, 5, X)`` се своди на ``X is 3+5``. Када се израчуна
  терм са десне стране добијају се термови ``X`` и ``8``, па пошто се
  они могу унификовати тако што се променљивој ``X`` додели вредност
  ``8``, упит успева уз резултат ``X=8``.

- Упит ``?- zbir(3, 5, 3+5)`` се своди на ``3+5 is 3+5``. Када се
  израчуна вредност терма са десне стране, добијају се термови ``3+5``
  и ``8``, који се не могу унификовати и добија се погрешан резултат
  ``false``.

Дакле, ако употребимо оператор ``is`` добијамо исправну могућност
израчунавања вредности израза (у том светлу најзначајнији нам је упит
``zbir(3, 5, X)``), при чему и провера израчунате вредности ради
исправно (упит ``zbir(3, 5, 8)`` коректно ради).

Међутим, важно је нагласити да се из ове релације не могу издвојити
друге функције. На пример, упит ``?- zbir(X, 5, 8)`` даје одговор
``no``. Решавање једначина, дакле, није могуће.

Оператори поређења на једнакост ``=:=`` и различитост ``=\=`` такође
врше израчунавање термова пре поређења.

.. infonote::

   Када год употребљавате аритметичке операторе, морате употребити и
   оператор ``is``, ``=:=`` или ``=\=`` којим ћете натерати систем да
   их примени тј. да изврши потребна израчунавања!

Релацијски оператори су описани у следећој табели.
   
+-------------+------------------------------------------------------------+
| Оператор    | Опис                                                       |
+=============+============================================================+
| ``=``       | Унификује два терма                                        |
+-------------+------------------------------------------------------------+
| ``\=``      | Негација унификације                                       |
+-------------+------------------------------------------------------------+
| ``==``      | Једнакост два терма                                        |
+-------------+------------------------------------------------------------+
| ``=:=``     | Једнакост израчунатих вредности два терма                  |
+-------------+------------------------------------------------------------+
| ``=\=``     | Негација једнакости                                        |
+-------------+------------------------------------------------------------+
| ``=<``      | Мање од или једнако                                        |
+-------------+------------------------------------------------------------+
| ``<``       | Мање од                                                    |
+-------------+------------------------------------------------------------+
| ``>=``      | Веће од или једнако                                        |
+-------------+------------------------------------------------------------+
| ``>``       | Веће од                                                    |
+-------------+------------------------------------------------------------+

Аритметички оператори су описани у следећој табели.

+-------------+--------------------------------------------------+
| Оператор    | Опис                                             |
+=============+==================================================+
| ``+``       | Сабира два броја.                                |
+-------------+--------------------------------------------------+
| ``-``       | Одузима други број од првог.                     |
+-------------+--------------------------------------------------+
| ``*``       | Множи два броја.                                 |
+-------------+--------------------------------------------------+
| ``/``       | Дели први број са другим.                        |
+-------------+--------------------------------------------------+
| ``//``      | Целобројно дељење (добија целобројни резултат).  |
+-------------+--------------------------------------------------+
| ``mod``     | Остатак при дељењу (добија остатак од дељења).   |
+-------------+--------------------------------------------------+
| ``**``      | Степеновање (први број се степенује другим).     |
+-------------+--------------------------------------------------+

.. questionnote::

   Дефинисати предикат који израчунава степен броја (изложилац је
   ненегативан цео број). Основна идеја је да пратимо рекурзивну
   дефиницију која је у језику Haskell била изражена на следећи начин:

   .. code-block:: haskell

      stepen x 0 = 1
      stepen x n = x * stepen x (n - 1)

   Уместо функције у језику PROLOG дефинишемо предикат тј. релацију.
   Поново имамо два случаја (излаз из рекурзије и рекурзивни корак).
      
   .. code-block::

      stepen(X, 0, 1).
      stepen(X, N, S) :- N > 0, N1 is N-1, stepen(X, N1, S1), S is X * S1.

   Пошто се у првом правилу вредност променљиве ``X`` не користи,
   добијамо упозорење ``Singleton variable X``. Да би се оно избегло,
   уместо назива ``X`` можемо употребити анонимну променљиву која се
   обележава подвлаком.

   .. code-block::

      stepen(_, 0, 1).
   
   Прво правило можемо читати као:

   - нулти степен било ког броја је 1*

   Друго правило се може протумачити као:

   - ако је ``N`` позитиван, ако је ``N1`` једнако вредности броја
     ``N`` након што се она умањи за 1, ако је ``S1`` вредност степена
     ``X`` на ``N1`` и ако је ``S`` једнака вредности која се добије
     када се израчуна производ броја ``X`` и те вредности ``S1``, тада
     је ``S`` вредност степена ``X`` на ``N``.

   Нагласимо да је потребно употребити оператор ``is`` да би се број
   ``N`` умањио за 1 као и да би се резултат рекурзивног позива ``S1``
   помножио са ``X``. Ако не бисмо у другом правилу навели услов ``N > 0``,
   тада би се прво пријавила исправно израчуната вредност
   степена, али би се приликом тражења даљих решења запало у
   бесконачну рекурзију јер не би било услова који би спречио да се
   друго правило примењује на ``N=0`` а затим и на негативне вредности
   променљиве ``N``.
      
   Можемо дефинисати и ефикаснију имплементацију степеновања.

   .. code-block::

      stepen(X, 0, 1).
      stepen(X, N, S) :- N > 0, N mod 2 =:= 0,
                         N1 is N // 2, X2 is X * X, stepen(X2, N1, S).
      stepen(X, N, S) :- N > 0, N mod 2 =\= 0,
                         N1 is N-1, stepen(X, N1, S1), S is S1 * X.


.. questionnote::

   Дефинисати предикат који Еуклидовим алгоритмом израчунава НЗД два
   дата природна броја.

   .. code-block::

      nzd(A, 0, A).
      nzd(A, B, N) :- B > 0, M is A mod B, nzd(B, M, N).

Сечење
------

У циљу смањења простора претраге, спречавања нежељеног бектрекинга и
на тај начин изостављања неких нетачних одговора или оптимизације
времена извршавања PROLOG уводи **оператор сечења** или **рез**
(енгл. cut).  Овај се оператор означава са ``!``, увек успева (када се
наведе у правилу, сматра се да је резултат његовог израчунавања
тачан), али у повратку спречава бектрекинг и враћање преко њега здесна
налево. Размотримо неколико примера.

Максимум се може дефинисати на следећи начин:

.. code-block:: prolog

   min(X, Y, X) :- X =< Y.
   min(X, Y, Y) :- Y < X.

Ако се на основу првог правила одреди да је ``X =< Y``, тада нема
потребе приликом бектрекинга проверавати друго правило јер унапред
знамо да његов услов неће бити испуњен. Зато се програм може убрзати
тако што се иза услова у првом правилу дода оператор сечења.


.. code-block:: prolog

   min(X, Y, X) :- X =< Y, !.
   max(X, Y, Y) :- Y < X.

Приликом упита ``?- max(3, 5, M)`` извршиће се унификација којом ће се
везати променљива ``X`` са вредношћу 3, ``Y`` са вредношћу 5 и ``M``
са вредношћу ``X`` тј. 3, провериће се услов ``3 =< 5`` који ће бити
тачан, провериће се оператор сечења који је тачан када се рачуна слева
надесно и доћи ће се до краја правила и пријавиће се резултат ``M=3``.

Претходна употреба оператора сечења је **зелена**, јер се оператором
сечења програм само убрзава и не мења му се значење.

Можемо отићи и корак даље и из другог правила изоставити услов ``Y <
X``. Наиме, пошто у првом правилу постоји сечење, јасно је да ће се до
провере другог правила стићи само ако услов првог правила није испуњен
тј. ако не важи ``X =< Y`` тј. сигурно тада знамо да важи ``Y > X``.
   
.. code-block:: prolog

   max(X, Y, X) :- X =< Y, !.
   max(X, Y, Y).

Вредност максимума бројева 3 и 5 можемо израчунати у ком редоследу
да су задати.

- Упит ``?- max(3, 5, M)`` се извршава на већ описани начин, добија се
  резултат ``M=5`` и због сечења се не траже друга решења.
- Упит ``?- max(5, 3, M)`` се извршава тако што се унификује ``X`` са
  5, ``Y`` са 3, проверава се ``5 =< 3`` и пошто тај услов није
  испуњен, одустаје се од овог правила. Затим се прелази на друго
  правило, унификују се ``X`` и 5, ``Y`` и ``3`` и ``M`` и ``Y``
  тј. 3, након чега се пријављује резултат ``M=3``. Приликом тражења
  других решења враћамо се уназад, нализимо на сечење и бектрекинг се
  прекида.
   
Ипак, ова употреба оператора сечења је **црвена**, јер се оператором
сечења мења значење програма. Заиста, наредни упит сасвим неочекивано
враћа нетачан одговор ``true``.

.. code-block:: prolog

   ?- min(2, 3, 3).

Приликом његовог извршавања, покушава се унификација са левом страном
првог правила што не успева. Унификација са левом страном другог
правила успева и пошто више нема услова на десној страни тог правила,
пријављује се одговор ``true``.

Дакле, иако сечење може скратити програм и омогућити нам да неке
услове не морамо да пишемо, треба бити веома обазриви јер такав
програм може исправно радити за неке услове, а престати да ради
исправно за неке друге упите. Приликом употребе сечења пожељно је увек
користити зелени, а не црвени облик сечења.


Сечење (додуше црвено) нам може помоћи да поједноставимо неке од
претходних дефиниција и да избегнемо експлицитно навођење додатних
услова. На пример, дефиниција степеновања се упрошћава.

.. code-block:: prolog

   stepen(_, 0, 1) :- !.
   stepen(X, N, S) :- N mod 2 =:= 0,
                      N1 is N // 2, X2 is X * X, stepen(X2, N1, S), !.
   stepen(X, N, S) :- N1 is N-1, stepen(X, N1, S1), S is S1 * X.


Листе
-----

Као и други програмски језици и програмски језик PROLOG пружа подршку
за рад са листама података. Слично као што смо видели у програмском
језику Haskell, листа је или празна (``[]``) или се разлаже на главу и
реп (``[X|XS]``). Листе се задају навођењем елемената између угластих
заграда (нпр. ``[3, 8, 4, 2]``).

Кренимо од предиката ``myMember`` који проверава да ли елемент ``E``
припада листи (то ради уграђени предикат ``member``, тако да ову
имплементацију приказујемо само ради илустрације).  Елемент не припада
празној листи, тако да случај празне листе не треба да буде обрађен
(ако нешто не постоји у бази знања, оно се аутоматски сматра
нетачним). Елемент припада непразној листи акко је једнак глави или
припада репу. Подсетимо се, дисјункцију можемо записати оператором
``;``.

.. code-block:: prolog
                
   myMember(E, [X|XS]) :- E = X ; myMember(E, XS).

Наравно, ово правило је могуће разбити на два.

.. code-block:: prolog
                
   myMember(X, [X|_]).
   myMember(E, [_|XS]) :- myMember(E, XS).

Јасно је да коришћењем овог предиката можемо проверити да ли дати број
припада датој листи, тј. да наредни упити враћају исправне резултате.

.. code-block:: prolog

   ?- myMember(3, [1, 2, 3, 4]).   % true
   ?- myMember(5, [1, 2, 3, 4]).   % false


Међутим, можда мало неочекивано, овај предикат се може употребити и да
се наброји један по један елемент листе. Наредни упит

.. code-block:: prolog

   ?- myMember(X, [1, 2, 3, 4]).
   
даје резултат ``X=1``, затим ``X=2``, ``X=3`` и на крају ``X=4``.

Ако је елемент једнак глави листе, он је члан листе и нема више
потребе да се проверава да ли припада репу. Зато на крај првог правила
можемо поставити рез.

.. code-block:: prolog

   myMember(E, [E|_]) :- !.
   myMember(E, [_|XS]) :- myMember(E, XS).

Међутим, ова измена спречава употребу предиката ``myMember`` за
набрајање свих елемената листе, јер се након пријављивања првог
елемента спречава бектрекинг преко реза. Зато се верзија без реза ипак
сматра бољом, ако се планира употреба за набрајање свих елемената
листе (што је, видећемо, доста чест случај).

Иуструјмо рад са листама кроз још неколико предиката.


.. questionnote::

   Дефинисати предикат који одређује дужину листе.

   .. code-block:: prolog
                
      myLength([], 0).
      myLength([_|XS], R) :- myLength(XS, R1), R is R1 + 1.

.. questionnote::

   Дефинисати предикат који одређује последњи елемент листе.
   
   .. code-block:: prolog

      myLast([X], X).
      myLast([_|XS], R) :- myLast(XS, R).

.. questionnote::

   Дефинисати предикат који одређује елемент листе на датој позицији.
   
   .. code-block:: prolog

      kth([X|_], 0, X) :- !.
      kth([_|XS], K, R) :- K1 is K-1, kth(XS, K1, R).

.. questionnote::

   Дефинисати предикат који обрће листу.
      
   .. code-block:: prolog
                   
      obrni([], []).
      obrni([X|XS], R) :- obrni(XS, R1), dodajNaKraj(R1, X, R).
      
      dodajNaKraj([], E, [E]).
      dodajNaKraj([X|XS], E, [X|XS1]) :- dodajNaKraj(XS, E, XS1).
    
   .. code-block:: prolog
    
      obrni([], A, A).
      obrni([X|XS], A, R) :- obrni(XS, [X|A], R).
      obrni(XS, R) :- obrni(XS, [], R).

   

   .. code-block:: prolog

      proveriPalindrom(XS) :- obrni(XS, XS).


.. code-block:: prolog
                
   myFlatten([], []).
   myFlatten([H|T], X) :- is_list(H), myFlatten(H, H1), myFlatten(T, T1), append(H1, T1, X), !.
   myFlatten([H|T], [H|T1]) :- myFlatten(T, T1).

.. code-block:: prolog
                
   compress([], []).
   compress([X,X|XS], R) :- compress([X|XS], R), !.
   compress([X|XS], [X|R1]) :- compress(XS, R1).

.. code-block:: prolog
 
   merge([], YS, YS).
   merge(XS, [], XS).
   merge([X|XS], [Y|YS], R) :- X < Y, merge(XS, [Y|YS], R1), R = [X|R1], !.
   merge([X|XS], [Y|YS], R) :- merge([X|XS], YS, R1), R = [Y|R1].

