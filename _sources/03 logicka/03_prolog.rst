Програмски језик PROLOG
=======================

Најзначајнији представник логичке парадигме је програмски језик
PROLOG.

Кратак историјат развоја
------------------------

Пролог (Prolog) је декларативни, логички програмски језик који је
развијен током 1970-их година, намењен пре свега решавању задатака
симболичке природе.Творцима овог језика сматрају се Алаин Колмерауер
(енгл. Alain Colmerauer) и Филипе Роусел (енгл. Philippe Roussel) на
Универзитету у Марсељу (енгл. University of Aix-Marseille) и Роберт
Ковалски (енгл. Robert Kowalski) са Универзитета у Единбургу
(енгл. University of Edinburgh). На развој пролога значајно је утицао
метод резолуције који је развио Алан Робертсон 1965.

Осамдесетих година прошлог века је постојала група научника која се
бавила рачунарством, која је веровала да је логичко програмирање
најбољи начин да се превазиђе сложеност и непоузданост императивних
језика. У Јапану који је у то доба био у великој технолошкој
експанзији направљен је велики пројекат развоја
рачунара 5. генерације, заснованих на логичком програмирању и
PROLOG-у. Ипак, логичко програмирање није заживело колико и остале
парадигме, пре свега јер програми написани у логичком програмском
језику нису довољно ефикасни као програми написани у неком
еквивалентном императивном језику, као и зато што је област примене
релативно мала (коришћен је углавном у домену аутоматског доказивања
теорема, у имплементацији експертских система, презаписивању термова,
аутоматском планирању).

Постоје савремене надоградње основног језика PROLOG које су веома
ефикасне у решавању неких специјализованих проблема (на пример,
B-PROLOG је веома ефикасан систем за решавање проблема задовољења
ограничења, engl. constraint programming).

Развојно окружење
-----------------

Програмски језик PROLOG може и да се интерпретира и да се компилира,
мада се чешће интерпретира. Популарне савремене имплементације су
SWI-Prolog и GNU-Prolog. Ми вам препоручујемо коришћење онлјан
окружења за SWI-Prolog (https://swish.swi-prolog.org/).

Основни појмови језика
----------------------

Логичко програмирање и језик PROLOG су у тесној вези са математичком
логиком. PROLOG програм се задаје помоћу **базе знања** која садржи
чињенице и правила закључивања. Чињенице су атомичке формуле облика:

.. code-block:: prolog

   P(c1, ..., cn).

Ово одговара атомичкој формули :math:`P(c_1, \ldots, c_n)` у којој
је предикат :math:`P` примењен на низ константи :math:`c_1` до
:math:`c_n`. На пример, једна чињеница у бази знања може бити:

.. code-block:: prolog

   grk(sokrat).

Приметимо да су и име предиката ``grk`` и име ``sokrat`` написани
малим словима (што није правописно исправно), јер се називи свих
предиката и називи свих константи морају писати малим словима.

Правила извођења су облика

.. code-block:: prolog

   H :- B1, ..., Bn.

где су и ``H`` и ``B1`` до ``Bn`` атомичке формуле облика

.. code-block:: prolog

   Bi(t1, ..., tm)

у којима су ``t1`` до ``tm`` обично променљиве (мада могу бити и
константе).
   
Свако правило извођења одговара импликацији :math:`B_1 \wedge \ldots
\wedge B_n \Rightarrow H` тј. клаузули :math:`\neg B_1 \vee \ldots
\wedge \neg B_n \vee H` (обратите пажњу на необичан смер импликације
тј. на запис :math:`H \Leftarrow B_1 \wedge \ldots \wedge
B_n`. Формула ``H`` се назива глава правила, формуле ``B1`` до ``Bn``
тело, а симбол ``:-`` се назива врат и он представља наопако записану
импликацију тј. логички везник :math:`\Leftarrow`.

Све променљиве су имплицитно универзално квантификоване. На пример,
правила

.. code-block:: prolog

   covek(X) :- grk(X).
   smrtan(X) :- covek(X).

означавају реченице :math:`(\forall X)(\mathrm{grk}(X) \Rightarrow
\mathrm{covek}(X))` тј. *сви Грци су људи* и :math:`(\forall
x)(\mathrm{covek}(X) \Rightarrow \mathrm{smrtan}(X))` тј. *сви људи су
смртни*.

Поред базе знања, последњи део PROLOG програма је **упит** који је
облика

.. code-block:: prolog

   ?- A1, ..., An                

где су ``A1`` до ``An`` предикати облика:

.. code-block:: prolog

   Ai(t1, ..., tm)

Упит одговара клаузули :math:`\neg A_1 \vee \ldots \vee \neg A_n`.
која је негација формуле :math:`A_1 \wedge \ldots \wedge A_n`. Та
формула је логичка последица базе знања акко и само ако се додавањем
клаузуле упита међу клаузуле базе знања може добити празна формула.

На пример, циљ може бити:

.. code-block:: prolog

   ?- smrtan(sokrat).

На овај упит PROLOG одговара са ``true``, што значи да је та формула
логичка последица базе знања. Заиста, ако је Сократ Грк, ако су сви
Грци људи и ако су сви људи смртни, тада је и сократ смртан.

Дакле PROLOG програм (база знања и упит) представља скуп клаузула
специјалног облика. Такве клаузуле се називају **Хорнове клаузуле** и
за њих је карактеристично да имају највише један позитиван и све
остале негативне литерале. PROLOG методом резолуције изводи празну
клаузулу и ако успе показује вредности променљивих које су до тога
довеле. Захваљујући специјалној структури Хорнових клаузула механизам
резолуције је много ефикаснији него у случају коришћења клаузула
произвољног облика. Са друге стране, наравно, не може се било која
логичка формула изразити у клаузалној форми коришћењем искључиво
Хорнових клаузула.

У нашем примеру, клаузуле нашег програма

.. code-block:: prolog

   grk(sokrat).
   covek(X) :- grk(X).
   smrtan(X) := covek(X).
   ?- smrtan(sokrat).

су

.. math::

   \mathrm{grk}(\mathrm{sokrat})\\
   \neg \mathrm{grk}(X) \vee \mathrm{covek}(X)\\
   \neg \mathrm{covek}(X) \vee \mathrm{smrtan}(X)\\
   \neg \mathrm{smrtan}(\mathrm{sokrat})
   
Резолуцијом средње две клаузуле добија се клаузула :math:`\neg
\mathrm{grk}(X) \vee \mathrm{smrtan}(X)`, која се онда може
резолвирати са првом и четвртом клаузулом (након инстанцијације
:math:`X=\mathrm{sokrat}`) и тако извести празна клаузула.

Обратите пажњу на то да PROLOG закључке изводи искључиво на основу
чињеница и правила које су екплицитно кодирани кроз базу знања. На
пример, одговор на упит

.. code-block:: prolog

   ?- smrtan(platon).

је ``false``, јер се додавањем клаузуле :math:`\neg
\mathrm{smrtan}(\mathrm{platon})` из базе знања не може извести празна
клаузула (јер се на основу наше базе знања не може закључити да је
Платон Грк).

Ако упит садржи променљиве, PROLOG исписује и вредности тих
променљивих које доводе до извођења празне клаузуле. На пример, на
упит

.. code-block:: prolog

   ?- smrtan(X).

PROLOG одговара са ``X = sokrat``. Ако после затражимо друга решења,
добићемо одговор ``false``, јер друга решења не постоје. Ако би база
знања садржала и чињеницу

.. code-block:: prolog

   grk(platon).

Добили бисмо решења ``X=sokrat``, ``X=platon`` и након тога одговор
``false``, што значи да осим ових нема више решења.

Пример: породично стабло
------------------------

Кодирајмо за почетак које особе чине ужу породицу Симпсон (све су
представљене константама) и ког су пола.

.. code-block:: prolog
   
   musko(homer).
   zensko(mardz).
   musko(bart).
   zensko(liza).
   zensko(megi).

Дефинишимо правила којима закључујемо ко су особе у породици Симпсон.
Мушке особе су особе и женске особе су особе. Додајемо зато следећа
два правила извођења.
   
.. code-block:: prolog

   % osobe u porodici Simpson su ili muske ili zenske osobe
   osoba(X) :- musko(X).
   osoba(X) :- zensko(X).

Не заборавимо да импликација тече здесна налево тј. овде су дата
правила :math:`(\forall X)(\mathrm{musko}(X) \Rightarrow
\mathrm{osoba}(X))` и :math:`(\forall X)(\mathrm{zensko}(X)
\Rightarrow \mathrm{osoba}(X))`. Уместо два правила могуће је навести
и једно правило:

.. code-block:: prolog

   % osobe u porodici Simpson su ili muske ili zenske osobe
   osoba(X) :- musko(X) ; zensko(X).

Оператор ``;`` је оператор дисјункције, па је овим задана импликација
:math:`(\forall X)(\mathrm{musko}(X) \vee \mathrm{zensko}(X)
\Rightarrow \mathrm{osoba}(X))`, која приликом превођења у клаузалну
форму даје потпуно исте две клаузуле :math:`\neg \mathrm{musko}(X)
\vee \mathrm{osoba}(X)` и :math:`\neg \mathrm{zensko}(X) \vee
\mathrm{osoba}(X)` као и када се особа опише помоћу два независна
правила.

Коректност овог правила можемо проверити постављањем упита

.. code-block:: prolog

   ?- osoba(X).

Ако је све како треба, требало би да добијемо пет одговора
``X=homer``, ``X=mardz``, ``X=bart``, ``X=liza``, ``X=megi`` и затим
одговор ``false`` који означава да су ово једина решења.

Прошириом базу знања односима родитељ-дете

.. code-block:: prolog
   
   roditelj(homer, bart).
   roditelj(homer, liza).
   roditelj(homer, megi).
   roditelj(mardz, bart).
   roditelj(mardz, liza).
   roditelj(mardz, megi).

Дефинишимо на основу овога предикате ``otac``, ``majka``, ``sin`` и
``cerka``.
   
.. code-block:: prolog

   % osfalsevna pravila izvodjenja za uzu porodicu
   otac(X, Y) :- musko(X), roditelj(X, Y).
   majka(X, Y) :- zensko(X), roditelj(X, Y).
   sin(X, Y) :- musko(Y), roditelj(X, Y).
   cerka(X, Y) :- zensko(Y), roditelj(X, Y).

Прво правило се може тумачити као импликација

.. math::

   (\forall X)(\forall Y)(\mathrm{musko}(X) \wedge \mathrm{roditelj}(X, Y) \Rightarrow \mathrm{otac}(X, Y))

тј. *ако је X мушко и родитељ је особи Y онда је X отац особи
Y*. Остала правила се тумаче аналогно.

Можемо проверити ова правила постављањем разних упита. На пример,
ко су Хомерове ћерке

.. code-block:: prolog

   ?- cerka(homer, X)

PROLOG проналази два решења ``X=liza`` и ``X=megi``.

Покушајмо да дефинишемо сада релације брат и сестра.  Особа X је брат
особи Y ако је X мушко и ако имају заједничког родитеља. Желимо,
дакле, да кодирамо импликацију

.. math::

   (\forall x)(\forall y)(\mathrm{musko}(x) \wedge ((\exists z)\mathrm{roditelj}(z, x) \wedge \mathrm{roditelj}(z, y)) \Rightarrow \mathrm{brat}(x, y))

Она није у Хорновом облику, али се лако може проверити да је
еквивалентна следећој импликацији, која јесте у Хорновом облику.

.. math::

   (\forall x)(\forall y)(\forall z)(\mathrm{musko}(x) \wedge \mathrm{roditelj}(z, x) \wedge \mathrm{roditelj}(z, y) \Rightarrow \mathrm{brat}(x, y))

На основу овога долазимо до следећих правила:
   
.. code-block:: prolog

   brat(X, Y) :- musko(X), roditelj(Z, X), roditelj(Z, Y).
   sestra(X, Y) :- zensko(X), roditelj(Z, X), roditelj(Z, Y).

Покушајмо да тестирамо ова правила тиме што ћемо проверити коме је све
Барт брат. Постављамо упит

.. code-block:: prolog

   ?- brat(bart, X)

PROLOG пронаалази тачне одговоре ``X=liza`` и ``X=megi``, али
проналази и нетачан одговор ``X=bart`` што значи да је Барт сам свој
брат. Заиста, то се потпуно уклапа у наше правило (Барт је мушко и има
заједничког родитеља као Барт). Да бисмо избегли овај погрешан
одговор, потребно је да додамо услов да су променљиве ``X`` и ``Y``
различите. То можемо изразити помоћу ``X \= Y``. Негација и
различитост у PROLOG-у су веома суптилна места и треба их добро
разумети да се не би правиле грешке, али ћемо се том темом посебно
бавити касније. У овом контексту исправно је предикате дефинисати на
следећи начин.
   
   
.. code-block:: prolog
   
   brat(X, Y) :- musko(X), roditelj(Z, X), roditelj(Z, Y),  X \= Y.
   sestra(X, Y) :- zensko(X), roditelj(Z, X), roditelj(Z, Y), X \= Y.

Приметимо да се решење ``X=liza`` проналази два пута и да се решење
``X=megi`` такође проналази два пута. То је због тога што се у оба
случаја проналази једном заједнички родитељ Хомер, а у другом
заједнички родите Марџ (променљива ``Z`` може да узме две различите
вредности, што се не види, јер се на крају исписују само вредности
променљиве ``Y``).

Проширимо сада базу знања чињеницама о Абрахану и Мони који су
Хомерови родитељи и Кленсију и Жеклин који су Марџини родитељи.

.. code-block:: prolog

   % baza znanja za babe i dede (po ocu)
   musko(abraham).
   roditelj(abraham, homer).
   zensko(mona).
   roditelj(mona, homer).
   % baza znanja za babe i dede (po majci)
   musko(klensi).
   roditelj(klensi, mardz).
   zensko(zeklin).
   roditelj(zeklin, mardz).
   

Добијамо упозорење да су чињенице које се односе на предикате
``musko``, ``zensko`` и ``roditelj`` раштркане по програму. Да бисмо
ово упозорење избегли можемо или да групишемо све чињенице за исти
предикат, или да издамо наредбу:

.. code-block:: prolog

   :- discontiguous musko/1, zensko/1, roditelj/2.

Сада једноставно можемо да дефинишемо предикате деда и баба.

.. code-block:: prolog

   deda(X, Y) :- otac(X, Z), roditelj(Z, Y).
   baba(X, Y) :- majka(X, Z), roditelj(Z, Y).

Међутим, још интересантније су дефиниције предиката којима се описују
преци и потомци, јер су те дефиниције у суштини рекурзивне. Довољно је
да дефинишемо, на пример, релацију предак, јер се релација потомак
може веома једноставно дефинисати преко релације предак (то јој је
заправо супротна релација).

.. code-block:: prolog
                
   potomak(X, Y) :- predak(Y, X).

Приметимо да је ова дефиниција исправна без обзира на то што још није
дефинисана релација ``predak``. Чим она буде дефинисана, моћи ћемо да
користимо и дефиницију релације ``potomak``. Наиме, базу знања у
идеалном случају треба схватити као скуп правила чијим се коришћењем
изводе закључци и редослед навођења правила не би требало да утиче на
резултат рада програма (видећемо касније да се од овог идеалног
случаја често одступа, да би се постигла већа ефикасност).

Родитељ неке особе јој је сигурно предак. Такође, било који предак
њеног родитеља јој је такође предак.

.. code-block:: prolog

   predak(X, Y) :- roditelj(X, Y).
   predak(X, Y) :- roditelj(Z, Y), predak(X, Z).

Прво правило, наравно, можемо да тумачимо као

.. math::

   (\forall X)(\forall Y)(\mathrm{roditelj}(X, Y) \Rightarrow \mathrm{predak}(X, Y))

док друга правило можемо да тумачимо као

.. math::

   (\forall X)(\forall Y)(\forall Z)(\mathrm{roditelj}(Z, Y) \wedge \mathrm{predak}(X, Z) \Rightarrow \mathrm{predak}(X, Y))

али и еквивалентно као

.. math::

   (\forall X)(\forall Y)(((\exists Z)\mathrm{roditelj}(Z, Y) \wedge \mathrm{predak}(X, Z)) \Rightarrow \mathrm{predak}(X, Y))


Наравно, претходна два правила можемо објединити коришћењем дисјункције.

.. code-block:: prolog

   predak(X, Y) :- roditelj(X, Y) ; roditelj(Z, Y), predak(X, Z).

На овај начин можемо да сазнамо, на пример, све Мегине претке. На упит

.. code-block:: prolog

   ?- predak(X, megi)

добијамо одговоре ``X=homer``, ``X=mardz``, ``X=klensi``,
``X=zeklin``, ``X=abraham`` и ``X=mona``, при чему редослед одговора
зависи од редоследа навођења чињеница у бази знања.

Проширите, за вежбу, базу знања чињеницама о Хомеровом брату и
Марџиним сестрама и дефинишите предикате стриц, тетка и ујак.

.. infonote::
   
   Нагласимо још једном декларативну природу претходних програма. Ни у
   једном тренутку није било потребе да описујемо начин извођења
   закључака. Довољно је било опишемо услове који треба да важе, а
   систем је тај који својим уграђеним алгоритмима проналази вредности
   које задовољавају дате услове. За логичко програмирање се каже да
   алгоритам обједињава **логику** и **контролу**, при чему програмер
   задаје логику, а контролу извршава систем. Систем може да примени
   различите стратегије извршавања (доказивања теорема) да би што
   ефикасније дошао до решења.


Дрво извођења
-------------

Задатак програмера је да кроз базу знања опише чињенице и правила
закључивања, а задатак PROLOG система је да провери да ли је дати упит
логичка последица базе знања. Иако програмер не би требало да води
рачуна о томе како се та провера врши (рекли смо да се у основи крије
механизам резолуције), често се ипак тај механизам представља дрветом
које помаже да се разуме шта се у позадини дешава.

Функције
--------

За разлику од функционалних, али и императивних и
објектно-оријентисаних језика где програмери углавном дефинишу
функције које на основу задатих аргумената израчунавају резултате,
основу PROLOGA чине предикати тј. релације. Писање функција није
директно подржано. Ипак, већ смо видели да се релације постављањем
одговарајућих упита могу користити и као функције. На пример, у
функционалном језику написали бисмо функцију ``brat(X)`` која би као
параметар примала особу, а као резултат враћала њеног брата.  У
прологу смо дефинисали предикат ``brat(X, Y)``, а затим смо, на
пример, помоћу упита ``brat(X, liza)`` могли да "израчунамо" да је
Лизин брат Барт. Могли смо заправо и више од тога. Упитом ``brat(bart,
X)`` могли смо да израчунамо чији је све брат Барт. Дакле, једна
релација, у зависности од тога како се упит поставља нам омогућава
више израчунавања тј. у себи крије више функција. Видећемо да ово
често може да буде изненађујуће, тј. да добијамо "гратис" могућност
неких израчунавања која нисмо имали у виду када смо дефинисали
релацију.

Дакле, уместо дефинисања функција облика

.. math::

   y = f(x_1, \ldots, x_n)


PROLOG допушта дефинисање релација облика

.. math::

   R(x_1, \ldots, x_n, y)

које се онда могу користити као функције тако што се аргументи
:math:`x_1` до :math:`x_n` фиксирају у упиту, а `y` се зада као
променљива чија се вредност аутоматски одређује. При том, сви
аргументи релације су симетрични и могуће је да било који од њих (па и
више њих истовремено) буду задати као променљиве чије се вредности
одређују.

Негација као неуспех
--------------------

Сви предикати са десне стране правила су задавани у позитивном облику
(ако изузмемо пример различитости две променљиве, што је негативни
облик). PROLOG даје подршку за негацију, али је та негација специфична
и не понаша се исто као класична логичка негација. Тај облик негације
се назива **негација као неуспех** (енгл. negation as failure).

Покушајмо да дефинишемо предикат женско, као негацију предиката мушко.

.. code-block:: prolog
                
   % Negacija kao neuspeh
   zensko(X) :- falset(musko(X)).

Очекујемо да се ово може тумачити као импликација :math:`(\forall
X)(\neg \mathrm{musko}(X) \Rightarrow \mathrm{zensko}(X))`. Међутим,
упити показују на неуобичајено понашање.
   
.. code-block:: prolog

   ?- zensko(homer).  % false
   ?- zensko(mardz).  % true
   ?- zensko(X).      % false

PROLOG успешно одређује да Хомер није женско, да Марџ јесте женско,
међутим, када се упита да наброји женске особе, добија се да не
постоји ни једна. Понашање операције ``falset`` је такво да она успева
ако и само ако јој аргумент не успева.

- Упит ``zensko(homer)`` се своди на упит ``falset(musko(homer))``. Пошто
  упит ``musko(homer)`` успева, упит ``zensko(homer)`` не успева и
  исправно се враћа резултат ``false``.

- Упит ``zensko(mardz)`` се своди на упит ``falset(musko(mardz))``. Пошто
  упит ``musko(mardz)`` не успева, упит ``zensko(mardz)`` успева и
  исправно се враћа резултат ``false``.

- Упит ``zensko(X)`` се своди на упит ``falset(musko(X))``. Упит
  ``musko(X)`` успева, при чему се добија вредност ``X=homer``.
  Међутим, пошто подупит ``musko(X)`` успева, упит ``falset(musko(X))``,
  по дефиницији негације, не успева, па самим тим ``zensko(X)`` враћа
  неисправан резултат ``false``.

.. infonote::

   Негација у PROLOG-у има другачије понашање од класичне логичке
   негације!

Аритметичка израчунавања
------------------------

Иако је PROLOG заснован на математичкој логици и његову основу, као
што смо видели чини симболичко израчунавање, програмирање се не може
замислити без нумеричког израчунавања тј. рада са бројевима. PROLOG
подржава рад и са целим и са реалним бројевима, али jе често за то
потребно користити посебну подршку.

Кренимо од употребе релацијских оператора. Дефинишимо предикате којима
се одређује агрегатно стање воде.

.. code-block:: prolog

   cvrsto(X) :- X < 0.
   tecno(X) :- X >= 0, X < 100.
   gasovito(X) :- X >= 100.                

Ови предикати су коректно дефинисани и дају исправан резултат за сваку
проверу.

Интересантан је и следећи пример. У бази знања памтимо почетак и крај
владавине неколико краљева из династије Немањића. Затим дефинишемо да
је неко био краљ током дате године, ако је та година унутар интервала
његове владавине.

.. code-block:: prolog

   kralj_od_do(stefan, 1217, 1228).
   kralj_od_do(radoslav, 1228, 1233).
   kralj_od_do(vladislav, 1234, 1243).
   kralj_od_do(uros, 1243, 1276).
   kralj_od_do(dragutin, 1276, 1282).
   kralj(Ime, Godina) :- kralj_od_do(Ime, GodinaOd, GodinaDo),
                         GodinaOd =< Godina, Godina =< GodinaDo.
   
Сада можемо да питамо и ко је био краљ током 1250. године.

.. code-block:: prolog

   ?- kralj(Ime, 1250).

Систем исправно изводи закључак да је једини краљ током те године био
Урош.
                         
Релацијски оператори се, дакле, на први поглед понашају прилично
очекивано. Међутим, PROLOG неће успети да нам одговори током којих је
све година Стефан био краљ.


.. code-block:: prolog

   ?- kralj(stefan, Godina).

На овај упит добијамо odgovor

::

   Arguments are not sufficiently instantiated
   In:
   [2] 1217 =< _1702
   [1] kralj(stefan,_1756) at  line 7

који нам одговара да није могуће да се релацијски оператор примени на
променљиву којој још није одређена вредност (у нашем случају то је
променљива ``Godina``).
   
Размотримо сада следећи пример предиката који користи операцију
сабирања.

.. code-block:: prolog

   zbir(X, Y, Z) :- Z == X + Y.

Ова дефиниција је синтаксички исправна, што значи да PROLOG зна нешто
о сабирању и једнакости. Међутим, ако поставимо следећи упит:

.. code-block:: prolog

   ?- zbir(3, 5, 8).

неочекивано добијамо неисправан одговор ``false``. И на упит

.. code-block:: prolog

   ?- zbir(3, 5, X).

добијамо одговор ``false``. Међутим, ако поставимо упит


.. code-block:: prolog

   ?- zbir(3, 5, 3 + 5).

Добијамо одговор ``true``.

Нешто очигледно није како треба. Покушајмо да променимо дефиницију
предиката ``zbir`` и да уместо оператора ``==`` употребимо оператор
``=``.

.. code-block:: prolog

   zbir(X, Y, Z) :- Z = X + Y.

И ова дефиниција је синтаксички исправна, што значи да PROLOG користи
и оператор ``==`` и ``=`` (и видећемо да они означавају различите
ствари). Међутим, ако поставимо следећи упит:

.. code-block:: prolog

   ?- zbir(3, 5, 8).

поново добијамо неисправан одговор ``false``. Са друге стране, на упит

.. code-block:: prolog

   ?- zbir(3, 5, X).

сада добијамо одговор ``3+5``, што је делимично тачно (јер, наравно,
очекујемо одговор ``8``). Поново на упит

.. code-block:: prolog

   ?- zbir(3, 5, 3 + 5).

добијамо тачан одговор ``true``.

Шта се заправо овде догађа? Оператор ``==`` је **оператор провере
једнакости** два терма и он враћа вредност тачно ако и само ако су
термови идентични.

- Упит ``?- zbir(3, 5, 8)`` се своди на ``8 == 3+5``. Проверава се да ли
  су терм са леве и десне стране идентични, они то нису и добија се
  одговор ``false``.

- Упит ``?- zbir(3, 5, X)`` се своди на ``X == 3+5``. Проверава се да ли
  су терм са леве и десне стране идентични, они то нису и добија се
  одговор ``false``.

- Упит ``?- zbir(3, 5, 3+5)`` се своди на ``3+5 == 3+5``. Проверава се да
  ли су терм са леве и десне стране идентични, они јесу идентични и
  добија се одговор ``true``.

Оператор ``=`` је **оператор унификације** и он враћа вредност тачно
ако и само ако се термови могу унификовати тј. ако се променљивама
доделити вредности тако да два термови постану једнаки након те
доделе.

- Упит ``?- zbir(3, 5, 8)`` се своди на ``8 = 3+5``. Пошто се термови не
  могу унификовати (у њима се ни не јављају променљиве) добија се
  одговор ``false``.

- Упит ``?- zbir(3, 5, X)`` се своди на ``X = 3+5``. Термови са леве и
  десне стране се могу унификовати тако што се променљивој ``X``
  додели вредност ``3+5``, па упит успева уз резултат ``X=3+5``.

- Упит ``?- zbir(3, 5, 3+5)`` се своди на ``3+5 == 3+5``. Термови са леве
  и десне стране су идентични (па се самим тим могу и унификовати) и
  као резултат се добија ``true``.

Објаснили смо операторе ``==`` и ``=``, међутим ни један од њих нам не
одговара у потпуности. Да би се извршило сабирање (или било која друга
аритметичка операција), потребно је да се употреби оператор ``is``.
Њиме се проверава да ли се термови са леве и десне стране могу
унификовати, али тек након што се терм са десне стране израчуна.

.. code-block:: prolog

   zbir(X, Y, Z) :- Z is X + Y.
   
- Упит ``?- zbir(3, 5, 8)`` се своди на ``8 is 3+5``. Када се израчуна
  вредност терма са десне стране, добија се вредност 8, па пошто су
  лева и десна страна тада једнаке, добија се исправан резултат
  ``true``.

- Упит ``?- zbir(3, 5, X)`` се своди на ``X is 3+5``. Када се израчуна
  терм са десне стране добијају се термови ``X`` и ``8``, па пошто се
  они могу унификовати тако што се променљивој ``X`` додели вредност
  ``8``, упит успева уз резултат ``X=8``.

- Упит ``?- zbir(3, 5, 3+5)`` се своди на ``3+5 is 3+5``. Када се
  израчуна вредност терма са десне стране, добијају се термови ``3+5``
  и ``8``, који се не могу унификовати и добија се погрешан резултат
  ``false``.

Дакле, ако употребимо оператор ``is`` добијамо исправну могућност
израчунавања вредности израза (у том светлу најзначајнији нам је упит
``zbir(3, 5, X)``), при чему и провера израчунате вредности ради
исправно (упит ``zbir(3, 5, 8)`` коректно ради).

Међутим, важно је нагласити да се из ове релације не могу издвојити
друге функције. На пример, упит ``?- zbir(X, 5, 8)`` даје одговор
``no``. Решавање једначина, дакле, није могуће.

Оператори поређења на једнакост ``=:=`` и различитост ``=\=`` такође
врше израчунавање термова пре поређења.

.. infonote::

   Када год употребљавате аритметичке операторе, морате употребити и
   оператор ``is``, ``=:=`` или ``=\=`` којим ћете натерати систем да
   их примени тј. да изврши потребна израчунавања!

Релацијски оператори су описани у следећој табели.
   
+-------------+------------------------------------------------------------+
| Оператор    | Опис                                                       |
+=============+============================================================+
| ``=``       | Унификује два терма                                        |
+-------------+------------------------------------------------------------+
| ``\=``      | Негација унификације                                       |
+-------------+------------------------------------------------------------+
| ``==``      | Једнакост два терма                                        |
+-------------+------------------------------------------------------------+
| ``=:=``     | Једнакост израчунатих вредности два терма                  |
+-------------+------------------------------------------------------------+
| ``=\=``     | Негација једнакости                                        |
+-------------+------------------------------------------------------------+
| ``=<``      | Мање од или једнако                                        |
+-------------+------------------------------------------------------------+
| ``<``       | Мање од                                                    |
+-------------+------------------------------------------------------------+
| ``>=``      | Веће од или једнако                                        |
+-------------+------------------------------------------------------------+
| ``>``       | Веће од                                                    |
+-------------+------------------------------------------------------------+

Аритметички оператори су описани у следећој табели.

+-------------+--------------------------------------------------+
| Оператор    | Опис                                             |
+=============+==================================================+
| ``+``       | Сабира два броја.                                |
+-------------+--------------------------------------------------+
| ``-``       | Одузима други број од првог.                     |
+-------------+--------------------------------------------------+
| ``*``       | Множи два броја.                                 |
+-------------+--------------------------------------------------+
| ``/``       | Дели први број са другим.                        |
+-------------+--------------------------------------------------+
| ``//``      | Целобројно дељење (добија целобројни резултат).  |
+-------------+--------------------------------------------------+
| ``mod``     | Остатак при дељењу (добија остатак од дељења).   |
+-------------+--------------------------------------------------+
| ``**``      | Степеновање (први број се степенује другим).     |
+-------------+--------------------------------------------------+

.. questionnote::

   Дефинисати предикат који израчунава степен броја (изложилац је
   ненегативан цео број).


Основна идеја је да пратимо рекурзивну дефиницију која је у језику
Haskell била изражена на следећи начин:

.. code-block:: haskell

   stepen x 0 = 1
   stepen x n = x * stepen x (n - 1)

Уместо функције у језику PROLOG дефинишемо предикат тј. релацију.
Поново имамо два случаја (излаз из рекурзије и рекурзивни корак).
      
.. code-block::
   
   stepen(X, 0, 1).
   stepen(X, N, S) :- N > 0, N1 is N-1, stepen(X, N1, S1), S is X * S1.

Пошто се у првом правилу вредност променљиве ``X`` не користи,
добијамо упозорење ``Singleton variable X``. Да би се оно избегло,
уместо назива ``X`` можемо употребити анонимну променљиву која се
обележава подвлаком.

.. code-block::

   stepen(_, 0, 1).
   
Прво правило можемо читати као:

- нулти степен било ког броја је 1*

Друго правило се може протумачити као:

- ако је ``N`` позитиван, ако је ``N1`` једнако вредности броја ``N``
  након што се она умањи за 1, ако је ``S1`` вредност степена ``X`` на
  ``N1`` и ако је ``S`` једнака вредности која се добије када се
  израчуна производ броја ``X`` и те вредности ``S1``, тада је ``S``
  вредност степена ``X`` на ``N``.

Нагласимо да је потребно употребити оператор ``is`` да би се број
``N`` умањио за 1 као и да би се резултат рекурзивног позива ``S1``
помножио са ``X``. Ако не бисмо у другом правилу навели услов ``N >
0``, тада би се прво пријавила исправно израчуната вредност степена,
али би се приликом тражења даљих решења запало у бесконачну рекурзију
јер не би било услова који би спречио да се друго правило примењује на
``N=0`` а затим и на негативне вредности променљиве ``N``.
      
Можемо дефинисати и ефикаснију имплементацију степеновања.

.. code-block::

   stepen(X, 0, 1).
   stepen(X, N, S) :- N > 0, N mod 2 =:= 0,
                      N1 is N // 2, X2 is X * X, stepen(X2, N1, S).
   stepen(X, N, S) :- N > 0, N mod 2 =\= 0,
                      N1 is N-1, stepen(X, N1, S1), S is S1 * X.


.. questionnote::

   Дефинисати предикат који Еуклидовим алгоритмом израчунава НЗД два
   дата природна броја.

.. code-block::

    nzd(A, 0, A).
    nzd(A, B, N) :- B > 0, M is A mod B, nzd(B, M, N).

Сечење
------

У циљу смањења простора претраге, спречавања нежељеног бектрекинга и
на тај начин изостављања неких нетачних одговора или оптимизације
времена извршавања PROLOG уводи **оператор сечења** или **рез**
(енгл. cut).  Овај се оператор означава са ``!``, увек успева (када се
наведе у правилу, сматра се да је резултат његовог израчунавања
тачан), али у повратку спречава бектрекинг и враћање преко њега здесна
налево. Размотримо неколико примера.

Максимум се може дефинисати на следећи начин:

.. code-block:: prolog

   min(X, Y, X) :- X =< Y.
   min(X, Y, Y) :- Y < X.

Ако се на основу првог правила одреди да је ``X =< Y``, тада нема
потребе приликом бектрекинга проверавати друго правило јер унапред
знамо да његов услов неће бити испуњен. Зато се програм може убрзати
тако што се иза услова у првом правилу дода оператор сечења.


.. code-block:: prolog

   min(X, Y, X) :- X =< Y, !.
   max(X, Y, Y) :- Y < X.

Приликом упита ``?- max(3, 5, M)`` извршиће се унификација којом ће се
везати променљива ``X`` са вредношћу 3, ``Y`` са вредношћу 5 и ``M``
са вредношћу ``X`` тј. 3, провериће се услов ``3 =< 5`` који ће бити
тачан, провериће се оператор сечења који је тачан када се рачуна слева
надесно и доћи ће се до краја правила и пријавиће се резултат ``M=3``.

Претходна употреба оператора сечења је **зелена**, јер се оператором
сечења програм само убрзава и не мења му се значење.

Можемо отићи и корак даље и из другог правила изоставити услов ``Y <
X``. Наиме, пошто у првом правилу постоји сечење, јасно је да ће се до
провере другог правила стићи само ако услов првог правила није испуњен
тј. ако не важи ``X =< Y`` тј. сигурно тада знамо да важи ``Y > X``.
   
.. code-block:: prolog

   max(X, Y, X) :- X =< Y, !.
   max(X, Y, Y).

Вредност максимума бројева 3 и 5 можемо израчунати у ком редоследу
да су задати.

- Упит ``?- max(3, 5, M)`` се извршава на већ описани начин, добија се
  резултат ``M=5`` и због сечења се не траже друга решења.
- Упит ``?- max(5, 3, M)`` се извршава тако што се унификује ``X`` са
  5, ``Y`` са 3, проверава се ``5 =< 3`` и пошто тај услов није
  испуњен, одустаје се од овог правила. Затим се прелази на друго
  правило, унификују се ``X`` и 5, ``Y`` и ``3`` и ``M`` и ``Y``
  тј. 3, након чега се пријављује резултат ``M=3``. Приликом тражења
  других решења враћамо се уназад, нализимо на сечење и бектрекинг се
  прекида.
   
Ипак, ова употреба оператора сечења је **црвена**, јер се оператором
сечења мења значење програма. Заиста, наредни упит сасвим неочекивано
враћа нетачан одговор ``true``.

.. code-block:: prolog

   ?- min(2, 3, 3).

Приликом његовог извршавања, покушава се унификација са левом страном
првог правила што не успева. Унификација са левом страном другог
правила успева и пошто више нема услова на десној страни тог правила,
пријављује се одговор ``true``.

Дакле, иако сечење може скратити програм и омогућити нам да неке
услове не морамо да пишемо, треба бити веома обазриви јер такав
програм може исправно радити за неке услове, а престати да ради
исправно за неке друге упите. Приликом употребе сечења пожељно је увек
користити зелени, а не црвени облик сечења.


Сечење (додуше црвено) нам може помоћи да поједноставимо неке од
претходних дефиниција и да избегнемо експлицитно навођење додатних
услова. На пример, дефиниција степеновања се упрошћава.

.. code-block:: prolog

   stepen(_, 0, 1) :- !.
   stepen(X, N, S) :- N mod 2 =:= 0,
                      N1 is N // 2, X2 is X * X, stepen(X2, N1, S), !.
   stepen(X, N, S) :- N1 is N-1, stepen(X, N1, S1), S is S1 * X.


Листе
-----

Као и други програмски језици и програмски језик PROLOG пружа подршку
за рад са листама података. Слично као што смо видели у програмском
језику Haskell, листа је или празна (``[]``) или се разлаже на главу и
реп (``[X|XS]``). Листе се задају навођењем елемената између угластих
заграда (нпр. ``[3, 8, 4, 2]``).

Кренимо од предиката ``myMember`` који проверава да ли елемент ``E``
припада листи (то ради уграђени предикат ``member``, тако да ову
имплементацију приказујемо само ради илустрације).  Елемент не припада
празној листи, тако да случај празне листе не треба да буде обрађен
(ако нешто не постоји у бази знања, оно се аутоматски сматра
нетачним). Елемент припада непразној листи акко је једнак глави или
припада репу. Подсетимо се, дисјункцију можемо записати оператором
``;``.

.. code-block:: prolog
                
   myMember(X, [H|T]) :- X = H ; myMember(X, T).

Наравно, ово правило је могуће разбити на два.

.. code-block:: prolog
                
   myMember(X, [X|_]).
   myMember(X, [_|T]) :- myMember(X, T).

Јасно је да коришћењем овог предиката можемо проверити да ли дати број
припада датој листи, тј. да наредни упити враћају исправне резултате.

.. code-block:: prolog

   ?- myMember(3, [1, 2, 3, 4]).   % true
   ?- myMember(5, [1, 2, 3, 4]).   % false


Међутим, можда мало неочекивано, овај предикат се може употребити и да
се наброји један по један елемент листе. Наредни упит

.. code-block:: prolog

   ?- myMember(X, [1, 2, 3, 4]).
   
даје резултат ``X=1``, затим ``X=2``, ``X=3`` и на крају ``X=4``.

Ако је елемент једнак глави листе, он је члан листе и нема више
потребе да се проверава да ли припада репу. Зато на крај првог правила
можемо поставити рез.

.. code-block:: prolog

   myMember(X, [X|_]) :- !.
   myMember(X, [_|T]) :- myMember(X, T).

Међутим, ова измена спречава употребу предиката ``myMember`` за
набрајање свих елемената листе, јер се након пријављивања првог
елемента спречава бектрекинг преко реза. Зато се верзија без реза ипак
сматра бољом, ако се планира употреба за набрајање свих елемената
листе (што је, видећемо, доста чест случај).

Иуструјмо рад са листама кроз још неколико предиката.


.. questionnote::

   Дефинисати предикат који одређује дужину листе.


Дужина празне листе је нула, а непразне листе је за један већа од
дужине репа.

.. code-block:: prolog
                
   myLength([], 0).
   myLength([_|T], N) :- myLength(T, N1), N is N1 + 1.

Пошто је употребљен оператор ``is``, овај се предикат не може
употребљавати да се наброје све листе дате дужине.

.. questionnote::

   Дефинисати предикат који спаја (надовезује) две листе.

Решење тече рекурзијом по првој листи. Ако је она празна, резултат
је друга листа. Ако је она облика глава-реп, тада резултат добијамо
тако што рекурзивно спојимо реп ``R`` и другу листу ``L``
добијајући међурезултат ``R1``. Коначан резултат добијамо додајући
главу ``H`` на почетак међурезултата.

.. code-block:: prolog

   myAppend([], L, L).
   myAppend([H|T], L, [H|R1]) :- myAppend(T, L, R1).

Друго правило можемо изразити и коришћењем оператора унификације на
десној страни (тада имамо експлицитну променљиву уз резултат којој
"додељујемо вредност" на крају, када су познате вредности од којих
се она гради):

.. code-block:: prolog

    myAppend([], L, L).
    myAppend([H|T], L, R) :- myAppend(T, L, R1), R = [H, R1].

У зависности од личног стила неком ће прва а неком друга
имплементација бити јаснија и разумљивија.

Овај предикат исправно надовезује две дате листе. На упит

.. code-block:: prolog

   ?- myAppend([1, 2, 3], [4, 5, 6], R).

добијамо исправан одговор ``X=[1, 2, 3, 4, 5, 6]``. Међутим,
прилично неочекивано, овај предикат успева и да одговори на питање
надовезивањем које две листе се може добити дата листа.

   
.. code-block:: prolog

   ?- myAppend(L1, L2, [1, 2, 3, 4]).

Добијају се одговори ``L1=[]``, ``L2=[1,2,3,4]``, затим
``L1=[1]``, ``L2=[2,3,4]``, затим ``L1=[1,2]``, ``L2=[3,4]``,
затим ``L1=[1,2,3]``, ``L2=[4]`` и на крају  ``L1=[1,2,3,4]``,
``L2=[]``.

.. questionnote::

   Дефинисати предикат који одређује последњи елемент листе.

Овај предикат није дефинисан за празне листе. Базу (излаз из
рекурзије) ће зато представљати случај једночлане листе где је
једини елемент листе уједно и последњи. Ако је листа непразна, тада
е последњи елемент репа листе последњи елемент листе.
   
.. code-block:: prolog

   myLast([X], X).
   myLast([_|T], Res) :- myLast(T, Res).

Овај предикат исправно одређује последњи елемент било које непразне
листе, а за празну листу враћа одговор ``false``. Остаје можда мало
нејасно да ли је након првог правила додати рез, тј. зашто се
једночлана листа не обрађује и на основу првог и на основу другог
правила, пошто је она такође непразна. Једночлана листа се може
унификовати са листом ``[_|T]``, тако што је ``T`` празна листа.
Након тога се, због десне стране правила, тражи последњи елемент
празне листе, и пошто то не успева, не налази се додатно решење.
Дакле, друго правило се примењује на јеночлану листу, али не доводи
до решења. Ако не ставимо рез након првог правила, овај предикат се
може искористити и да наброји све листе којима је дати елемент
последњи. На упит


.. code-block:: prolog

   myLast(L, 0).

Добијамо одговоре ``L=[0]``, ``L=[_1412, 0]``, ``L = [_1412, _1418, 0]``
итд. при чемусу ``_1412``, ``_1418`` итд. називи аутоматски генерисаних
променљивих.

      
.. questionnote::

   Дефинисати предикат који одређује елемент листе на датој позицији.

Елемент на позицији 0 празне листе је њена глава. За ``K > 0``
елемент на позицији ``K`` непразне листе је елемент на позицији
``K-1`` њеног репа.

.. code-block:: prolog

   kth([H|_], 0, H).
   kth([_|T], K, R) :- К > 0, K1 is K-1, kth(T, K1, R).

Променљива ``R`` означава резултат.       

У решењу можемо употребити и сечење.
   
.. code-block:: prolog

   kth([H|_], 0, H) :- !.
   kth([_|T], K, R) :- K1 is K-1, kth(T, K1, R).

.. questionnote::

   Дефинисати предикат који обрће листу.

Наивно решење добијамо тако што приметимо да се обртањем празне
листе добија празна листа, а да се резултат обртања непразне листе
која има главу и реп добија тако што се глава те листе добија на
резултат обртања репа те листе.
   
.. code-block:: prolog
                
   myReverse([], []).
   myReverse([H|T], R) :- myReverse(T, R1), myAppend(R1, H, R).

Потребно је и да дефинишемо предикат којим се елемент додаје на
крај листе. Додавањем елемента на крај празне листе добија се
једночлана листа. Ако је листа непразна, додавање елемента на њен
крај се добија тако што јој се задржи глава, а реп јој се замени
додавањем елемента на крај њеног репа.

.. code-block:: prolog
   
   myAppend([], X, [X]).
   myAppend([H|T], X, [H|T1]) :- myAppend(T, X, T1).

Уместо да директно наведемо облик резултата на левој страни
правила, можемо употребити и оператор унификације на десној страни
правила.

.. code-block:: prolog
   
   myAppend([], X, R) :- R = [X].
   myAppend([H|T], X, R) :- myAppend(T, X, T1), R = [H|T1].
   
   
Ова имплементација обртања је неефикасна и ефикасније решење се
добија ако се користи акумулатор (опис овог алгоритма приказан је у
поглављу о функционалном програмирању). Узима се један по један
елемент полазне листе и додаје се на почетак помоћне листе
(акумулатора) све док се полазна листа не испразни и тада је
коначан резултат оно што се нагомилало у акумулатору. На почетку се
креће од празног акумулатора.
   
.. code-block:: prolog
 
   myReverse([], A, A).
   myReverse([H|T], A, R) :- myReverse(T, [H|A], R).
   myReverse(L, R) :- myReverse(L, [], R).

Променљива ``L`` означава листу која се обрђе, ``R`` резултат
обртања, а ``A`` акумулатор.
   
Обртање можемо употребити да проверимо, на пример, да ли је ниска
палиндром.

.. code-block:: prolog

   proveriPalindrom(XS) :- obrni(XS, XS).

.. questionnote::

   Дефинисати предикат који прима угнежђене листе бројева и "пегла" их
   тј. издваја листу свих бројева који се у њима јављају. На пример, треба
   да важи ``myFlatten [[1, 2, 3], [4, [5, 6]], 7] [1, 2, 3, 4, 5, 6, 7]``.

"Пеглањем" празне листе добија се празна листа. Код непразних листа,
"пегла" се реп листе, а затим се анализира глава. Постоје два могућа
случаја. Ако је глава листа, тада се резултат добије тако што се та
глава "пегла" и резултат се спаја са "испегланим" репом. Ако глава
није листа, она се таква каква јесте додаје на почетак "испегланог"
репа. Проверу да ли је дата променљива листа можемо извршити
библиотечким предикатом ``is_list``.

.. code-block:: prolog
             
   myFlatten([], []).
   myFlatten([H|T], X) :- is_list(H), myFlatten(H, H1), myFlatten(T, T1), append(H1, T1, X), !.
   myFlatten([H|T], [H|T1]) :- myFlatten(T, T1).


Приметимо да ову функционалност није могуће постићи у језику
Haskell, јер тип полазне листе није могуће дефинисати (тамо сви
елементи листе морају да имају исти тип, а овде радимо са листама
које садрже елементе различитих типова).

.. questionnote::

   Дефинисати предикат који обједињава две сортиране листе у трећу
   сортирану. Дефинисати затим предикат који дели листу на две једнаке
   половине. Дефинисати на крају предикат који применом претходна два
   предиката сортира листу.

Ако је било која од две листе које се обједињавају празна, резултат
је она друга. Ако су обе листе непразне, мању од њихове две главе
смештамо на почетак резултата, а реп резултата добијамо рекурзивним
обједињавањем репа листе чија је глава била мања и целе друге
листе.

.. code-block:: prolog

   merge([], L2, L2).
   merge(L1, [], L1).
   merge([H1|T1], [H2|T2], R) :- H1 < H2, merge(T1, [H2|T2], R1), R = [H1|R1], !.
   merge([H1|T1], [H2|T2], R) :- merge([H1|T1], T2, R1), R = [H2|R1].


Поделу листе на два једнака дела можемо постићи тако што
наизменично елементе са почетка листе која се дели смештамо у једну
и другу резултујућу листу. Празна листа се дели на две
празне. Једночлана се дели тако што ће једна од резултујућих листа
бити једночлана, а друга празна. Листу која има бар два елемента
делимо тако што реп без та два елемента делимо на два дела, а онда
први елемент стављамо на почетак првог од та два дела, а други на
почетак другог.
   
.. code-block:: prolog

   split([], [], []).
   split([X], [X], []).
   split([H1,H2|T], [H1|L], [H2|R]) :- split(T, L, R).

На крају дефинишемо сортирање обједињавањем. Празна и једночлана
листа се не мењају приликом сортирања. Листа која има бар два
елемента се дели на две подлисте, оне се независно сортирају и на
крају обједињавају.

.. code-block:: prolog

   mergeSort([], []).
   mergeSort([X], [X]) :- !.
   mergeSort(L, R) :- split(L, L1, L2), mergeSort(L1, L1S), mergeSort(L2, L2S), merge(L1S, L2S, R).

   
Логичке загонетке
-----------------

Веома лепа илустрација моћи језика PROLOG у односу на друге програмске
језике је кроз решавање логичких загонетки. Обично су програми само
прецизно кодирање услова загонетки, а систем онда самостално проналази
решење, што је доста ефикасније него код других програмских језика у
којима програмер мора да програмира поступак одређивања решења. У
зависности од загонетке која се решава и начина решавања програми могу
бити мање или више ефикасни. У наредним решењима нећемо обраћати пуно
пажње на ефикасност решења, већ пре свега на једносавност њиховог
програмирања. Размотримо следећих неколико примера.



.. questionnote::

   Неколико пријатеља је гласало које би градове желели да посете.
    
   1. Гласали су за Каиро, Лондон, Пекинг, Москву, Бомбај, Најроби и
      Џакарту.
   2. Један град је добио 4 гласа, два града по 2 гласа, два града по 1
      глас и два града нису добили ниједан глас.
   3. Каиро и Пекинг су добили различит број гласова.
   4. Москва је добила или најмање или највише гласова од свих градова.
   5. Каиро је добио више гласова од Џакарте.
   6. Гледајући листу из тачке 1, тачно два пута се догодило да је град
      са два гласа дошао непосредно иза града са једним гласом.
   7. Џакарта је добила или један глас мање од Лондона или један
      глас мање од Пекинга.

Направићемо листу променљивих које одговарају градовима. Вредност
сваке од тих променљивих биће број гласова које је тај град
добио. На основу другог правила знамо да ће листа вредности тих
променљивих садржати вредности ``[4, 2, 2, 1, 1, 0, 0]``, али не
знамо у ком редоследу тј. знаћемо да је листа вредности променљивих
једна од пермутација ове листе. Можемо употребити библиотечки
предикат ``permutation`` који се може употребљавати за набрајање
свих пермутација (покушајте да за вежбу самостално дефинишете такав
предикат). Приступ решењу је, дакле, прилично директан: набрајају
се све пермутације ове листе и за сваку од њих се проверава да ли
задовољава додатне услове. Иако су оваква решења у општем случају
веома неефикасна, јер број пермутација брзо расте, у овом
конкретном задатку ефикасност је задовољавајућа јер пермутација
седмочлане листе има тек око 5 хиљада. Сваки даљи услов, осим
услова 6 се веома директно кодира. Што се тиче услова 6, дефинишемо
помоћни предикат који броји појављивања пара бројева у листи.
 
.. code-block:: prolog
                
    brojPojavljivanjaPara([], _, 0).
    brojPojavljivanjaPara([X1,X2|T], [X1,X2], N) :-
       brojPojavljivanjaPara(T, [X1,X2], N1), N is N1 + 1, !.
    brojPojavljivanjaPara([_|T], [X1,X2], N) :-
       brojPojavljivanjaPara(T, [X1,X2], N).
 
    glasovi(Gradovi) :-
      Gradovi = [Kairo,London,Peking,Moskva,Bombaj,Najrobi,Dzakarta],
      permutation(Gradovi, [4, 2, 2, 1, 1, 0, 0]),
      Kairo =\= Peking,
      (Moskva = 0 ; Moskva = 4),
      Kairo > Dzakarta,
      brojPojavljivanjaPara(Gradovi, [0, 2], 2),
      (Dzakarta is (London-1); Dzakarta is (Peking-1)).


Тачно решење ``Gradovi = [4, 0, 2, 0, 2, 1, 1]`` се пријављује
неколико пута, јер функција за проналажење пермутација неколико
пута проналази исту пермутацију (зато што листа садржи дупликате).

.. questionnote::
   
   Пет људи различитих националности живи у пет кућа различитих боја,
   имају пет различитих врста кућних љубимаца, пију пет различитих
   напитака и пуше пет различитих врста цигарета.
   
   1. Норвежанин живи у првој кући.
   2. Млеко се пије у средњој кући.
   3. Енглез живи у црвеној кући.
   4. Шпанац има пса.
   5. У зеленој кући се пије кафа.
   6. Украјинац пије чај.
   7. Власник пужа пуши цигарете олдголд.
   8. У жутој кући се пуше цигарете кулс.
   9. Зелена кућа је прва десно од куће боје слоноваче.
   10. У кући поред оне у којој живи лисица се пуше цигарете честер.
   11. У кући поред оне у којој се пуше цигарете кулс је љубимац коњ.
   12. Плава кућа је поред оне у којој живи Норвежанин.
   13. Власник једне куће пуши цигарете лаки и пије ђус.
   14. Јапанац пуши цигарете парламент.

Напиши програм који одређује ко је власник зебре и ко пије воду?

Кључно питање је како представити решење. Веома погодна
репрезентација је у облику листе термова где је сваки терм облика
``kuca(nacionalnost, boja, ljubimac, pice, cigarete)``. Тада можемо
креирати петочлану листу ``Kuce`` и кодирати услове о њеним
члановима. Прва два услова се могу кодирати приликом дефинисања
низа кућа: први елемент је облика ``kuca(norvezanin, _, _, _, _)``,
где анонимне променљиве могу бити унификоване са стварним
вредностима на тим позицијама, а трећи елемент је облика
``kuca(_, _, _, mleko, _)``. О другом, четвртом и петом елементу листе
не знамо ништа, па их можемо представити анонимним променљивама. У услову
9. потребно је да кодирамо "кућа је десно од куће", а у неколико
услова треба да кодирамо да су куће једна поред друге. За то
дефинишемо два помоћна предиката ``desnoOd`` и ``pored`` (који се
лако кодира помоћу ``desnoOd`` зато што је кућа поред куће ако и
само ако је прва десно од друге или друга десно од прве). Све
остале услове кодирамо коришћењем уграђеног предиката ``member``
који проверава да ли дати елемент припада листи, али и може да
наброји редом чланове листе. Имајући све ово у виду, сви услови се
прилично директно кодирају (приметимо да услови различитости следе
из тога што за сваку категорију имамо 5 различитих константи, након
што као последња два услова додамо информације о томе да власник
зебре има зебру, а да онај ко пије воду пије воду). Покретањем
предиката ``zebraZagonetka`` добијамо јединствено решење да Јапанац
има зебру, а да Норвежанин пије воду.

.. code-block:: prolog

  desnoOd(X, Y, [Y, X| _]).
  desnoOd(X, Y, [_|T]) :- desnoOd(X, Y, T).
  pored(X, Y, L) :- desnoOd(X, Y, L) ; desnoOd(Y, X, L).

  zebraZagonetka(VlasnikZebre, PijeVodu) :-
     Kuce = [kuca(norvezanin, _, _, _, _), _, kuca(_, _, _, mleko, _), _, _],
     member(kuca(englez, crvena, _, _, _), Kuce),
     member(kuca(spanac, _, pas, _, _), Kuce),
     member(kuca(_, zelena, _, kafa, _), Kuce),
     member(kuca(ukrajinac, _, _, caj, _), Kuce),
     member(kuca(_, _, puz, _, oldgold), Kuce),
     member(kuca(_, zuta, _, _, kuls), Kuce),
     desnoOd(kuca(_, zelena, _, _, _), kuca(_, slonovaca, _, _, _), Kuce),
     pored(kuca(_, _, _, _, cester), kuca(_, _, lisica, _, _), Kuce),
     pored(kuca(_, _, _, _, kuls), kuca(_, _, konj, _, _), Kuce),
     pored(kuca(norvezanin, _, _, _, _), kuca(_, plava, _, _, _), Kuce),
     member(kuca(_, _, _, djus, laki), Kuce),
     member(kuca(japanac, _, _, _, parlament), Kuce),
     member(kuca(VlasnikZebre, _, zebra, _, _), Kuce),
     member(kuca(PijeVodu, _, _, voda, _), Kuce).
