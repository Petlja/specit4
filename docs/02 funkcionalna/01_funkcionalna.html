<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Функционална парадигма</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/activecode.css" />
    <link rel="stylesheet" type="text/css" href="../_static/codemirror.css" />
    <link rel="stylesheet" type="text/css" href="../_static/qchoice.css" />
    <link rel="stylesheet" type="text/css" href="../_static/clickable.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pytutor.css" />
    <link rel="stylesheet" type="text/css" href="../_static/modal-basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/datafile.css" />
    <link rel="stylesheet" type="text/css" href="../_static/dragndrop.css" />
    <link rel="stylesheet" type="text/css" href="../_static/fitb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/matrixeq.css" />
    <link rel="stylesheet" type="text/css" href="../_static/parsons.css" />
    <link rel="stylesheet" type="text/css" href="../_static/lib/prettify.css" />
    <link rel="stylesheet" type="text/css" href="../_static/poll.css" />
    <link rel="stylesheet" type="text/css" href="../_static/showEval.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tabbedstuff.css" />
    <link rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/video.css" />
    <link rel="stylesheet" type="text/css" href="../_static/webgldemo.css" />
    <link rel="stylesheet" type="text/css" href="../_static/webglinteractive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/karel.css" />
    <link rel="stylesheet" type="text/css" href="../_static/notes.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/associations.css" />
    <link rel="stylesheet" type="text/css" href="../_static/editor.css" />
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/user-highlights.css" type="text/css" />
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.1/css/all.css" type="text/css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-4.0.0-dist/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/flatly.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/petlja-course.css" type="text/css" />
    <link rel="stylesheet" href="../_static/nbstyle.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/runestonebase.js"></script>
    <script src="../_static/skulpt.min.js"></script>
    <script src="../_static/skulpt-stdlib.js"></script>
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/jquery.highlight.js"></script>
    <script src="../_static/bookfuncs.js"></script>
    <script src="../_static/codemirror.js"></script>
    <script src="../_static/xml.js"></script>
    <script src="../_static/css.js"></script>
    <script src="../_static/python.js"></script>
    <script src="../_static/htmlmixed.js"></script>
    <script src="../_static/javascript.js"></script>
    <script src="../_static/jquery_i18n/CLDRPluralRuleParser.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.messagestore.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.fallbacks.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.language.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.parser.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.emitter.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.emitter.bidi.js"></script>
    <script src="../_static/activecode-i18n.en.js"></script>
    <script src="../_static/activecode-i18n.sr-Cyrl.js"></script>
    <script src="../_static/activecode.js"></script>
    <script src="../_static/clike.js"></script>
    <script src="../_static/timed_activecode.js"></script>
    <script src="../_static/animationbase.js"></script>
    <script src="../_static/mchoice.js"></script>
    <script src="../_static/timedmc.js"></script>
    <script src="../_static/timed.js"></script>
    <script src="../_static/mchoice-i18n.en.js"></script>
    <script src="../_static/mchoice-i18n.sr-Cyrl.js"></script>
    <script src="../_static/clickable.js"></script>
    <script src="../_static/timedclickable.js"></script>
    <script src="../_static/d3.v2.min.js"></script>
    <script src="../_static/jquery.ba-bbq.min.js"></script>
    <script src="../_static/jquery.jsPlumb-1.3.10-all-min.js"></script>
    <script src="../_static/pytutor.js"></script>
    <script src="../_static/codelens.js"></script>
    <script src="../_static/skulpt.min.js"></script>
    <script src="../_static/skulpt-stdlib.js"></script>
    <script src="../_static/datafile.js"></script>
    <script src="../_static/dragndrop.js"></script>
    <script src="../_static/timeddnd.js"></script>
    <script src="../_static/dragndrop-i18n.en.js"></script>
    <script src="../_static/dragndrop-i18n.sr-Cyrl.js"></script>
    <script src="../_static/fitb.js"></script>
    <script src="../_static/timedfitb.js"></script>
    <script src="../_static/fitb-i18n.en.js"></script>
    <script src="../_static/fitb-i18n.sr-Cyrl.js"></script>
    <script src="../_static/matrixeq.js"></script>
    <script src="../_static/lib/prettify.js"></script>
    <script src="../_static/lib/hammer.min.js"></script>
    <script src="../_static/parsons.js"></script>
    <script src="../_static/parsons-i18n.en.js"></script>
    <script src="../_static/parsons-i18n.sr-Cyrl.js"></script>
    <script src="../_static/timedparsons.js"></script>
    <script src="../_static/poll.js"></script>
    <script src="../_static/reveal.js"></script>
    <script src="../_static/shortanswer.js"></script>
    <script src="../_static/timed_shortanswer.js"></script>
    <script src="../_static/showEval.js"></script>
    <script src="../_static/tabbedstuff.js"></script>
    <script src="../_static/runestonevideo.js"></script>
    <script src="../_static/webglinteractive.js"></script>
    <script src="../_static/FileSaver.min.js"></script>
    <script src="../_static/Blob.js"></script>
    <script src="../_static/karelCorner.js"></script>
    <script src="../_static/karelRobot.js"></script>
    <script src="../_static/karelWorld.js"></script>
    <script src="../_static/karelChat.js"></script>
    <script src="../_static/karelRobotDrawer.js"></script>
    <script src="../_static/karelUI.js"></script>
    <script src="../_static/karel.js"></script>
    <script src="../_static/karel-i18n.en.js"></script>
    <script src="../_static/karel-i18n.sr-Cyrl.js"></script>
    <script src="../_static/notes.js"></script>
    <script src="../_static/pygamelib-init.js"></script>
    <script src="../_static/gallery.js"></script>
    <script src="../_static/associations.js"></script>
    <script src="../_static/associations-i18n.en.js"></script>
    <script src="../_static/associations-i18n.sr-Cyrl.js"></script>
    <script src="../_static/editor.js"></script>
    <script src="../_static/jszip.js"></script>
    <script src="../_static/editor-i18n.en.js"></script>
    <script src="../_static/editor-i18n.sr-Cyrl.js"></script>
    <script src="../_static/translations.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/jquery-ui-1.10.3.custom.min.js"></script>
    <script src="../_static/jquery-fix.js"></script>
    <script src="../_static/bootstrap-4.0.0-dist/js/bootstrap.min.js"></script>
    <script src="../_static/bootstrap-4.0.0-dist/js/bootstrap.bundle.min.js"></script>
    <script src="../_static/bootstrap-sphinx.js"></script>
    <script src="../_static/waypoints.min.js"></script>
    <script src="../_static/rangy-core.js"></script>
    <script src="../_static/rangy-textrange.js"></script>
    <script src="../_static/rangy-cssclassapplier.js"></script>
    <script src="../_static/user-highlights.js"></script>
    <script src="../_static/jquery.idle-timer.js"></script>
    <script src="../_static/processing-1.4.1.min.js"></script>
    <script src="../_static/jquery.hotkey.js"></script>
    <script src="../_static/jquery-migrate-1.2.1.min.js"></script>
    <script src="../_static/course-errors.js"></script>
    <script src="../_static/petlja.js"></script>
    <script src="../_static/require.js"></script>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
    <meta content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' name='viewport' />
    <link rel="shortcut icon" href="../_static/favicon.ico" type="image/ico" />
    <script type="text/javascript">
      eBookConfig = {};
      eBookConfig.host = 'http://127.0.0.1:8000' ? 'http://127.0.0.1:8000' : 'http://127.0.0.1:8000';
      eBookConfig.app = eBookConfig.host + '/runestone';
      eBookConfig.ajaxURL = eBookConfig.app + '/ajax/';
      eBookConfig.course = 'paradigme';
      eBookConfig.logLevel = '0';
      eBookConfig.loginRequired = 'false';
      eBookConfig.build_info = "";
      eBookConfig.isLoggedIn = false;
      eBookConfig.useRunestoneServices = false;
      eBookConfig.python3 = true;
      eBookConfig.basecourse = 'paradigme';
      eBookConfig.runestone_version = '';
      eBookConfig.imagesDir = '../_images/';
      eBookConfig.staticDir = '../_static/';
      if (typeof (Sk) != "undefined")
        Sk.imgPath = eBookConfig.imagesDir;
    </script>

  </head>

  <body>



<div id="navbar" class="content-header">
  <div class="right-side-nav">
    
    <div id="usefulLinksToggle" class="useful-links-toggle">
        <a class="dropdown-toggle dropdown-toggle-burger" role="button" href="#" id="usefulLinksDropdown" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-bars fa-2x"></i>
        </a>
        <div class="dropdown-menu dropdown-nav-links shadow-lg" aria-labelledby="usefulLinksDropdown" x-placement="bottom-start" style="position: absolute; transform: translate3d(-55px, 32px, 0px); top: 0px; left: 0px; will-change: transform;">
          <div class="links-title"> Корисни линкови</div>
          <div class="useful-link">
            <a href="https://www.haskell.org/ghc/" target="_blank">Glasgow haskell compiler</a></div>
          <div class="useful-link">
            <a href="https://www.haskell.org/hugs/" target="_blank">Hugs Haskell interpreter</a></div>
          <div class="useful-link">
            <a href="https://replit.com/languages/haskell" target="_blank">Haskell online (repl.it)</a></div>
          <div class="useful-link">
            <a href="https://www.swi-prolog.org/" target="_blank">SWI Prolog</a></div>
          <div class="useful-link">
            <a href="https://swish.swi-prolog.org/" target="_blank">SWI Prolog online</a></div>
          
        </div>
    </div>

    
</div>

<div class="left-side-nav">
  <div class="course-logo-nav">
      <a target="_blank" href="https://petlja.org">
          <img src="../_static/img/petlja-logo-wt.svg" alt="petlja.org" id="lightPetljaLogo">
      </a>
  </div>
  <div class="course-logo-nav-kabinet">
      <a target="_blank" href="https://petlja.org/net.kabinet">
          <img src="../_static/img/netkabinet-logo-strelica-wt.svg" alt="petlja.org" id="lightNetKabinetLogo">
      </a>
  </div>
</div>


<div class="content-header-label" id = "content-header-label" href="../">Увод у програмске парадигме, логичко и функционално програмирање за четврти разред специјализованих ИТ одељења</div>

</div>




<div class="petljaCourseContainer">

<div class="petljaCourseContent">
  
           <div class="tableOfContent">
            <h5> Садржај </h5>
            </div>
           <div>
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-01%20paradigme>
                    <h5>О програмским парадигмама</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../01%20paradigme/01_o_paradigmama.html><div class="studioLecture" id=activity-01%20paradigme-01_o_paradigmama><i class="fas fa-file-alt activity-icon"></i>О програмским језицима и парадигмама</div></a>
                <a href=../01%20paradigme/02_imperativna.html><div class="studioLecture" id=activity-01%20paradigme-02_imperativna><i class="fas fa-file-alt activity-icon"></i>Императивна парадигма</div></a>
                <a href=../01%20paradigme/03_oop.html><div class="studioLecture" id=activity-01%20paradigme-03_oop><i class="fas fa-file-alt activity-icon"></i>Објектнооријентисана парадигма</div></a>
                <a href=../01%20paradigme/04_skript.html><div class="studioLecture" id=activity-01%20paradigme-04_skript><i class="fas fa-file-alt activity-icon"></i>Скрипт парадигма</div></a>
                <a href=../01%20paradigme/05_o_paradigmama_quiz.html><div class="studioLecture" id=activity-01%20paradigme-05_o_paradigmama_quiz><i class="far fa-question-circle activity-icon"></i>Квиз</div></a>
                </div>
            </div>
                
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-02%20funkcionalna>
                    <h5>Функционална парадигма</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../02%20funkcionalna/01_funkcionalna.html><div class="studioLecture" id=activity-02%20funkcionalna-01_funkcionalna><i class="fas fa-file-alt activity-icon"></i>О функционалној парадигми</div></a>
                <a href=../02%20funkcionalna/01a_funkcionalna_quiz.html><div class="studioLecture" id=activity-02%20funkcionalna-01a_funkcionalna_quiz><i class="far fa-question-circle activity-icon"></i>Квиз</div></a>
                <a href=../02%20funkcionalna/02_haskell.html><div class="studioLecture" id=activity-02%20funkcionalna-02_haskell><i class="fas fa-file-alt activity-icon"></i>Haskell - изрази и функције</div></a>
                <a href=../02%20funkcionalna/02b_haskell_liste.html><div class="studioLecture" id=activity-02%20funkcionalna-02b_haskell_liste><i class="fas fa-file-alt activity-icon"></i>Haskell - листе</div></a>
                <a href=../02%20funkcionalna/02c_haskell_tipovi.html><div class="studioLecture" id=activity-02%20funkcionalna-02c_haskell_tipovi><i class="fas fa-file-alt activity-icon"></i>Haskell - алгебарски типови података</div></a>
                <a href=../02%20funkcionalna/02e_haskell_main.html><div class="studioLecture" id=activity-02%20funkcionalna-02e_haskell_main><i class="fas fa-file-alt activity-icon"></i>Haskell - улаз, излаз, главни програм</div></a>
                <a href=../02%20funkcionalna/02z_haskell_vezba.html><div class="studioLecture" id=activity-02%20funkcionalna-02z_haskell_vezba><i class="fas fa-file-alt activity-icon"></i>Haskell - задаци за вежбу</div></a>
                <a href=../02%20funkcionalna/02d_haskell_primeri.html><div class="studioLecture" id=activity-02%20funkcionalna-02d_haskell_primeri><i class="fas fa-file-alt activity-icon"></i>Haskell - пример већег програма</div></a>
                </div>
            </div>
                
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-03%20logicka>
                    <h5>Логичка парадигма</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../03%20logicka/01_logicka.html><div class="studioLecture" id=activity-03%20logicka-01_logicka><i class="fas fa-file-alt activity-icon"></i>О логичкој парадигми</div></a>
                <a href=../03%20logicka/01_iskazna_logika.html><div class="studioLecture" id=activity-03%20logicka-01_iskazna_logika><i class="fas fa-file-alt activity-icon"></i>Исказна логика</div></a>
                <a href=../03%20logicka/01_sat.html><div class="studioLecture" id=activity-03%20logicka-01_sat><i class="fas fa-file-alt activity-icon"></i>SAT решавачи</div></a>
                <a href=../03%20logicka/01a_iskazna_logika_quiz.html><div class="studioLecture" id=activity-03%20logicka-01a_iskazna_logika_quiz><i class="far fa-question-circle activity-icon"></i>Исказна логика - квиз</div></a>
                <a href=../03%20logicka/02_predikatska_logika.html><div class="studioLecture" id=activity-03%20logicka-02_predikatska_logika><i class="fas fa-file-alt activity-icon"></i>Предикатска логика</div></a>
                <a href=../03%20logicka/02_atp.html><div class="studioLecture" id=activity-03%20logicka-02_atp><i class="fas fa-file-alt activity-icon"></i>Аутоматски доказивачи теорема</div></a>
                <a href=../03%20logicka/02a_predikatska_logika_quiz.html><div class="studioLecture" id=activity-03%20logicka-02a_predikatska_logika_quiz><i class="far fa-question-circle activity-icon"></i>Предикатска логика - квиз</div></a>
                <a href=../03%20logicka/03_prolog.html><div class="studioLecture" id=activity-03%20logicka-03_prolog><i class="fas fa-file-alt activity-icon"></i>Prolog - база знања и правила извођења</div></a>
                <a href=../03%20logicka/03_prolog_secenje.html><div class="studioLecture" id=activity-03%20logicka-03_prolog_secenje><i class="fas fa-file-alt activity-icon"></i>Prolog - дрво извођења, сечење</div></a>
                <a href=../03%20logicka/03_prolog_aritmetika.html><div class="studioLecture" id=activity-03%20logicka-03_prolog_aritmetika><i class="fas fa-file-alt activity-icon"></i>Prolog - аритметичка израчунавања</div></a>
                <a href=../03%20logicka/03_prolog_liste.html><div class="studioLecture" id=activity-03%20logicka-03_prolog_liste><i class="fas fa-file-alt activity-icon"></i>Prolog - листе</div></a>
                <a href=../03%20logicka/03_prolog_zagonetke.html><div class="studioLecture" id=activity-03%20logicka-03_prolog_zagonetke><i class="fas fa-file-alt activity-icon"></i>Prolog - решавање логичких загонетки</div></a>
                <a href=../03%20logicka/03z_prolog_zadaci.html><div class="studioLecture" id=activity-03%20logicka-03z_prolog_zadaci><i class="fas fa-file-alt activity-icon"></i>Prolog - задаци за самостални рад</div></a>
                </div>
            </div>
                </div>
</div>



<div class="lectureContent">

  <div id="errors">
  </div>
  
  <div class="lectureContentMaterial">
  
    <div id="main-content">
    
  <section id="id1">
<h1>Функционална парадигма<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h1>
<p>Покушајмо да илуструјемо основне идеје функционалне парадигме кроз
један једноставан пример. Пример је веома једноставан и његово
императивно решење није наоричито компликовано. Ипак, кроз низ
међукорака полазни програм ћемо трансформисати, да бисмо на крају
приказали решење које је потпуно у духу функционалног програмирања,
користи богату библиотечку подршку (библиотеке Linq) и које ће бити
јасније и читљивије од полазног императивног, а самим тим вероватно и
једноставније (наравно, када усвојите основне концепте функционалног
програмирања). Наравно, исти принципи који ће бити изложени на овом
веома једноставном примеру се примењују и при решавању комплекснијих
задатака и њихова предност тада постаје још јаче изражена.</p>
<p>Исти задатак ће бити решен императивно, у језику C#, затим
функционално, у језику C# коришћењем библиотеке Linq и на крају у
функционалном језику Haskell. Циљ нам је, дакле, да прикажемо како се
стил програмирања карактеристичан за функционалне програмске језике
(попут језика Haskell) присутан и у нашироко популарним индустријским
језицима, какав је C# (за њега слободно можемо рећи да је
мултипарадигматичан).</p>
<section id="c">
<h2>Решење у језику C#<a class="headerlink" href="#c" title="Permalink to this heading">¶</a></h2>
<section id="id2">
<h3>Полазни проблем<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h3>
<p>Напишимо програм за одређивање збира квадрата непарних цифара унетог
позитивног природног броја. То је задатак какав сте сигурно сретали у
првом разреду и сигурно бисте га коришћењем императивне парадигме
решили на следећи начин.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Program</span>
<span class="p">{</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">ZbirKvadrataNeparnihCifara</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">zbir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">cifra</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="m">10</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cifra</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">               </span><span class="n">zbir</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">cifra</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cifra</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">zbir</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">int</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">());</span>
<span class="w">         </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">ZbirKvadrataNeparnihCifara</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id3">
<h3>Декомпозиција проблема<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h3>
<p>Размотримо да ли бисмо могли да идентификујемо појединачне алгоритме
које смо употребили у овом решењу. Размислимо, да ли бисмо неки од
њих, у складу са добром праксом процедуралног програмирања, могли да
издвојимо у посебну функцију која би нам била корисна и у другим
задацима? Прво, у решењу се користи поступак заснован на целобројном
дељењу у којем се одређују једна по једна цифра датог броја (и то
здесна налево). Тиме од датог броја добијамо серију његових
цифара. Након тога издвајамо и шаљемо на даљу обраду само оне цифре
које су непарне. Потом сваку од тих цифара квадрирамо. И на крају,
рачунамо збир тако добијених квадрата. Разлагањем овог алгоритма на
саставне делове, за улаз 12345 се добија следећа секвенца
међурезултата.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>12345 → [5, 4, 3, 2, 1] → [5, 3, 1] → [25, 9, 1] → 35.
</pre></div>
</div>
<p>Кључна идеја је да извршимо декомпозицију проблема, тј. да сложени
алгоритам изразимо као композицију једноставнијих алгоритама. Хајде
сада да напишемо кôд који ради на овај начин.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Program</span>
<span class="p">{</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Cifre</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">       </span><span class="kt">var</span><span class="w"> </span><span class="n">rezultat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">       </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">       </span><span class="p">{</span>
<span class="w">          </span><span class="n">rezultat</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="m">10</span><span class="p">);</span>
<span class="w">          </span><span class="n">n</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="m">10</span><span class="p">;</span>
<span class="w">       </span><span class="p">}</span>
<span class="w">       </span><span class="k">return</span><span class="w"> </span><span class="n">rezultat</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IzdvojNeparneCifre</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cifre</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">var</span><span class="w"> </span><span class="n">rezultat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">        </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">cifra</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">cifre</span><span class="p">)</span>
<span class="w">           </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cifra</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">              </span><span class="n">rezultat</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">cifra</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">rezultat</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">kvadrirajCifre</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cifre</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">var</span><span class="w"> </span><span class="n">rezultat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">        </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">cifra</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">cifre</span><span class="p">)</span>
<span class="w">            </span><span class="n">rezultat</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">cifra</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cifra</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">rezultat</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">Saberi</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">brojevi</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">zbir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">broj</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">brojevi</span><span class="p">)</span>
<span class="w">           </span><span class="n">zbir</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">broj</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">zbir</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">ZbirKvadrataNeparnihCifara</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nf">Saberi</span><span class="p">(</span><span class="n">KvadrirajCifre</span><span class="p">(</span><span class="n">IzdvojNeparneCifre</span><span class="p">(</span><span class="n">Cifre</span><span class="p">(</span><span class="n">n</span><span class="p">))));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">int</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">());</span>
<span class="w">         </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">ZbirKvadrataNeparnihCifara</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Програм је много дужи, али је свака појединачна функција доста
једноставнија него она у полазном решењу и исказује само један
појединачан алгоритам. Можемо рећи да је овај програм знатно
модуларнији него полазни, који је прилично монолитан. Добра
декомпозиција и модуларност нам доприносе разумљивости кода и лакшој
имплементацији, јер се фокусирамо на мање и једноставније проблеме
(једноставније је написати функцију за сабирање листе бројева, него
полазну функцију која ради неколико задатака од једном). Такође,
доприноси и поновној искористивости кода, јер исту функцију можемо
употребити и у другим програмима (лако је разумети да су за разлику од
полазне функције која сабира квадрате непарних цифара броја и функција
која издваја појединачне цифре и функција која сабира елементе листе
бројева корисна и у другим програмима програмима).</p>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>Суштина функционалног програмирања долази у изражавању свих
израчунавања у облику већег броја мањих функција, по могућности
стандардног облика и проналажењу начина да те функције компонујемо
тако да добијемо комплексније функције које изражавају решења нашег
проблема. Стил разбијања проблема на потпроблеме и њиховог решења
на композицију једноставнијих блокова присутан је и на другим
местима у рачунарству. Током 1960их година направљен је оперативни
систем UNIX, а принципи које је он увео се и данас користе (пре
свега на оперативном систему Linux, али и у командној линији
система Windows постоји слична функционалност). Основу UNIX
филозофије представља колекција једноставних програма који раде
јасно дефинисане задатке, чијом се композицијом остварује решавање
сложенијих задатака.</p>
<ul class="simple">
<li><p>Write programs that do one thing and do it well.</p></li>
<li><p>Write programs to work together.</p></li>
<li><p>Write programs to handle text streams, because that is a universal interface.</p></li>
</ul>
<p>Композиција се остварује компоновањем програма. На пример,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cat datumi.txt | egrep “januar” | sort -n | uniq
</pre></div>
</div>
<p>Овим излиставамо датотеку <code class="docutils literal notranslate"><span class="pre">datumi.txt</span></code> затим одређујемо све њене
линије које садрже реч <code class="docutils literal notranslate"><span class="pre">januar</span></code>, сортирамо их и на крају
елиминишемо дупликате. Оператор | (чита се пајп) изражава
композицију тако што излаз свог првог аргумента усмерава на улаз
свог другог аргумента.</p>
<p>Рецимо да датотека <code class="docutils literal notranslate"><span class="pre">datumi.txt</span></code> садржи следећи текст:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">4.</span> <span class="n">januar</span> <span class="mf">2017.</span>
<span class="mf">1.</span> <span class="n">januar</span> <span class="mf">1993.</span>
<span class="mf">13.</span> <span class="n">jul</span> <span class="mf">2008.</span>
<span class="mf">17.</span> <span class="n">februar</span> <span class="mf">2023.</span>
<span class="mf">4.</span> <span class="n">januar</span> <span class="mf">2017.</span>
<span class="mf">19.</span> <span class="n">decembar</span> <span class="mf">2005.</span>
</pre></div>
</div>
<p>Команда <code class="docutils literal notranslate"><span class="pre">cat</span></code> чита садржај те датотеке и исписује га на свој
стандардни излаз. Када бисмо издали команду <code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">datumi.txt</span></code> овај
садржај би се појавио на екрану. Команда <code class="docutils literal notranslate"><span class="pre">egrep</span></code> чита линију по
линију и издваја оне које садрже дату реч (или дати регуларни
израз). Команда <code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">datumi.txt</span> <span class="pre">|</span> <span class="pre">egrep</span> <span class="pre">&quot;januar&quot;</span></code> шаље излаз
команде <code class="docutils literal notranslate"><span class="pre">cat</span></code> тј. садржај наше датотеке, на улаз команде
<code class="docutils literal notranslate"><span class="pre">egrep</span></code>, која затим филтрира линије и исписује на свој излаз само
оне које садрже реч <code class="docutils literal notranslate"><span class="pre">januar</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">4.</span> <span class="n">januar</span> <span class="mf">2017.</span>
<span class="mf">1.</span> <span class="n">januar</span> <span class="mf">1993.</span>
<span class="mf">4.</span> <span class="n">januar</span> <span class="mf">2017.</span>
</pre></div>
</div>
<p>Новом применом оператора <code class="docutils literal notranslate"><span class="pre">|</span></code> овај излаз се уместо да се прикаже
на екрану преусмерава на улаз наредне команде, <code class="docutils literal notranslate"><span class="pre">sort</span> <span class="pre">-n</span></code>, која
сортира линије. Параметар <code class="docutils literal notranslate"><span class="pre">-n</span></code> служи да би се сортирање извршило
нумерички, а не лексикографски. Након сортирања добија се</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="n">januar</span> <span class="mf">1993.</span>
<span class="mf">4.</span> <span class="n">januar</span> <span class="mf">2017.</span>
<span class="mf">4.</span> <span class="n">januar</span> <span class="mf">2017.</span>
</pre></div>
</div>
<p>На крају, овај се излаз предаје команди <code class="docutils literal notranslate"><span class="pre">uniq</span></code> која елиминише
дупликате и која на екран исписује</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="n">januar</span> <span class="mf">1993.</span>
<span class="mf">4.</span> <span class="n">januar</span> <span class="mf">2017.</span>
</pre></div>
</div>
<p>Дакле, можемо да кажемо да функционално програмирање и UNIX деле
исту филозофију композионалности једноставних целина која се током
година показала веома успешном. Кључни моменат је то што је
имплементација пајп оператора (тј. композиције) таква да се
међурезултати не материјализују цели у меморији, већ се након сваке
обрађене линије од стране првог програма резултат обраде одмах
прослеђује на улаз другог програма, избегавајући да се цео излаз
програма истовремено чува у меморији. Ово је веома важна идеја,
која се користи и у функционалном програмирању и сада ћемо је дубље
размотрити.</p>

    </div></div>
</section>
<section id="id4">
<h3>Лењост<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h3>
<p>Уз све његове предности, претходно решење не можемо сматрати
прихватљивим. Свако компоновање две функције подразумевало је да прва
функција свој резултат врати другој, која онда тај резултат преузима
као свој улазни параметар. Током декомпоновања проблема на
једноставније, већина међурезултата је заправо представљала неке
серије бројева и у претходном решењу су те серије бројева представљене
листама, што значи да је током извршавања претходног алгоритма
креирано неколико листи, чији су сви елементи истовремено заузимали
меморију. У случају кратких серија, као у овом примеру, то није
критично, али можемо лако замислити ситуације у којима се ради са
серијама од неколико десетина, па и стотина хиљада елемената и јасно
је да је тада цена коју плаћамо зарад лепе декомпозиције програма
превелика. То је један од разлога зашто се у класичним програмским
језицима декомпозиција обично не ради до краја и зашто су кораци који
се програмирају обично крупни (цео овај задатак би у класичном
програмирању по правилу био имплементиран у облику једне функције, као
у нашем почетном решењу), задржавајући се на нижем степену
модуларности. Да ли постоји начин да овај проблем превазиђемо? Решење
долази у облику лењог израчунавања. Наиме, функције не морају да
комуницирају преко листа, већ је могуће да употребимо лење токове о
којима је било речи у курсу објектно-оријентисаног програмирања у
језику C#. Подсетимо се, лењи ток представљамо преко интерфејса
<code class="docutils literal notranslate"><span class="pre">IEnumerable</span></code>, а градимо га најједноставније наредбом <code class="docutils literal notranslate"><span class="pre">yield</span>
<span class="pre">return</span></code> која узрокује да се извршавање функције суспендује и настави
тек када је позиваоцу потребан наредни елемент (не извршава се цела
функција одједном, већ само по потреби и зато кажемо да се она
извршава лењо).</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Program</span>
<span class="p">{</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Cifre</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">       </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">       </span><span class="p">{</span>
<span class="w">          </span><span class="k">yield</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="m">10</span><span class="p">;</span>
<span class="w">          </span><span class="n">n</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="m">10</span><span class="p">;</span>
<span class="w">       </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IzdvojNeparneCifre</span><span class="p">(</span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cifre</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">cifra</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">cifre</span><span class="p">)</span>
<span class="w">           </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cifra</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">              </span><span class="k">yield</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">cifra</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">kvadrirajCifre</span><span class="p">(</span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cifre</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">         </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">cifra</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">cifre</span><span class="p">)</span>
<span class="w">              </span><span class="k">yield</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">cifra</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cifra</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">Saberi</span><span class="p">(</span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">brojevi</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">zbir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">broj</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">brojevi</span><span class="p">)</span>
<span class="w">           </span><span class="n">zbir</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">broj</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">zbir</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">ZbirKvadrataNeparnihCifara</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nf">Saberi</span><span class="p">(</span><span class="n">KvadrirajCifre</span><span class="p">(</span><span class="n">IzdvojNeparneCifre</span><span class="p">(</span><span class="n">Cifre</span><span class="p">(</span><span class="n">n</span><span class="p">))));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">int</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">());</span>
<span class="w">         </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">ZbirKvadrataNeparnihCifara</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Лењост нам доноси много боље решење од претходног и омогућава да
декомпозицију извршимо без меморијских и временских неефикасности које
би нам суштински спречиле декомпозицију у језицима у којима лењост
није подржана (покушајте да направите функцију која враћа листу од
милион елемената и лењи ток од милион елемената, саберите елементе
резултата и упоредите меморију коју та два програма заузимају током
извршавања). Иако у претходном програму радимо са токовима које
замишљамо као серије (низове, листе) цифара, захваљујући лењости, оне
се не материјализују и ниједан од међурезултата није интегрално
присутан у меморији. Сваки наредни елемент серије се израчунава само у
тренутку када функција позивалац затражи наредни елемент (у склопу
своје петље <code class="docutils literal notranslate"><span class="pre">foreach</span></code>), при чему је организација таква да када нам
наредни елемент затреба, претходни елемент обично више није
потребан. Јасно је да имплементација лењости носи са собом додатне
захтеве (потребно је некако запамтити где се стало са извршавањем
сваке функције која је суспендована наредбом <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">return</span></code>) и то
носи са собом неку цену. Међутим, у већини случајева та цена неће бити
таква да угрожава декомпозицију на мање модуле, за разлику од
сценарија без лењости у коме је јасно да су пенали које плаћамо
превелики и да они суштински заустављају декомпозицију,
тј. модуларизацију.</p>
<p><em>Лењост</em>, генерално, подразумева да се вредност неког израза
израчунава само када је то заиста неопходно. На пример, логички
оператори <cite>&amp;&amp;</cite> и <cite>||</cite> се израчунавају лењо: када је први операнд такав
да се на основу њега може закључити вредност целог израза, вредност
другог операнда се не израчунава.</p>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>Помало изненађујуће, лењост омогућава да се у програмима користе
бесконачне колекције података (на пример, листа свих природних или
листа свих простих бројева). Наравно, оне се не могу сместити у
меморију рачунара, но лење колекције се ионако никада не смештају
целе у меморију. Може се дефинисати функција која враћа један по
један елемент такве колекције и онда се њеним узастопним позивима
итерирати кроз елементе такве колекције. Наравно, да би се прошло
кроз бесконачну колекцију потребно је бесконачно времена, тако да
се на овај начин, да цитирамо чувеног Чарсла Бебиџа, бесконачност
простора преводи у бесконачност времена.</p>
<p>Размотримо један пример. Колацова секвенца се дефинише на следећи
начин. Почетни елемент може бити произвољни природни број, а
наредни елемент се одређује на основу текућег применом следећих
правила:</p>
<ul class="simple">
<li><p>ако је текући елемент <span class="math notranslate nohighlight">\(n\)</span> паран, наредни број једнак је
<span class="math notranslate nohighlight">\(\frac{n}{2}\)</span>;</p></li>
<li><p>ако је текући елемент <span class="math notranslate nohighlight">\(n\)</span> непаран, наредни број једнак
је <span class="math notranslate nohighlight">\(3n+1\)</span>.</p></li>
</ul>
<p>На пример, кренувши од броја 3 добија се низ 3, 10, 5, 16, 8, 4, 2,
1, 4, 2, 1, 4, 2, 1, …</p>
<p>Размотримо следећу имплементацију функције која враћа (бесконачну)
серију Колацових бројева.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Program</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">ulong</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Collatz</span><span class="p">(</span><span class="kt">ulong</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">yield</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">                </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">2</span><span class="p">;</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">                </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">ulong</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">ulong</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">());</span>
<span class="w">        </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">ulong</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">Collatz</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
<p>Програм се никада не зауставља и примећујемо да после неколико
почетних бројева креће да стално исписује 1, 4, 2, 1, 4, 2, …</p>
<p>Ако желимо да испишемо само првих неколико елемената секвенце
можемо или прекинути петљу у функцији <code class="docutils literal notranslate"><span class="pre">Main</span></code> после одређеног
корака или можемо употребити методу <code class="docutils literal notranslate"><span class="pre">Take</span></code> библиотеке Linq па
употребити петљу <code class="docutils literal notranslate"><span class="pre">foreach</span> <span class="pre">(ulong</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">Collatz(n).Take(k))</span></code> којом
бисмо исписали првих <code class="docutils literal notranslate"><span class="pre">k</span></code> елемената. Пошто секвенца постаје
неинтересантна након што се појави прва јединица могли бисмо у
функцији <code class="docutils literal notranslate"><span class="pre">Collatz</span></code>, која је генерише, можемо додати прекид петље
након што је враћен елемент 1.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">ulong</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Collatz</span><span class="p">(</span><span class="kt">ulong</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">yield</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="p">)</span>
<span class="w">           </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">           </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">2</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">           </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>На овај начин делује да ће колекција која се овом функцијом враћа
увек бити коначна. Међутим, то не знамо. Наиме, нико до сада није
успео нити да докаже нити да оповргне да ће се за било који избор
почетне вредности <code class="docutils literal notranslate"><span class="pre">n</span></code> заиста некад стићи до вредности 1 и да ће
се набрајање зауставити. Овај проблем је чувен по томе што се
формулише изузетно једноставно, а и даље га нико није решио. Дакле,
без обзира на то што смо додали прекид петље и даље постоји
теоријска могућност да ће се за неко <code class="docutils literal notranslate"><span class="pre">n</span></code> добити бесконачна
колекција. Наравно, ова имплементација је наивна јер се користи тип
<cite>ulong</cite> који је ограничен, па може доћи до прекорачења, међутим,
није је тешко поправити је тако што би се користили неограничени
цели бројеви (на пример, тип <code class="docutils literal notranslate"><span class="pre">BigInteger</span></code>).</p>

    </div></div>
</section>
<section id="id5">
<h3>Апстракција и функције вишег реда<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h3>
<p>Решење које смо написали је лепо и довољно ефикасно. Декомпозиција је
омогућила да се сваки алгоритам појединачно имплементира и свака од
ових функција се једноставније разуме него полазна сложена
функција. Ипак, главни добитак ће бити ако успемо да ове функције
ставимо у библиотеку и употребимо их у различитим контекстима. Кључни
проблем у овоме је то што оваквих малих, корисних функција има заиста
прегршт. Ако бисмо у библиотеци имали функцију која квадрира све цифре
у некој серији, зашто не бисмо имали и функцију која израчунава њихове
кубове? Ако имамо функцију која издваја све непарне цифре, зашто не
бисмо имали и ону која издваја све парне цифре или све оне дељиве са
три? Зашто не бисмо имали функцију која из листе бројева издваја све
оне који су негативни или све оне који су потпуни квадрати? Таква
библиотека би била превелика и јасно је да бисмо увек наишли на неки
сценарио за који у библиотеци не бисмо нашли решење. Потребно је да
направимо одређену апстракцију. Размотримо шта би се разликовало код
наше функције која издваја непарне бројеве и функције која би
издвајала негативне бројеве из неке серије (лењог тока).</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IzdvojNeparne</span><span class="p">(</span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">brojevi</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">broj</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">brojevi</span><span class="p">)</span>
<span class="w">       </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">broj</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">          </span><span class="k">yield</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">broj</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IzdvojNegativne</span><span class="p">(</span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">brojevi</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">broj</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">brojevi</span><span class="p">)</span>
<span class="w">       </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">broj</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">          </span><span class="k">yield</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">broj</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Примећујемо да се разликује само услов наредбе <code class="docutils literal notranslate"><span class="pre">if</span></code>. Да ли постоји
начин да тај услов проследимо некако функцији као параметар? На основу
онога што смо до сада користили, не постоји (осим да евентуално
направимо неки објекат у којем се методом представља услов који треба
проверити). C# нам пружа боље решење од тога. Функцији је као
параметар могуће проследити другу функцију! Када то урадимо, добијамо
<strong>функцију вишег реда</strong> или <strong>функционал</strong>. Тај концепт вам сигурно
није стран. Извод у математици је функционал који прими једну
функцију, а врати другу функцију. Тип функције се у језику C# дефинише
помоћу <code class="docutils literal notranslate"><span class="pre">Func&lt;&gt;</span></code>. На пример, тип <code class="docutils literal notranslate"><span class="pre">Func&lt;int,</span> <span class="pre">bool&gt;</span></code> означава тип
функције која прима један аргуемнт типа <code class="docutils literal notranslate"><span class="pre">int</span></code>, а враћа резултат типа
<code class="docutils literal notranslate"><span class="pre">bool</span></code>. Дакле, уместо гомиле појединачних функција које издвајају
елементе из серије, можемо направити генерички функционал који издваја
елементе који задовољавају дати услов, при чему се тај услов наводи
као параметар у облику функције која прима <code class="docutils literal notranslate"><span class="pre">int</span></code> и враћа <code class="docutils literal notranslate"><span class="pre">bool</span></code>
тј.  као податак типа <code class="docutils literal notranslate"><span class="pre">Func&lt;int,</span> <span class="pre">bool&gt;</span></code>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Izdvoj</span><span class="p">(</span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">brojevi</span><span class="p">,</span>
<span class="w">                               </span><span class="n">Func</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">uslov</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">broj</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">brojevi</span><span class="p">)</span>
<span class="w">       </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">uslov</span><span class="p">(</span><span class="n">broj</span><span class="p">))</span>
<span class="w">          </span><span class="k">yield</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">broj</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Слично, функција која је квадрирала сваки елемент серије се може
једноставно апстраховати до функционала који би примењивао задату
функцију која слика int у int на сваки елемент серије.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Preslikaj</span><span class="p">(</span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">brojevi</span><span class="p">,</span>
<span class="w">                                  </span><span class="n">Func</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">broj</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">brojevi</span><span class="p">)</span>
<span class="w">          </span><span class="k">yield</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">broj</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>У оваквој варијанти наш програм изгледа овако.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Program</span>
<span class="p">{</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Cifre</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">       </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">       </span><span class="p">{</span>
<span class="w">          </span><span class="k">yield</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="m">10</span><span class="p">;</span>
<span class="w">          </span><span class="n">n</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="m">10</span><span class="p">;</span>
<span class="w">       </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Izdvoj</span><span class="p">(</span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">brojevi</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">Func</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">uslov</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">broj</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">brojevi</span><span class="p">)</span>
<span class="w">           </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">uslov</span><span class="p">(</span><span class="n">broj</span><span class="p">))</span>
<span class="w">              </span><span class="k">yield</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">broj</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Preslikaj</span><span class="p">(</span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">brojevi</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">Func</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">broj</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">brojevi</span><span class="p">)</span>
<span class="w">              </span><span class="k">yield</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">broj</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">Saberi</span><span class="p">(</span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">brojevi</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">zbir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">broj</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">brojevi</span><span class="p">)</span>
<span class="w">           </span><span class="n">zbir</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">broj</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">zbir</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">neparan</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">broj</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">       </span><span class="k">return</span><span class="w"> </span><span class="n">broj</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">kvadrat</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">broj</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">       </span><span class="k">return</span><span class="w"> </span><span class="n">broj</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">broj</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">ZbirKvadrataNeparnihCifara</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nf">Saberi</span><span class="p">(</span><span class="n">Preslikaj</span><span class="p">(</span><span class="n">Izdvoj</span><span class="p">(</span><span class="n">Cifre</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="n">neparan</span><span class="p">),</span><span class="w"> </span><span class="n">kvadrat</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">int</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">());</span>
<span class="w">         </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">ZbirKvadrataNeparnihCifara</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Функције <code class="docutils literal notranslate"><span class="pre">Izdvoj</span></code> и <code class="docutils literal notranslate"><span class="pre">Preslikaj</span></code> су већ прилично опште, употребљиве
у разним програмима и имало би смисла убацити их у библиотеку.  Остаје
проблем то што раде само над токовима типа <code class="docutils literal notranslate"><span class="pre">int</span></code>. Међутим, то би се
лако дало уопштити коришћењем параметарског полиморфизма и генеричких
функција о којима је било речи у курсу објектно-оријентисаног
програмирања у језику C#, тако да се сада тиме нећемо бавити.  Оно што
је било помало неконформно у претходном решењу је то што смо морали да
дефинишемо посебне функције <code class="docutils literal notranslate"><span class="pre">neparan</span></code> и <code class="docutils literal notranslate"><span class="pre">kvadrat</span></code>. Да би се
избегло прављење таквих једнократних функција, на располагању нам
стоје <strong>анонимне функције</strong>, тј. <strong>ламбда–изрази</strong>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">ZbirKvadrataNeparnihCifara</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nf">Saberi</span><span class="p">(</span><span class="n">Preslikaj</span><span class="p">(</span><span class="n">Izdvoj</span><span class="p">(</span><span class="n">Cifre</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m">0</span><span class="p">),</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Израз <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=&gt;</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">x</span></code> представља функцију која прима број <code class="docutils literal notranslate"><span class="pre">x</span></code>, а
враћа његов квадрат. Приметимо да није потребно да наведемо тип, већ
га компилатор одређује из контекста (врши се дедукција типова, слично
као што је био случај са <code class="docutils literal notranslate"><span class="pre">var</span></code>).</p>
<p>За језике које подржавају да се функције додељују променљивама, шаљу
као аргументи другим функцијама, враћају као њихови резултати и
слично, кажемо да су функције „грађани првог реда” и да су функцијски
типови равноправним свим другим типовима (бројевима, низовима, …).
Дакле, у функционалном програмирању функције се могу користити као
подаци!</p>
</section>
<section id="linq">
<h3>Библиотека Linq<a class="headerlink" href="#linq" title="Permalink to this heading">¶</a></h3>
<p>Ако упоредимо добијену верзију програма са почетном, императивном, и
даље се с правом може замерити да је добијено решење доста
компликованије од полазног, јер су све функције имплементиране ручно.
Програм постаје много једноставнији када се уместо ручне
имплементације функција употреби њихова библиотечка имплементације.
Библиотека језика C# која пружа функционалност функционала <code class="docutils literal notranslate"><span class="pre">Izdvoj</span></code>
и <code class="docutils literal notranslate"><span class="pre">Preslikaj</span></code> и која подршку за функционални стил програмирања у том
језику је библиотека <strong>Linq</strong>. Она је део стандардне библиотеке језика
C# и није је потребно посебно инсталирати.</p>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>Библиотека Language Integrated Query (LINQ) је интегрални део
развојног оквира .NET и језика C#, која омогућава програмерима да
изражавају упите над различитим изворима података, као што су
колекције објеката, базе података, XML документи, и други,
користећи декларативан приступ. LINQ омогућава ефикасан рад са
подацима, филтрирање, пресликавање, груписање, пројектовање и
спајање података, чиме олакшава развој апликација и побољшава
читљивост кода.</p>

    </div></div>
<p>Метода <code class="docutils literal notranslate"><span class="pre">Where</span></code> пружа исту функционалност као наша функција
<code class="docutils literal notranslate"><span class="pre">Izdvoj</span></code> (издваја елементе на основу датог услова), метода
<code class="docutils literal notranslate"><span class="pre">Select</span></code> пружа исту функционалност као наша функција <code class="docutils literal notranslate"><span class="pre">Preslikaj</span></code>
(пресликава елементе применом дате функције), док метода <code class="docutils literal notranslate"><span class="pre">Sum</span></code> пружа
исту функционалност као наша функција <code class="docutils literal notranslate"><span class="pre">Saberi</span></code> (израчунава збир свих
елемената). Све три су методе проширења над <code class="docutils literal notranslate"><span class="pre">IEnumerable</span></code>. Тиме
долазимо до финалне C# верзије нашег програма. Имена <code class="docutils literal notranslate"><span class="pre">Select</span></code> и
<code class="docutils literal notranslate"><span class="pre">Where</span></code> долазе од везе библиотеке Linq и база података, али се том
везом сада нећемо бавити.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System.Linq</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Program</span>
<span class="p">{</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Cifre</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">       </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">       </span><span class="p">{</span>
<span class="w">          </span><span class="k">yield</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="m">10</span><span class="p">;</span>
<span class="w">          </span><span class="n">n</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="m">10</span><span class="p">;</span>
<span class="w">       </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">ZbirKvadrataNeparnihCifara</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nf">Cifre</span><span class="p">(</span><span class="n">n</span><span class="p">).</span><span class="n">Where</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m">0</span><span class="p">).</span><span class="n">Select</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">).</span><span class="n">Sum</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">int</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">());</span>
<span class="w">         </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">ZbirKvadrataNeparnihCifara</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Иако није написан у функционалном програмском језику, овај програм је
написан у функционалном програмском стилу. Резимирајмо основе концепте
које смо кроз овај једноставан пример упознали:</p>
<ul class="simple">
<li><p>Уместо једног монолитног алгоритма, проблем је решен тако што је
алгоритам разложен на низ веома елементарних корака који се
сукцесивно примењују (у овом пример то су били изградња низа цифара
броја, издвајање елемената низа који задовољавају неко дато
својство, пресликавање сваког елемента низа применом дате функције и
сабирање свих елемената низа).</p></li>
<li><p>Већину тих једноставних алгоритамских корака није било потребно
ручно имплементирати, јер постоји њихова библиотечка имплементација.</p></li>
<li><p>Да би библиотечке имплементације биле довољно опште, оне су
параметризоване помоћу функција, које им се предају приликом позива
(при чему је врло удобно за то користити синтаксу анонимних
функција).</p></li>
<li><p>Појединачни алгоритамски кораци примају и враћају серије података.
Ако се те серије реализују помоћу лењих колекција уместо класичних
низова или листа података, елементи се не чувају истовремено у
меморији и добијају се ефикаснији програми (пре свега меморијски
ефикаснији).</p></li>
</ul>
<p>Велики број карактеристика функционалних језика је уграђен у савремене
програмске језике какви су и C#, Python, па у некој мери и C++ и Java
(у овом примеру смо користили лењост, функције вишег реда, анонимне
функције). Савремени трендови у свету програмирања управо су на тој
линији – коришћење функционалног приступа у класичним програмским
језицима. Ипак, постоје и класични, чисти функционални програмски
језици и у наставку овог курса ћемо упознати језик Haskell, који је
типични представник чистог функционалног програмског језика.</p>
</section>
</section>
<section id="haskell">
<h2>Решење у језику Haskell<a class="headerlink" href="#haskell" title="Permalink to this heading">¶</a></h2>
<p>Размотримо сада како се претходни пример може испрограмирати у
програмском језику Haskell, којим ћемо се детаљније бавити у наставку
овог курса. Циљ овог поглавља је само да повучемо паралелу и приметимо
велику сличност између концепата које смо упознали у претходном решењу
у језику C# са решењем у чисто функционалном језику. Ово је прилика да
се на веома једноставном, али илустративном примеру упознамо са неким
основим елементима језика Haskell. У овом трентуку се од вас очекује
само да пробате да разумете написани кôд, а не да можете самостално да
пишете програме у овом програмском језику. У наредним поглављимо ћемо
веома постепено уводити овај програмски језик, са пуно примера и
задатака и тада ће се од вас очекивати и да кренете да у њему
самостално програмирате. У овој фази чак можете и да прескочите читање
решења у овом програмском језику, можете прочитати наредне лекције
решавајући тамо задате задатке, а затим се на крају вратити на овај
пример.</p>
<p>Једно решење претходног задатка у језику Haskell је следеће.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">cifre</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">cifre</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span>
<span class="nf">cifre</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="p">`</span><span class="n">mod</span><span class="p">`</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">cifre</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="p">`</span><span class="n">div</span><span class="p">`</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>

<span class="nf">zbirKvadrataNeparnihCifara</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">zbirKvadrataNeparnihCifara</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span>
<span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="p">(</span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">`</span><span class="n">mod</span><span class="p">`</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">cifre</span><span class="w"> </span><span class="n">n</span><span class="p">)))</span>
</pre></div>
</div>
<p>Видећемо да је, осим синтаксичких разлика, овај програм у свом духу
прилично сличан програму који смо написали у језику C#.</p>
<section id="id6">
<h3>Анотације типова<a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h3>
<p>Претходни програм садржи дефиницију две функције: <code class="docutils literal notranslate"><span class="pre">cifre</span></code> и
<code class="docutils literal notranslate"><span class="pre">zbirKvadrataNeparnihCifara</span></code>. Линије <code class="docutils literal notranslate"><span class="pre">cifre</span> <span class="pre">::</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">[Int]</span></code> и
<code class="docutils literal notranslate"><span class="pre">zbirKvadrataNeparnihCifara</span> <span class="pre">::</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code> одговарају декларацијама
функција. Прва, на пример, каже да је <code class="docutils literal notranslate"><span class="pre">cifre</span></code> функција која прима
<code class="docutils literal notranslate"><span class="pre">Int</span></code> а враћа листу података типа <code class="docutils literal notranslate"><span class="pre">Int</span></code> (податак типа <code class="docutils literal notranslate"><span class="pre">[Int]</span></code>),
а друга да је <code class="docutils literal notranslate"><span class="pre">zbirKvadrataNeparnihCifara</span></code> функција која прима
<code class="docutils literal notranslate"><span class="pre">Int</span></code> и враћа <code class="docutils literal notranslate"><span class="pre">Int</span></code>. Занимљиво, ове анотације типова су потпуно
опционе. Чак и да их не наведемо, језик Haskell има механизам
дедукције типова и он ће, на основу дефиниција које следе, закључити
ког типа су ове функције (могуће је да чак закључи и општије типове
него ове које смо навели, јер се, на пример, збир може примењивати на
листу било којих нумеричких елемената, а не само елемената типа
<code class="docutils literal notranslate"><span class="pre">Int</span></code>).</p>
</section>
<section id="id7">
<h3>Рекурзивне дефиниције<a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h3>
<p>Прво је дефинисана функција која на основу броја одређује листу
његових цифара. Примећујете, наравно, коришћена је рекурзија о којој
смо већ много говорили у другом и трећем разреду. Наиме, функционални
програмски језици не подржавају измену вредности променљивих, па самим
тим итерацију није могуће остварити (свака петља се заснива на томе да
се током њеног извршавања мења вредност неке променљиве).</p>
<p>За број 0 резултат је празна листа означена са <code class="docutils literal notranslate"><span class="pre">[]</span></code> (ово нам служи
као излаз из рекурзије, а коректно је јер је у тексту задатка
претпостављено да је број увек позитиван).</p>
<p>За бројеве различите од нула, то је листа која се добије тако што се
остатак при дељењу са 10 дода на почетак листе која се добије када се
одреди листа цифара целобројног количника броја подељеног
са 10. Додавање појединачног броја на почетак листе остварено је
помоћу оператора <code class="docutils literal notranslate"><span class="pre">:</span></code> (на пример, <code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">:</span> <span class="pre">[3,</span> <span class="pre">2,</span> <span class="pre">4]</span></code> даје листу
<code class="docutils literal notranslate"><span class="pre">[5,</span> <span class="pre">3,</span> <span class="pre">2,</span> <span class="pre">4]</span></code>).  Операторе <code class="docutils literal notranslate"><span class="pre">mod</span></code> и <code class="docutils literal notranslate"><span class="pre">div</span></code> смо писали инфиксно, и да
бисмо могли да их користимо инфиксно морали смо да их наведемо у
оквиру ових необичних наводника (<code class="docutils literal notranslate"><span class="pre">mod</span> <span class="pre">12</span> <span class="pre">5</span></code> је исто што и
<code class="docutils literal notranslate"><span class="pre">12</span> <span class="pre">`mod`</span> <span class="pre">5</span></code>, представља остатак при дељењу броја 12
бројем 5 и вредност му је 2). Примећујете да се позиви функција пишу
без заграда (уместо <code class="docutils literal notranslate"><span class="pre">cifre(n)</span></code>, пишемо <code class="docutils literal notranslate"><span class="pre">cifre</span> <span class="pre">n</span></code>, уместо <code class="docutils literal notranslate"><span class="pre">mod(12,</span> <span class="pre">5)</span></code>,
пишемо <code class="docutils literal notranslate"><span class="pre">mod</span> <span class="pre">12</span> <span class="pre">5</span></code>).  Ово ће вас у почетку сигурно прилично
збуњивати, али када се навикнете, може вам се десити да увидите
предности оваквог записа и да се можда чак и запитате зашто
математичари не усвоје овакву нотацију. Више детаља о синтакси ћемо,
наравно, дати у наредним поглављима.</p>
</section>
<section id="id8">
<h3>Поклапање шаблона<a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h3>
<p>Приметимо да смо дефиниције обе функције (<code class="docutils literal notranslate"><span class="pre">cifre</span></code> и
<code class="docutils literal notranslate"><span class="pre">zbirNeparnihCifaraBroja</span></code>) дате помоћу математичких једнакости. Веза
функционалног програмирања и математике је веома дубока и о њој ћемо
интензивно причати у наставку курса. У првом случају је примењена
техника која се зове поклапање шаблона (енг. <em>pattern
matching</em>).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">cifre</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span>
<span class="nf">cifre</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="p">`</span><span class="n">mod</span><span class="p">`</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">cifre</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="p">`</span><span class="n">div</span><span class="p">`</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>Наиме, приликом израчунавања функције <code class="docutils literal notranslate"><span class="pre">cifre</span></code>, редом се проверавају
наведене једнакости и ако се аргумент може уклопити у шаблон дат првом
левом страном (у овом случају то је <code class="docutils literal notranslate"><span class="pre">cifre</span> <span class="pre">0</span></code>), примењиваће се та
дефиниција, а ако се не може уклопити, онда ће се прећи на другу (у
овом случају то је <code class="docutils literal notranslate"><span class="pre">cifre</span> <span class="pre">n</span></code>). Зато се друга једнакост односи само
на случај када је параметар различит од нуле, без потребе да се то
експлицитно нагласи. Уместо овога могли смо користити гранање (што би
више одговарало рекурзивној дефиницији у језику C#).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">cifre</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="p">`</span><span class="n">mod</span><span class="p">`</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">cifre</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="p">`</span><span class="n">div</span><span class="p">`</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>Оператор if-then-else прави условни израз и одговара оператору <code class="docutils literal notranslate"><span class="pre">?:</span></code>
у језику C# (а не наредби if-else). Сагласићете се да је решење са
уклапањем шаблона обично елегантније.</p>
</section>
<section id="id9">
<h3>Лењост<a class="headerlink" href="#id9" title="Permalink to this heading">¶</a></h3>
<p>У C# решењу истакли смо зашто нам је веома важно да функција не враћа
целу листу одједном, већ да резултат даје у облику лењог тока. Haskell
је језик који је по својој дефиницији лењ и код њега ће се управо
ствари одвијати онако како смо у језику C# моделовали помоћу
<code class="docutils literal notranslate"><span class="pre">IEnumerable</span></code> и <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">return</span></code>. Дакле, у језику Haskell не морамо
да бринемо да ће се компоновањем функција које раде над листама добити
неефикасан програми.</p>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>И у језику Haskell је могуће дефинисати бесконачне колекције.
Рекурзивна функција којом се израчунава Колацова секвенца (за коју
заправо не знамо да ли увек враћа коначну или некад враћа
бесконачну секвенцу) се може дефинисати на следећи начин.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">collatz</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span>
<span class="nf">collatz</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">collatz</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">`</span><span class="n">mod</span><span class="p">`</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span>
<span class="w">            </span><span class="kr">then</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">collatz</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="p">`</span><span class="n">div</span><span class="p">`</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">            </span><span class="kr">else</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">collatz</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Првих 10 елемената секвенце која почиње од броја 100 можемо добити
изразом <code class="docutils literal notranslate"><span class="pre">take</span> <span class="pre">10</span> <span class="pre">(collatz</span> <span class="pre">100)</span></code> (функцијом <code class="docutils literal notranslate"><span class="pre">take</span></code> се издвајају
почетни елементи листе).</p>

    </div></div>
</section>
<section id="sum-map-filter">
<h3>Функција sum, функционали map и filter и ламбда изрази<a class="headerlink" href="#sum-map-filter" title="Permalink to this heading">¶</a></h3>
<p>Размотримо сада израз помоћу којег је дефинисана функција
<code class="docutils literal notranslate"><span class="pre">zbirNeparnihCifaraBroja</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sum (map (\x -&gt; x * x) (filter (\ x -&gt; x `mod` 2 /= 0) (cifre n)))
</pre></div>
</div>
<p>У њему се користе библиотечке функције <code class="docutils literal notranslate"><span class="pre">sum</span></code>, <code class="docutils literal notranslate"><span class="pre">map</span></code> и <code class="docutils literal notranslate"><span class="pre">filter</span></code>.</p>
<ul class="simple">
<li><p>Функција <code class="docutils literal notranslate"><span class="pre">sum</span></code>, очекивано, израчунава збир елемената дате листе.</p></li>
<li><p>Функционал <code class="docutils literal notranslate"><span class="pre">map</span></code> одговара нашем <code class="docutils literal notranslate"><span class="pre">Preslikaj</span></code>, тј. Linq-овом
<code class="docutils literal notranslate"><span class="pre">Select</span></code>.</p></li>
<li><p>Функционал <code class="docutils literal notranslate"><span class="pre">filter</span></code> одговара нашем <code class="docutils literal notranslate"><span class="pre">Izdvoj</span></code>, тј. Linq-овом
<code class="docutils literal notranslate"><span class="pre">Where</span></code>.</p></li>
</ul>
<p>Анонимне функције се записују помоћу <strong>ламбда–израза</strong>, који веома
личе на оне у језику C#, једино што морају да почну карактером <code class="docutils literal notranslate"><span class="pre">\</span></code>
(који одговара грчком слову ламбда λ, додуше са једном поломљеном
ногом) и што се уместо <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> користи <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>.</p>
<ul class="simple">
<li><p>Функција квадрирања се означава ламбда-изразом <code class="docutils literal notranslate"><span class="pre">\</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">x</span></code>.</p></li>
<li><p>Функција која проверава да ли је број паран ламбда изразом
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">`mod`</span> <span class="pre">2</span> <span class="pre">/=</span> <span class="pre">0</span></code>.</p></li>
</ul>
<p>Дакле, у наведеном изразу, прво се коришћењем наше функције <code class="docutils literal notranslate"><span class="pre">cifre</span></code>
одређују цифре броја, затим се функцијом
<code class="docutils literal notranslate"><span class="pre">filter</span> <span class="pre">(x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">`mod`</span> <span class="pre">2</span> <span class="pre">/=</span> <span class="pre">0)</span></code> издвајају парне цифре,
затим се функцијом <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">(\x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">x)</span></code> оне квадрирају и на крају се
функцијом <code class="docutils literal notranslate"><span class="pre">sum</span></code> добијени квадрати сабирају.</p>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>Теорију иза ламбда–израза као механизма за опис израчунавања
дефинисао је Алонзо Черч још 1930-их година и она и данас
представља теоријску основу функционалних програмских језика.</p>

    </div></div>
</section>
<section id="id10">
<h3>Компрехенсија<a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h3>
<p>Пресликавање и филтрирање тј. функционали <code class="docutils literal notranslate"><span class="pre">map</span></code> и <code class="docutils literal notranslate"><span class="pre">filter</span></code> су
толико чести да су имплицитно присутни у математичкој
нотацији. Размотримо следеће решење истог задатка.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">zbirKvadrataNeparnihCifara</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">zbirKvadrataNeparnihCifara</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span>
<span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">cifre</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">`</span><span class="n">mod</span><span class="p">`</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Приметите колико се овде Haskell приближио традиционалној
математици. У овом решењу користили смо тзв. компрехенсију листа која
одговара скуповној компрехенсији из математике (довољно је замислити
да се уместо угластих користе витичасте заграде, а да се уместо
симбола <code class="docutils literal notranslate"><span class="pre">&lt;-</span></code> користи <code class="docutils literal notranslate"><span class="pre">∈</span></code>). Дакле,</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">f</span> <span class="pre">l</span></code> можемо обележити са <code class="docutils literal notranslate"><span class="pre">[f</span> <span class="pre">x</span> <span class="pre">|</span> <span class="pre">x</span> <span class="pre">&lt;-</span> <span class="pre">l]</span></code>, што одговара изразу <span class="math notranslate nohighlight">\(\{f(x)\,|\,x\in l\}\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">filter</span> <span class="pre">P</span> <span class="pre">l</span></code> можемо обележити са <code class="docutils literal notranslate"><span class="pre">[x</span> <span class="pre">|</span> <span class="pre">x</span> <span class="pre">&lt;-</span> <span class="pre">l,</span> <span class="pre">P</span> <span class="pre">x]</span></code>, што одговара изразу <span class="math notranslate nohighlight">\(\{x\,|\,x\in l\,\wedge\,P(x)\}\)</span>, док</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[f</span> <span class="pre">x</span> <span class="pre">|</span> <span class="pre">x</span> <span class="pre">&lt;-</span> <span class="pre">l,</span> <span class="pre">P</span> <span class="pre">x]</span></code> означава композицију функционала
<code class="docutils literal notranslate"><span class="pre">map</span></code> и <code class="docutils literal notranslate"><span class="pre">filter</span></code> тј. <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">f</span> <span class="pre">(filter</span> <span class="pre">P</span> <span class="pre">l)</span></code>, што одговара изразу <span class="math notranslate nohighlight">\(\{f(x)\,|\,x\in l\,\wedge\,P(x)\}\)</span>.</p></li>
</ul>
</section>
<section id="id11">
<h3>Композиција функција<a class="headerlink" href="#id11" title="Permalink to this heading">¶</a></h3>
<p>Често се наглашава да је функционално програмирање тесно повезано са
математиком. Урадимо сада још један корак карактеристичан у
функционалном стилу програмирања али и математици, који ће нам
омогућити да решење још мало лепше запишемо (са мање заграда и са
јасније наглашеним осноним алгоритмима чијом се применом добија крајње
решење). У самом старту смо кренули од тога да наш програм
декомпонујемо, тј. да његово решење добијемо као композицију мањих
елемената. Композионалност, тј. могућност добијања резултата
компоновањем функција лежи у сржи програмирања, и функционални језици
веома инсистирају на њој. Пошто су функције у језику Haskell чисте,
тј. немају бочне ефекте, оне одговарају математичким функцијама и могу
се компоновати на исти начин као што се компонују и функције у
математици.</p>
<p>Појам композиције две функције <span class="math notranslate nohighlight">\(f\)</span> и <span class="math notranslate nohighlight">\(g\)</span> је у математици
веома јасно и прецизно дефинисан. Ако је <span class="math notranslate nohighlight">\(g\)</span> функција која
пресликава <span class="math notranslate nohighlight">\(A\)</span> у <span class="math notranslate nohighlight">\(B\)</span>, и ако је <span class="math notranslate nohighlight">\(f\)</span> функција која
пресликава <span class="math notranslate nohighlight">\(B\)</span> у <span class="math notranslate nohighlight">\(C\)</span>, онда је <span class="math notranslate nohighlight">\(f\circ g\)</span> функција
која пресликава <span class="math notranslate nohighlight">\(A\)</span> у <span class="math notranslate nohighlight">\(C\)</span> и дефинисана је помоћу
<span class="math notranslate nohighlight">\((f\circ g)(x) = f(g(x))\)</span>. У математици је сасвим природно
дефинисати функцију помоћу <span class="math notranslate nohighlight">\(h=f\circ g\)</span>, без помињања вредности
у појединачним тачкама (за ово се каже да је <strong>нотација без тачака</strong>,
тј. point-free style).</p>
<a class="reference internal image-reference" href="../_images/kompozicija.png"><img alt="../_images/kompozicija.png" class="align-center" src="../_images/kompozicija.png" style="width: 400px;" /></a>
<p>Језик Haskell подржава директно оператор композиције функција (означен
је тачкицом <code class="docutils literal notranslate"><span class="pre">.</span></code>) и у њему је такође могуће користити нотацију без
тачака. Размотримо следећу дефиницију нашег текућег примера.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">zbirKvadrataNeparnihCifara</span><span class="w"> </span><span class="ow">=</span>
<span class="w">     </span><span class="n">sum</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">`</span><span class="n">mod</span><span class="p">`</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">cifre</span>
</pre></div>
</div>
<p>Функција <code class="docutils literal notranslate"><span class="pre">zbirKvadrataNeparnihCifara</span></code> је експлицитно дефинисана као
композиција 4 функције. У композицији се функције примењују здесна
налево.</p>
<ul class="simple">
<li><p>Прво се примењује функција цифре која пресликава тип (скуп
вредности) <code class="docutils literal notranslate"><span class="pre">Int</span></code> у тип <code class="docutils literal notranslate"><span class="pre">[Int]</span></code> тј. број пресликава у листу
његових цифара.</p></li>
<li><p>Затим се примењује функција <code class="docutils literal notranslate"><span class="pre">filter</span> <span class="pre">(x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">`mod`</span> <span class="pre">2</span> <span class="pre">/=</span>&#160; <span class="pre">0)</span></code>
која пресликава тип <code class="docutils literal notranslate"><span class="pre">[Int]</span></code> у тип <code class="docutils literal notranslate"><span class="pre">[Int]</span></code> тј. листу цифара
пресликава у листу њених непарних елемената.</p></li>
<li><p>Затим се примењује функција <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">(\x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">x)</span></code> која пресликава тип
<code class="docutils literal notranslate"><span class="pre">[Int]</span></code> у <code class="docutils literal notranslate"><span class="pre">[Int]</span></code> тј. која листу непарних цифара пресликава у листу
њихових квадрата.</p></li>
<li><p>На крају се примењује функција <code class="docutils literal notranslate"><span class="pre">sum</span></code> која пресликава тип <code class="docutils literal notranslate"><span class="pre">[Int]</span></code>
у тип <code class="docutils literal notranslate"><span class="pre">Int</span></code> тј. која листу квадрата непарних цифара пресликава у
њихов збир.</p></li>
</ul>
</section>
<section id="id12">
<h3>Каријеве функције<a class="headerlink" href="#id12" title="Permalink to this heading">¶</a></h3>
<p>Нашу функцију смо сада експлицитно изразили као композицију четири
функције. Прва здесна је функција <code class="docutils literal notranslate"><span class="pre">cifre</span></code> која узима број и враћа
листу његових цифара и њен тип је <code class="docutils literal notranslate"><span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">[Int]</span></code>. Међутим, код
друге, <code class="docutils literal notranslate"><span class="pre">filter</span> <span class="pre">(x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">`mod`</span> <span class="pre">2</span> <span class="pre">/=</span> <span class="pre">0)</span></code> треба мало да
застанемо и да се замислимо. Она филтрира задату листу тако што из ње
издваја све непарне елементе. Она дакле, прима листу бројева и враћа
листу бројева и тип јој је <code class="docutils literal notranslate"><span class="pre">[Int]</span> <span class="pre">-&gt;</span> <span class="pre">[Int]</span></code>.</p>
<p>Каква је веза ове конкретне функције филтрирања са библиотечком
функцијом <code class="docutils literal notranslate"><span class="pre">filter</span></code>? Јасно је да је она настала тако што је функција
<code class="docutils literal notranslate"><span class="pre">filter</span></code> конкретизована, фиксирањем њеног првог аргумента. Функција
<code class="docutils literal notranslate"><span class="pre">filter</span></code> је функција којој можемо да задамо два аргумента (услов
провере и листу) и тако добијемо листу оних елемената задате листе
који задовољавају задати услов провере. Гледано математички, то би
била функција две променљиве, која прима уређени пар аргумената и
враћа резултат. Међутим, у језику Haskell ствари стоје
другачије. Приметимо да синтакса језика уместо очекиваног позива
облика <code class="docutils literal notranslate"><span class="pre">filter(uslov,</span> <span class="pre">lista)</span></code> захтева навођење израза облика
<code class="docutils literal notranslate"><span class="pre">filter</span> <span class="pre">uslov</span> <span class="pre">lista</span></code>. На пример, вредност израза</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">filter</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">`</span><span class="n">mod</span><span class="p">`</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span>
</pre></div>
</div>
<p>је листа <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">3,</span> <span class="pre">5]</span></code>.</p>
<p>У изразу <code class="docutils literal notranslate"><span class="pre">filter</span> <span class="pre">(x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">`mod`</span> <span class="pre">2</span> <span class="pre">/=</span> <span class="pre">0)</span></code> смо функцији
<code class="docutils literal notranslate"><span class="pre">filter</span></code> задали само један аргумент (услов провере). На тај начин смо
добили функцију једне променљиве: функцију која прима листу и враћа
листу њених непарних елемената. Функцију <code class="docutils literal notranslate"><span class="pre">filter</span></code> је, дакле, могуће
<strong>парцијално применити</strong> задајући јој само први, уместо оба аргумента.
Оваква парцијална примена функција открива да у Haskell-у заправо не
постоје функције више аргумената, већ су оне представљене као функције
које пресликавају свој први аргумент у неку конкретнију функцију. Тип
функције <code class="docutils literal notranslate"><span class="pre">filter</span></code> је:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">filter</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">bool</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
<p>Овај тип се чита здесна налево:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">filter</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">bool</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">([</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
</pre></div>
</div>
<p>То значи да је (једини) аргумент функције <code class="docutils literal notranslate"><span class="pre">filter</span></code> функција типа
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></code> (тј. услов који је моделован функцијом која пресликава
елементе неког типа <code class="docutils literal notranslate"><span class="pre">a</span></code> у тип <code class="docutils literal notranslate"><span class="pre">bool</span></code>), а повратна вредност јој је
функција типа <code class="docutils literal notranslate"><span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span></code> тј. функција која прима листу елемената
типа <code class="docutils literal notranslate"><span class="pre">a</span></code> и враћа нову листу елемената типа <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>У изразу <code class="docutils literal notranslate"><span class="pre">filter</span> <span class="pre">(x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">`mod`</span> <span class="pre">2</span> <span class="pre">/=</span> <span class="pre">0)</span></code> функција
<code class="docutils literal notranslate"><span class="pre">filter</span></code> је примењена на аргумент <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">`mod`</span> <span class="pre">2</span> <span class="pre">/=</span> <span class="pre">0)</span></code>,
чиме је добијена конкретна функција која слика листу у листу
издвајајући јој непарне цифре. То нам је добро дошло у претходном
примеру, јер смо такву функцију могли укључити у ланац композиције.</p>
<p>Када се функција <code class="docutils literal notranslate"><span class="pre">filter</span></code> примењује на два аргумента, примена се
врши слева надесно.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nf">\</span><span class="p">`</span><span class="n">mod</span><span class="nf">\</span><span class="p">`</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span>
</pre></div>
</div>
<p>Дакле, прво се примењује функција <code class="docutils literal notranslate"><span class="pre">filter</span></code> типа
<code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">bool)</span> <span class="pre">-&gt;</span> <span class="pre">([a]</span> <span class="pre">-&gt;</span> <span class="pre">[a])</span></code> на аргумент
<code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">`mod`</span> <span class="pre">2</span> <span class="pre">/=</span> <span class="pre">0)</span></code> типа <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></code>, добија се конкретна
функција филтрирања типа <code class="docutils literal notranslate"><span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span></code>, а онда се она примењује на
конкретну листу типа <code class="docutils literal notranslate"><span class="pre">[a]</span></code>, дајући конкретну листу типа <code class="docutils literal notranslate"><span class="pre">[a]</span></code> као резултат.</p>
<p>Овај начин предствљања функција више променљивих (као функције једне
променљиве које враћају функције) назива се <strong>Каријевање</strong>
(енг. currying) у част чувеног логичара Хаскела Карија (уосталом, и
језик Haskell носи његово име).</p>
</section>
</section>
<section id="id13">
<h2>Предности функционалне парадигме<a class="headerlink" href="#id13" title="Permalink to this heading">¶</a></h2>
<section id="id14">
<h3>Везе са математиком и формална верификација<a class="headerlink" href="#id14" title="Permalink to this heading">¶</a></h3>
<p>Видели смо да се у програмима у императивним програмским језицима
вредности променљивих мењају током извршавања програма. Зато је кључни
појам за анализу програма стање, које је одређено тренутним
вредностима променљивих. Извршавање функција зависи од стања и може да
промени стање (функције могу да имају бочне ефекте). Зато функција
позвана са истим аргументима у различитим тренуцима током извршавања
програма може да врати различит резултат. Ово условљава да је редослед
израчунавања вредности функција веома битан током извршавања програма
и не може се тек тако мењати (што, на пример, отежава могућност
паралелизације програма, и такође чини да резоновање о функцијама није
могуће вршити независно од контекста у којем се оне позивају). Анализа
коректности програма написаних у императивним програмским језицима је
компликована и захтева посеван математички апарат.</p>
<p>Променљиве у функционалним језицима не мењају своју вредност током
извршавања програма, што их чини веома блиским математичком појму
променљивих. Пошто, се не користе променљиве којима се мења вредност
током извршавања програма, израчунавање вредности израза не зависи од
стања програма. Са друге стране, није могуће коришћење петљи, што
функционалне програмске језике чини доста другачијим од импеартивних,
у којима су петље основни механизам изражавања алгоритама (уместо
петљи, користи се рекурзивно дефинисање функција, које опет има јасну
математичку основу).</p>
<p>Функције које се разматрају у чистом функционалном програмирању у
потпуности одговарају математичким функцијама (увек за исте улазе дају
исте излазе – каже се да су <strong>чисте</strong>, <strong>референцијално транспаренте</strong>
и да немају бочне ефекте). О оваквим се функцијама може формално
резоновати применом класичних математичких техника, што је веома
значајно у анализи кода и доказивању његове коректности.</p>
<p>Све наведено пружа могућност да се изврши <strong>верификација</strong> чистих
функција и функционалних програма, тј.  да се њихова коректност докаже
применом уобичајених математичких метода (пре свега математичке
индукције и једнакосног резоновања). Размотримо пример рекурзивне
функције која израчунава степен датог броја.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">stepen</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">stepen</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">stepen</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Овај програм у потпуности одговара математичкој дефиницији:</p>
<div class="math notranslate nohighlight">
\[\begin{split}x^n  = \begin{cases}
     1 &amp; \text{за } n = 0 \\
     x \cdot x^{n-1} &amp; \text{за } n &gt; 0
     \end{cases}\end{split}\]</div>
<p>Коректност рекурзивно дефинисаних функција се по правилу доказује
математичком индукцијом.</p>
<ul class="simple">
<li><p>Као базу индукције, потребно је доказати да функција израчунава
коректан резултат када год врати резултат без вршења рекурзивног
позива тј. доказати да су излази из рекурзије коректни.</p></li>
<li><p>Као индуктивна хипотеза претпоставља се да сваки рекурзивни позив
враћа исправан резултат. Индуктивни корак онда захтева да се, под
претпоставком да таква индуктивна хипотеза важи, докаже да функција
враћа исправан резултата и у случајевима када су вршени рекурзивни
позиви.</p></li>
</ul>
<p>Покажимо ово на примеру функције <code class="docutils literal notranslate"><span class="pre">stepen</span></code>. Докажимо да функција за
сваки природан број <span class="math notranslate nohighlight">\(n\)</span> (укључујући и нулу) и сваки реалан број
<span class="math notranslate nohighlight">\(x\)</span> различит од нуле, исправно израчунава степен <span class="math notranslate nohighlight">\(x^n\)</span>.</p>
<ul class="simple">
<li><p>Базу чини случај <span class="math notranslate nohighlight">\(n=0\)</span>, јер се тада врши излаз из рекурзије и
враћа се вредност 1. Тај резултат је коректан јер знамо да је
<span class="math notranslate nohighlight">\(x^0=1\)</span>.</p></li>
<li><p>Када је <span class="math notranslate nohighlight">\(n &gt; 0\)</span>, рекурзивни позив који се врши је <code class="docutils literal notranslate"><span class="pre">stepen</span> <span class="pre">x</span> <span class="pre">(n-1)</span></code>
и као индуктивну хипотезу претпостављамо да он враћа исправну
вредност <span class="math notranslate nohighlight">\(x^{n-1}\)</span> (приметимо да из <span class="math notranslate nohighlight">\(n &gt; 0\)</span> следи
<span class="math notranslate nohighlight">\(n - 1 \geq 0\)</span>, па је рекурзивни позив извршен над вредностима
које су у домену ове функције). На основу дефиниције видимо да је
резултат функције у том случају вредност <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">stepen</span> <span class="pre">x</span> <span class="pre">(n</span> <span class="pre">-</span> <span class="pre">1)</span></code>.
На основу индуктивне хипотезе знамо да је ово вредност
<span class="math notranslate nohighlight">\(x \cdot x^{n-1} = x^n\)</span>. Дакле, позив <code class="docutils literal notranslate"><span class="pre">stepen</span> <span class="pre">x</span> <span class="pre">n</span></code> враћа
вредност <span class="math notranslate nohighlight">\(x^n\)</span> и функција <code class="docutils literal notranslate"><span class="pre">stepen</span></code> је коректно дефинисана.</p></li>
</ul>
<p>Нагласимо и да функционални језици какав је Haskell обично директно
подржавају типове података за представљање неограничено великих
бројева, па не постоји опасност од прекорачења, што је један од веома
честих извора грешака у императивним и објектно-оријентисаним
програмима. То може учинити рачунање мало споријим (мада и не мора,
ако су вредности са којима се рачуна мале), али чини програме мање
подложним грешкама, што је често важније.</p>
<p>Захваљујући томе што функције одговарају математичким функцијама, о
њима можемо резоновати коришћењем једнакости и алгебарских закона.  На
пример, видели смо да функција <code class="docutils literal notranslate"><span class="pre">map</span></code> врши пресликавање серије
елемената применом дате функције. Пошто та функција нема споредних
ефеката, важи следећи алгебарски закон:</p>
<div class="math notranslate nohighlight">
\[\mathrm{map}\ f\ (\mathrm{map}\ g\ xs) = \mathrm{map}\ (f \circ g)\ xs\]</div>
<p>Наиме, ако све елементе серије пресликамо неком функцијом <span class="math notranslate nohighlight">\(g\)</span>,
па затим тако добијену серију пресликамо функцијом <span class="math notranslate nohighlight">\(f\)</span>, добијамо
исти ефекат као да смо полазну серију пресликали композицијом функција
<span class="math notranslate nohighlight">\(f \circ g\)</span>. Компилатор може, на пример, да употреби претходни
алгебарски закон да оптимизује програм тако што ће уместо два
узастопна пресликавања вршити само једно. Обратите пажњу на то да,
када функције <span class="math notranslate nohighlight">\(f\)</span> и <span class="math notranslate nohighlight">\(g\)</span> не би биле чисте, тј. када би
имале бочне ефекте, овај закон не би морао да важи (покушајте да
нађете пример који то илуструје).</p>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>Када би се докази коректности писали на папиру, постојала би
опасност да они садрже грешке. Стога се верификација врши помоћу
специјалних софтверских алатки. <strong>Аутоматски доказивачи теорема</strong>
покушавају да докажу коректност софтвера тако што потпуно
самостално проналазе доказе теорема које говоре о коректности тог
софтвера. Они често не могу да докажу целокупну коректност, али
могу да докажу одсуство неких честих типова грешака (на пример, да
се не врши целобројно дељење нулом, да се <code class="docutils literal notranslate"><span class="pre">null</span></code> показивачи не
дереференцирају, да се не приступа елементима низа ван његових
граница и слично). <strong>Интерактивни доказивачи теорема</strong> проверавају
доказе које корисници записују (на специјализованим језицима),
користећи аутоматске доказиваче да самостално обраде једноставније
делове доказа. Интерактивни доказивачи теорема често користе
функционалне програмске језике.</p>
<p>Постоје значајни примери веома комплексног софтвера који је
делимично или потпуно формално верификован. Поменимо неке
најзначајније.</p>
<ul class="simple">
<li><p>CompCert је компилатор за програмски језик C који је
имплементиран у функционалном језику интерактивног доказивача
Coq.</p></li>
<li><p>SEL4 је оперативни систем који је верификован у интерактивном
доказивачу теорема Isabelle/HOL. Прво је верификована његова
функционална имплементација у језику Haskell, а затим и
имплементација у програмском језику C (што је захтевало много
компликованије методе јер C није функционални језик).</p></li>
<li><p>Систем Event-B је употребљен за формалну верификацију линије 11
париском метроа, којом уместо људских возача управља софтвер.</p></li>
</ul>

    </div></div>
</section>
<section id="id15">
<h3>Декларативност<a class="headerlink" href="#id15" title="Permalink to this heading">¶</a></h3>
<p>На крају, када упоредимо ово решење са оним полазним, можемо приметити
да смо након дивергенције у програм са много више линија кода заправо
дошли до програма који је много краћи, али и разумљивији од полазног
C# решења (ако вам се тако не чини, верујте да је то само зато што сте
на императивни начин размишљања навикли и да ћете током овог
полугодишта, променити мишљење).  Нагласимо још једну важну особину
овог решења. Приметимо блискост овог решења са самим текстом задатка
(ако читамо редом, примећујемо речи „сума“, „квадрата“, „непарних“,
„цифара броја“ и свака од тих речи редом одговара једној од наших
функција у ланцу композиције). У нашем програму нисмо морали да
објашњавамо ни како се сумира, ни како се издвајају цифре, ни како се
пресликавају – захваљујући својој богатој библиотеци, језик је то сам
урадио уместо нас. Дакле, програм је био много ближи опису самог
проблема, него опису решења, док се полазно C# решење морало много
приближити самом поступку израчунавања, тј. директном опису сваког
корака у решавању овог проблема. Зато се за функционалне језике често
каже да су много више декларативни него императивни (много више
описујемо сам проблем, него процедуру његовог решавања). Наравно, то
не ради увек (код одређивања цифара у запису броја рекурзивним
дефиницијама смо директно описали процедуру и тај аспект овог програма
није декларативан, већ процедуралан).</p>
</section>
<section id="id16">
<h3>Паралелизација<a class="headerlink" href="#id16" title="Permalink to this heading">¶</a></h3>
<p>На крају, рецимо и да изражавање програма у функционалном облику често
може да допринесе паралелизацији. На пример и filter и map су такве
функције да анализирају независно један по један елемент листе и веома
једноставно се могу паралелизовати (нпр. један процесор обрађује први
део дугачке листе, а други процесор други део). Захваљујући овоме,
функционални стил програмирања је веома популаран у оквиру развоја
паралелних и дистрибуираних система.</p>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>Један од веома важних разлога за рани успех компаније <em>Google</em> је
систем за паралелно и дистрибуирано израчунавање назван
<strong>Map/Reduce</strong>, који је инспирисан функционалним програмирањем.</p>
<p>Замислимо програм који треба да преброји појављивања неке кључне
речи у огромном броју докумената (на пример, на веб-странама
преузетим са целог веба). Јасно је да би то превише дуго трајало
ако би се извршавало секвенцијално. Зато се тај посао паралелизује,
тако што сваки процес добија одређени број веб-страна које треба да
обради.</p>
<p>Прва идеја би могла да буде да сваки рачунар када наиђе на
појављивање тражене речи увећа неки бројач појављивања који се
налази у некој заједничкој, дељеној меморији. Међутим, такав
приступ је проблематичан, јер је потребно обезбедити неки механизам
закључавања који ће спречити да дође до грешке. Наиме увећање
променљиве није атомичка операција и подразумева да се стара
вредност прво прочита из меморије, па да се затим упише увећана
вредност. Ако би између читања и уписа нове вредности променљиве
неки други процес прочитао вредност променљиве, десило би се да се
једно увећавање прескочи. Учили сте из оперативних система да се
обезбеђивање таквих критчних секција врши закључавањем, али то
решење је компликовано и неефикасно.</p>
<p>Много боља идеја је да се уместо коришћења дељене променљиве посао
издели тако што ће сваки процес независно да преброји појављивања
речи у својим документима, а онда ће се у другој фази сви добијени
бројеви сабрати. Прво се, дакле, сваки скуп веб-страница пресликава
(<em>мапира</em>) у број појављивања речи у том скупу, а затим се ти
бројеви сабирају (<em>редукују</em>). Овај општи механизам се примењује за
паралелизацију различитих задатака, при чему се они извршавају
дистрибуирано, на великим кластерима. У првој фази се увек скуп веб
страна мапира тако што се из њих извлаче неки помоћни подаци, који
се затим у другој фази редукују да би се добио коначни резултат.
Мапирање одговара функцији <cite>map</cite> коју смо већ срели, док се
редукција врши функцијом која се у функционалним језицима назива
често <cite>fold</cite> или <cite>reduce</cite> (видећемо да је сумирање типичан пример
редукције и да се може лако реализовати функцијом <cite>fold</cite>).</p>
<p>Нагласимо још једном да пресликавање које се врши у првој фази мора
да буде чисто, тј. без бочних ефеката. Заиста, како бисмо могли да
верујемо у резултат претраге ако на хиљаде рачунара мапирамо упит
који није имплементиран као чиста функција и како би могло да се
гарантује да бочни ефекти нису нешто побрљали у резултату функције?</p>

    </div></div>
</section>
</section>
<section id="id17">
<h2>Задаци за самостални рад<a class="headerlink" href="#id17" title="Permalink to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p>Потражити на интернету податке о првом масивно паралелном рачунару
који се звао <em>Connection Machine</em> (настао средином
1980их). Истражите зашто су се аутори одличили за LISP као језик у
коме се тај рачунар програмирао? Потражите на Интернету Фејнманов
алгоритам за рачунање логаритма на Connection Machine (Ричард
Фејнман је чувени физичар, добитник Нобелове награде)?</p></li>
<li><p>Потражите на интернету информације о програмском језику Verse. Када
је настао и чему је намењен? Ко је наручио овај језик? Ко је творац
овог овог језика и које језике је он још конструисао?</p></li>
<li><p>Потражите на интернету информације о програмском језику Scala.
Којој парадигми он припада? У каквој је вези овај језик са
програмским језиком Java?</p></li>
</ol>
</section>
</section>


    </div>
    
    <div>
<div class="lecture-prev-next-toggle">
  <a  href="index.html" id="prevLectureLink" class="lecture-toggler-arrows"><i class="fas fa-arrow-left fa"></i> <span> Претходна лекција </span> </a>
  
  <a id="nextLectureLink" class="lecture-toggler-arrows"><span> Следећа лекција</span>  <i class="fas fa-arrow-right fa"></i> </a>
</div>

<script type="text/javascript">
  $('#relations-prev').tooltip({'placement':'right', 'selector': '', 'delay': { show: 100, hide: 50}});
  $('#relations-next').tooltip({'placement':'left', 'selector': '', 'delay': { show: 100, hide: 50}});
</script>
</div>

    
  </div>
</div>

<div class="petljadoc-resources">
  <span class="pull-left">(Created using  <a href="https://pypi.org/project/Sphinx/">Swinx</a>, <a href="http://runestoneinteractive.org/">RunestoneComponents</a> and <a href="https://github.com/Petlja/PetljaDoc">PetljaDoc</a>) <br> © 2022 Petlja</span>
</div>


<div class="lectureToolbox">

  <label class="font-size-toggle" id="fontSizeToggle">

      <i class="fas fa-font"></i><label>Слова</label>
  </label>
  <div class="font-change d-none" id="fontChangeModal">
      <span class="dec-letter-icon" id="decLetterIcon">A-</span>
      <label id="currentFontSize">16</label>
      <span class="inc-letter-icon" id="incLetterIcon">A+</span>
  </div>
</div>

</div>

  </body>
</html>