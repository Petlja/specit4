<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Исказна логика</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/activecode.css" />
    <link rel="stylesheet" type="text/css" href="../_static/codemirror.css" />
    <link rel="stylesheet" type="text/css" href="../_static/qchoice.css" />
    <link rel="stylesheet" type="text/css" href="../_static/clickable.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pytutor.css" />
    <link rel="stylesheet" type="text/css" href="../_static/modal-basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/datafile.css" />
    <link rel="stylesheet" type="text/css" href="../_static/dragndrop.css" />
    <link rel="stylesheet" type="text/css" href="../_static/fitb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/matrixeq.css" />
    <link rel="stylesheet" type="text/css" href="../_static/parsons.css" />
    <link rel="stylesheet" type="text/css" href="../_static/lib/prettify.css" />
    <link rel="stylesheet" type="text/css" href="../_static/poll.css" />
    <link rel="stylesheet" type="text/css" href="../_static/showEval.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tabbedstuff.css" />
    <link rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/video.css" />
    <link rel="stylesheet" type="text/css" href="../_static/webgldemo.css" />
    <link rel="stylesheet" type="text/css" href="../_static/webglinteractive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/karel.css" />
    <link rel="stylesheet" type="text/css" href="../_static/notes.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/associations.css" />
    <link rel="stylesheet" type="text/css" href="../_static/editor.css" />
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/user-highlights.css" type="text/css" />
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.1/css/all.css" type="text/css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-4.0.0-dist/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/flatly.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/petlja-course.css" type="text/css" />
    <link rel="stylesheet" href="../_static/nbstyle.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/runestonebase.js"></script>
    <script src="../_static/skulpt.min.js"></script>
    <script src="../_static/skulpt-stdlib.js"></script>
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/jquery.highlight.js"></script>
    <script src="../_static/bookfuncs.js"></script>
    <script src="../_static/codemirror.js"></script>
    <script src="../_static/xml.js"></script>
    <script src="../_static/css.js"></script>
    <script src="../_static/python.js"></script>
    <script src="../_static/htmlmixed.js"></script>
    <script src="../_static/javascript.js"></script>
    <script src="../_static/jquery_i18n/CLDRPluralRuleParser.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.messagestore.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.fallbacks.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.language.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.parser.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.emitter.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.emitter.bidi.js"></script>
    <script src="../_static/activecode-i18n.en.js"></script>
    <script src="../_static/activecode-i18n.sr-Cyrl.js"></script>
    <script src="../_static/activecode.js"></script>
    <script src="../_static/clike.js"></script>
    <script src="../_static/timed_activecode.js"></script>
    <script src="../_static/animationbase.js"></script>
    <script src="../_static/mchoice.js"></script>
    <script src="../_static/timedmc.js"></script>
    <script src="../_static/timed.js"></script>
    <script src="../_static/mchoice-i18n.en.js"></script>
    <script src="../_static/mchoice-i18n.sr-Cyrl.js"></script>
    <script src="../_static/clickable.js"></script>
    <script src="../_static/timedclickable.js"></script>
    <script src="../_static/d3.v2.min.js"></script>
    <script src="../_static/jquery.ba-bbq.min.js"></script>
    <script src="../_static/jquery.jsPlumb-1.3.10-all-min.js"></script>
    <script src="../_static/pytutor.js"></script>
    <script src="../_static/codelens.js"></script>
    <script src="../_static/skulpt.min.js"></script>
    <script src="../_static/skulpt-stdlib.js"></script>
    <script src="../_static/datafile.js"></script>
    <script src="../_static/dragndrop.js"></script>
    <script src="../_static/timeddnd.js"></script>
    <script src="../_static/dragndrop-i18n.en.js"></script>
    <script src="../_static/dragndrop-i18n.sr-Cyrl.js"></script>
    <script src="../_static/fitb.js"></script>
    <script src="../_static/timedfitb.js"></script>
    <script src="../_static/fitb-i18n.en.js"></script>
    <script src="../_static/fitb-i18n.sr-Cyrl.js"></script>
    <script src="../_static/matrixeq.js"></script>
    <script src="../_static/lib/prettify.js"></script>
    <script src="../_static/lib/hammer.min.js"></script>
    <script src="../_static/parsons.js"></script>
    <script src="../_static/parsons-i18n.en.js"></script>
    <script src="../_static/parsons-i18n.sr-Cyrl.js"></script>
    <script src="../_static/timedparsons.js"></script>
    <script src="../_static/poll.js"></script>
    <script src="../_static/reveal.js"></script>
    <script src="../_static/shortanswer.js"></script>
    <script src="../_static/timed_shortanswer.js"></script>
    <script src="../_static/showEval.js"></script>
    <script src="../_static/tabbedstuff.js"></script>
    <script src="../_static/runestonevideo.js"></script>
    <script src="../_static/webglinteractive.js"></script>
    <script src="../_static/FileSaver.min.js"></script>
    <script src="../_static/Blob.js"></script>
    <script src="../_static/karelCorner.js"></script>
    <script src="../_static/karelRobot.js"></script>
    <script src="../_static/karelWorld.js"></script>
    <script src="../_static/karelChat.js"></script>
    <script src="../_static/karelRobotDrawer.js"></script>
    <script src="../_static/karelUI.js"></script>
    <script src="../_static/karel.js"></script>
    <script src="../_static/karel-i18n.en.js"></script>
    <script src="../_static/karel-i18n.sr-Cyrl.js"></script>
    <script src="../_static/notes.js"></script>
    <script src="../_static/pygamelib-init.js"></script>
    <script src="../_static/gallery.js"></script>
    <script src="../_static/associations.js"></script>
    <script src="../_static/associations-i18n.en.js"></script>
    <script src="../_static/associations-i18n.sr-Cyrl.js"></script>
    <script src="../_static/editor.js"></script>
    <script src="../_static/jszip.js"></script>
    <script src="../_static/editor-i18n.en.js"></script>
    <script src="../_static/editor-i18n.sr-Cyrl.js"></script>
    <script src="../_static/translations.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/jquery-ui-1.10.3.custom.min.js"></script>
    <script src="../_static/jquery-fix.js"></script>
    <script src="../_static/bootstrap-4.0.0-dist/js/bootstrap.min.js"></script>
    <script src="../_static/bootstrap-4.0.0-dist/js/bootstrap.bundle.min.js"></script>
    <script src="../_static/bootstrap-sphinx.js"></script>
    <script src="../_static/waypoints.min.js"></script>
    <script src="../_static/rangy-core.js"></script>
    <script src="../_static/rangy-textrange.js"></script>
    <script src="../_static/rangy-cssclassapplier.js"></script>
    <script src="../_static/user-highlights.js"></script>
    <script src="../_static/jquery.idle-timer.js"></script>
    <script src="../_static/processing-1.4.1.min.js"></script>
    <script src="../_static/jquery.hotkey.js"></script>
    <script src="../_static/jquery-migrate-1.2.1.min.js"></script>
    <script src="../_static/course-errors.js"></script>
    <script src="../_static/petlja.js"></script>
    <script src="../_static/require.js"></script>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
    <meta content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' name='viewport' />
    <link rel="shortcut icon" href="../_static/favicon.ico" type="image/ico" />
    <script type="text/javascript">
      eBookConfig = {};
      eBookConfig.host = 'http://127.0.0.1:8000' ? 'http://127.0.0.1:8000' : 'http://127.0.0.1:8000';
      eBookConfig.app = eBookConfig.host + '/runestone';
      eBookConfig.ajaxURL = eBookConfig.app + '/ajax/';
      eBookConfig.course = 'paradigme';
      eBookConfig.logLevel = '0';
      eBookConfig.loginRequired = 'false';
      eBookConfig.build_info = "";
      eBookConfig.isLoggedIn = false;
      eBookConfig.useRunestoneServices = false;
      eBookConfig.python3 = true;
      eBookConfig.basecourse = 'paradigme';
      eBookConfig.runestone_version = '';
      eBookConfig.imagesDir = '../_images/';
      eBookConfig.staticDir = '../_static/';
      if (typeof (Sk) != "undefined")
        Sk.imgPath = eBookConfig.imagesDir;
    </script>

  </head>

  <body>



<div id="navbar" class="content-header">
  <div class="right-side-nav">
    
    <div id="usefulLinksToggle" class="useful-links-toggle">
        <a class="dropdown-toggle dropdown-toggle-burger" role="button" href="#" id="usefulLinksDropdown" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-bars fa-2x"></i>
        </a>
        <div class="dropdown-menu dropdown-nav-links shadow-lg" aria-labelledby="usefulLinksDropdown" x-placement="bottom-start" style="position: absolute; transform: translate3d(-55px, 32px, 0px); top: 0px; left: 0px; will-change: transform;">
          <div class="links-title"> Корисни линкови</div>
          <div class="useful-link">
            <a href="https://www.sphinx-doc.org/en/master/usage/restructuredtext/index.html" target="_blank">Sphinx Docs</a></div>
          <div class="useful-link">
            <a href="https://github.com/Petlja/PetljaDoc/blob/master/README.md" target="_blank">Petljadoc</a></div>
          <div class="useful-link">
            <a href="https://github.com/RunestoneInteractive/overview" target="_blank">Runestone Interactive</a></div>
          
        </div>
    </div>

    
</div>

<div class="left-side-nav">
  <div class="course-logo-nav">
      <a target="_blank" href="https://petlja.org">
          <img src="../_static/img/petlja-logo-wt.svg" alt="petlja.org" id="lightPetljaLogo">
      </a>
  </div>
  <div class="course-logo-nav-kabinet">
      <a target="_blank" href="https://petlja.org/net.kabinet">
          <img src="../_static/img/netkabinet-logo-strelica-wt.svg" alt="petlja.org" id="lightNetKabinetLogo">
      </a>
  </div>
</div>


<div class="content-header-label" id = "content-header-label" href="../">Shrot description</div>

</div>




<div class="petljaCourseContainer">

<div class="petljaCourseContent">
  
           <div class="tableOfContent">
            <h5> Садржај </h5>
            </div>
           <div>
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-01%20paradigme>
                    <h5>О програмским парадигмама</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../01%20paradigme/01_o_paradigmama.html><div class="studioLecture" id=activity-01_o_paradigmama><i class="fas fa-file-alt activity-icon"></i>О програмским језицима и парадигмама</div></a>
                <a href=../01%20paradigme/02_imperativna.html><div class="studioLecture" id=activity-02_imperativna><i class="fas fa-file-alt activity-icon"></i>Императивна парадигма</div></a>
                </div>
            </div>
                
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-02%20funkcionalna>
                    <h5>Функционална парадигма</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../02%20funkcionalna/01_funkcionalna.html><div class="studioLecture" id=activity-01_funkcionalna><i class="fas fa-file-alt activity-icon"></i>О функционалној парадигми</div></a>
                <a href=../02%20funkcionalna/02_haskell.html><div class="studioLecture" id=activity-02_haskell><i class="fas fa-file-alt activity-icon"></i>Haskell - изрази и функције</div></a>
                <a href=../02%20funkcionalna/02b_haskell_liste.html><div class="studioLecture" id=activity-02b_haskell_liste><i class="fas fa-file-alt activity-icon"></i>Haskell - листе</div></a>
                <a href=../02%20funkcionalna/02c_haskell_tipovi.html><div class="studioLecture" id=activity-02c_haskell_tipovi><i class="fas fa-file-alt activity-icon"></i>Haskell - алгебарски типови података</div></a>
                <a href=../02%20funkcionalna/02z_haskell_vezba.html><div class="studioLecture" id=activity-02z_haskell_vezba><i class="fas fa-file-alt activity-icon"></i>Haskell - задаци за вежбу</div></a>
                </div>
            </div>
                
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-03%20logicka>
                    <h5>Логичка парадигма</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../03%20logicka/01_logicka.html><div class="studioLecture" id=activity-01_logicka><i class="fas fa-file-alt activity-icon"></i>О логичкој парадигми</div></a>
                <a href=../03%20logicka/01_iskazna_logika.html><div class="studioLecture" id=activity-01_iskazna_logika><i class="fas fa-file-alt activity-icon"></i>Исказна логика</div></a>
                <a href=../03%20logicka/02_predikatska_logika.html><div class="studioLecture" id=activity-02_predikatska_logika><i class="fas fa-file-alt activity-icon"></i>Предикатска логика</div></a>
                <a href=../03%20logicka/03_prolog.html><div class="studioLecture" id=activity-03_prolog><i class="fas fa-file-alt activity-icon"></i>PROLOG</div></a>
                </div>
            </div>
                </div>
</div>



<div class="lectureContent">

  <div id="errors">
  </div>
  
  <div class="lectureContentMaterial">
  
    <div id="main-content">
    
  <div class="section" id="id1">
<h1>Исказна логика<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h1>
<p>Основни појам логике је <strong>исказ</strong>. То је тврдња која може бити тачна
или нетачна. На пример, <em>„Београд је главни град Републике Србије”</em> је
тачан исказ, а <em>„7 је паран број”</em> је нетачан исказ.</p>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>У реалности постоје и тврдње које могу бити истините у некој мери,
попут исказа <em>„напољу је данас топло”</em> који зависи од субјективног
осећања, контекста (доба године) и слично. Ми се нећемо бавити
таквом оценом већ ћемо разматрати само класичну логику у којој је
сваки исказ или потпуно тачан или потпуно нетачан.</p>

    </div></div>
<p>Сложене исказе добијамо тако што једноставне исказе повезујемо
логичким везницима.</p>
<p>На пример, исказ <em>„број 6 није прост”</em> је <strong>негација</strong> (<strong>логичко
не</strong>) исказа <em>„број 6 је прост”</em>. Пошто је други исказ нетачан, први
исказ (негација) је тачан. Негацију исказа <span class="math notranslate nohighlight">\(p\)</span> означавамо са
<span class="math notranslate nohighlight">\(\neg p\)</span> и њена истинитосна вредност је супротна од истинитосне
вредности полазног исказа.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{|c||c|}
\hline
p &amp; \neg p \\
\hline
0 &amp; 1 \\
1 &amp; 0 \\
\hline
\end{array}\end{split}\]</div>
<p>Исказ <em>„7 је непаран прост број”</em> у себи крије <strong>конјункцију</strong>
(<strong>логичко „и”</strong>) исказа „7 је непаран број” и „7 је прост број”. Сва
ова три исказа су тачна. Конјункција исказа је тачна ако и само ако су
тачна оба исказа.</p>
<p>Конјункција исказа <span class="math notranslate nohighlight">\(p\)</span> и <span class="math notranslate nohighlight">\(q\)</span> обележава се са <span class="math notranslate nohighlight">\(p
\wedge q\)</span>. Истинитосна вредност тог исказа у зависности од истинитосне
вредности исказа <span class="math notranslate nohighlight">\(p\)</span> и истиитосне вредности исказа <span class="math notranslate nohighlight">\(q\)</span>
одређена је следећом таблицом (0 означава да је исказ нетачан, а 1 да
је тачан).</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{|c|c||c|}
\hline
p &amp; q &amp; p \wedge q \\
\hline
0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 0 \\
1 &amp; 1 &amp; 1 \\
\hline
\end{array}\end{split}\]</div>
<p>Купац добија попуст ако је тачан исказ <em>„купац је премијум купац или
му је рачун већи од 1000 динара”</em>. Тај исказ је <strong>дисјункција</strong>
(<strong>логичко „или”</strong>) исказа „Купац је премијум купац” и исказа „рачун
је већи од 1000 динара”. Дисјункција је тачна када је било који од та
два исказа тачан тј. када је тачан бар један од њих. Могуће је да се
деси и да су оба исказа тачна и њихова дисјункција ће бити тачна (ако
премијум купац направи рачун већи од 1000 динара, исказ ће бити тачан
и он ће добити попуст). Таква дисјункција се назива <strong>инклузивна
дисјункција</strong>. У математици се подразумева да је дискункција
инклузивна осим ако се другачије не нагласи.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{|c|c||c|}
\hline
p &amp; q &amp; p \vee q \\
\hline
0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 1 \\
\hline
\end{array}\end{split}\]</div>
<p>Постоји и <strong>ексклузивна дисјункција</strong> која је тачна када је тачно
један од два исказа тачна. На пример, <em>„ићи ћу у посластичарницу или
ако имам пуно пара или ако сам пуно гладан”</em> може бити пример
ексклузивне дисјункције која је нетачна ако су оба услова испуњена
(јер неко може да се боји да ће се пуно угојити ако гладан и са пуно
пара оде у посластичарницу). Екслузивност дисјункције обично у
говорном језику наглашавамо коришћењем везника „или-или”.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{|c|c||c|}
\hline
p &amp; q &amp; p \underline{\vee} q \\
\hline
0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 0 \\
\hline
\end{array}\end{split}\]</div>
<p>Размотримо исказ „ако будеш учио, добићеш добру оцену”. Ово је пример
<strong>импликације</strong> (<strong>ако-онда</strong>). Размислимо када је овај исказ тачан
тј. када наставник говори истину, а када лаже.</p>
<ul class="simple">
<li><p>Ако је ученик учио и добио добру оцену, наставник је рекао
истину.</p></li>
<li><p>Ако је ученик учио, а наставник му није дао добру оцену, јасно је да
је наставник слагао.</p></li>
<li><p>Ако ученик није учио и није добио добру оцену, поново је јасно да
наставник није ништа слагао.</p></li>
<li><p>Донекле збуњујућ случај је ако ученик није учио, а наставник му ипак
да добру оцену. Ни у овом случају не можемо рећи да је наставник
лагао (можемо рећи да поклања оцене). Наиме, наставник у својој
реченици није рекао ништа о томе шта ће се десити ако ученик не буде
учио, па какву год оцену да му да, наставник није слагао ученика.</p></li>
</ul>
<p>Дакле импликација је нетачна једино када је претпоставка испуњена а
закључак није (ученик јесте учио, а наставник му није дао добру
оцену). Импликација је тачна у свим осталим случајевима. Ако
претпоставка није испуњена, импликација је тачна (ако ученик не учи,
наставник не може да испадне лажов). Такође, ако је закључак тачан,
импликација је тачна (ако ученику да добру оцену наставник не може да
испадне лажов).</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{|c|c||c|}
\hline
p &amp; q &amp; p \Rightarrow q \\
\hline
0 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 0 \\
1 &amp; 1 &amp; 1 \\
\hline
\end{array}\end{split}\]</div>
<p>Честа забуна је да људи мешају импликацију и <strong>еквиваленцију</strong>
тј. исказ „ако будеш учио, добићеш добру оцену” схватају као исказ
„добићеш добру цену ако и само ако будеш учио”, што између осталог
значи да ако ученик не буде учио он сигурно неће добити добру
оцену. Еквиваленција је тачна једино када два исказа имају исту
истинитосну вредност (или су оба нетачна или су оба тачна).</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{|c|c||c|}
\hline
p &amp; q &amp; p \Leftrightarrow q \\
\hline
0 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 0 \\
1 &amp; 1 &amp; 1 \\
\hline
\end{array}\end{split}\]</div>
<p>Применом ових логичких везника кренувши од елементарних исказа и
евентуално логичких константи <span class="math notranslate nohighlight">\(\top\)</span> и <span class="math notranslate nohighlight">\(\bot\)</span> градимо
сложене исказе тј.  <strong>исказне формуле</strong>. На пример, <span class="math notranslate nohighlight">\(p \vee \neg
q \Leftrightarrow (p \wedge (\neg q \Rightarrow p))\)</span>. Подразумевамо да
у овако записаним формулама приоритет има оператор <span class="math notranslate nohighlight">\(\neg\)</span>, затим
<span class="math notranslate nohighlight">\(\wedge\)</span>, па <span class="math notranslate nohighlight">\(\vee\)</span>, затим <span class="math notranslate nohighlight">\(\Rightarrow\)</span> и на крају
<span class="math notranslate nohighlight">\(\Leftrightarrow\)</span>.</p>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p><strong>Синтакса</strong> исказне логике дефинише како се граде исправно
записане формуле. Прецизна дефиниција синтаксе формуле је
одређена контекстно слободном граматиком:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray*}
\mathit{formula} &amp;\rightarrow&amp; promenljiva\\
\mathit{formula} &amp;\rightarrow&amp; \top\\
\mathit{formula} &amp;\rightarrow&amp; \bot\\
\mathit{formula} &amp;\rightarrow&amp; \neg \mathit{formula}\\
\mathit{formula} &amp;\rightarrow&amp; \mathit{formula} \wedge \mathit{formula}\\
\mathit{formula} &amp;\rightarrow&amp; \mathit{formula} \vee \mathit{formula}\\
\mathit{formula} &amp;\rightarrow&amp; \mathit{formula} \Rightarrow \mathit{formula}\\
\mathit{formula} &amp;\rightarrow&amp; \mathit{formula} \Leftrightarrow \mathit{formula}\\
\mathit{formula} &amp;\rightarrow&amp; (\mathit{formula})
\end{eqnarray*}\end{split}\]</div>
<p><strong>Семантика</strong> одређује истинитосну вредност формула. <strong>Валуација</strong>
<span class="math notranslate nohighlight">\(v\)</span> је функција која пресликава скуп променљивих у скуп
<span class="math notranslate nohighlight">\(\{0, 1\}\)</span> (променљиве које се сликају у 1 су тачне у тој
валуацији, а оне које се сликају у 0 су нетачне у тој
валуацији). Вредност формуле <span class="math notranslate nohighlight">\(F\)</span> у валуацији <span class="math notranslate nohighlight">\(v\)</span>
обележавамо са <span class="math notranslate nohighlight">\(I_v(F)\)</span>. Функцију <span class="math notranslate nohighlight">\(I_v\)</span> дефинишемо
рекурзивно, на основу водећег везника у формули.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(I_v(\top) = 1\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(I_v(\bot) = 0\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(I_v(p) = v(p)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(I_v(\neg F) = 1 - I_v(F)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(I_v(F_1 \wedge F_2) = \min{(I_v(F_1), I_v(F_2))}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(I_v(F_1 \vee F_2) = \max{(I_v(F_1), I_v(F_2))}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(I_v(F_1 \Rightarrow F_2) = I_v(\neg F_1 \vee F_2)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(I_v(F_1 \Leftrightarrow F_2) = I_v((F_1 \Rightarrow F_2) \wedge (F_2 \Rightarrow F_1))\)</span></p></li>
</ul>
<p>Кажемо да је формула <span class="math notranslate nohighlight">\(F\)</span> <strong>тачна у датој валуацији</strong>
<span class="math notranslate nohighlight">\(v\)</span> ако и само ако је <span class="math notranslate nohighlight">\(I_v(F) = 1\)</span>. Ово обележавамо и
са <span class="math notranslate nohighlight">\(v \vDash F\)</span>.</p>

    </div></div>
<p>Неке исказне формуле су тачне без обзира на истинитосну вредност
полазних исказа од којих су изграђени. Такве формуле се називају
<strong>таутологије</strong>. На пример, формула <span class="math notranslate nohighlight">\(\neg (p \wedge q)
\Leftrightarrow \neg p \vee \neg q\)</span> је тачна без обзира на то да ли су
<span class="math notranslate nohighlight">\(p\)</span> и <span class="math notranslate nohighlight">\(q\)</span> тачни (то је јасно ако разумемо да она говори о
томе да је исто рећи да није тачно да су <span class="math notranslate nohighlight">\(p\)</span> и <span class="math notranslate nohighlight">\(q\)</span> оба
тачни и рећи да бар један од њих није тачан).</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{|c|c||c|}
\hline
p &amp; q &amp; \neg (p \wedge q) \Leftrightarrow \neg p \vee \neg q\\
\hline
0 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 1 \\
\hline
\end{array}\end{split}\]</div>
<p>Доделу истинитосних вредности променљивих називамо <strong>валуација</strong> (на
пример, другом реду у претходној табели одговара валуација
<span class="math notranslate nohighlight">\(p\mapsto 0, q\mapsto 1\)</span>). Таутологије су формуле које су тачне
у свим валуацијама. Негације таутологија су <strong>незадовољиве</strong>
тј. нетачне у свим валуацијама. Формуле које су тачне бар у једној
валуацији називамо <strong>задовољиве формуле</strong> а формуле које нису
таутлогије, тј. које су нетачне бар у једној валуацији називамо
<strong>порециве формуле</strong>.</p>
<p>Испитивање коректности закључивања се може свести на испитивање
таутологичности неких формула. Закључивање се обично заснива на томе
да се на основу тога што је познато да важи један или више исказа
(претпосавке тј. премисе) тврди да важи и неки додатни исказ (закључак
тј. конклузија). Закључак је исправан ако је он <strong>логичка последица</strong>
претпоставки тј. ако је тачан када год су све претпоставке тачне.  Да
би се испитало да ли је исказ <span class="math notranslate nohighlight">\(q\)</span> логичка последица претпоставки
<span class="math notranslate nohighlight">\(p_1, p_2, \ldots, p_n\)</span> (што можемо записати као <span class="math notranslate nohighlight">\(p_1,
\ldots p_n \vDash q\)</span>), довољно је испитати да ли је формула <span class="math notranslate nohighlight">\(p_1
\wedge p_2 \wedge \ldots \wedge p_n \Rightarrow q\)</span> таутологија. Дакле,
логичке последице су у тесној вези са импликацијом.</p>
<p>Испитивање таутологичности (али и задовољивости, незадовољивости и
порецивости) формула може се извршити испитивањем свих валуација
тј. прављењем истинитосне таблице, а видећемо да постоје и ефикаснији
и интуитивнији начини.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>На пример, претпоставимо да знамо да су искази <em>Ако је Цеца
победила онда је Марија била друга или је Сандра била трећа”</em> и
<em>„Сандра није била трећа”</em> тачни. Да ли је исправно из њих
закључити да је исказ <em>„Ако Марија није била друга, онда Цеца није
победила”</em>? Желимо да проверимо да ли је трећи исказ логичка
последица прва два тј. да ли је трећи исказ тачан у свим
валуацијама у којима су прва два тачна. Да би се то проверило
довољно је проверити да је формула <span class="math notranslate nohighlight">\(I_1 \wedge I_2
\Rightarrow I_3\)</span> таутологија, где су са <span class="math notranslate nohighlight">\(I_1\)</span> и <span class="math notranslate nohighlight">\(I_2\)</span>
означени полазни искази, а са <span class="math notranslate nohighlight">\(I_3\)</span> исказ за који проверавамо
да ли је њихова логичка последица. Ако са <span class="math notranslate nohighlight">\(p\)</span> означимо исказ
<em>„Цеца је победила”</em>, са <span class="math notranslate nohighlight">\(q\)</span> исказ „Марија је била друга” и
са <span class="math notranslate nohighlight">\(r\)</span> исказ <em>„Сандра је била трећа”</em>, добијамо формулу:</p>
<div class="math notranslate nohighlight">
\[(p \Rightarrow q \vee r) \wedge (\neg r) \Rightarrow (\neg q \Rightarrow \neg p)\]</div>
<p>Ова формула јесте таутологија, што доказујемо следећом истинитосном
таблицом:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{ccccccccccccccccccc}
(p &amp; \Rightarrow &amp;q  &amp; \vee&amp; r) &amp;\wedge&amp; (\neg &amp;r) &amp;\Rightarrow &amp;(\neg &amp;q  &amp;\Rightarrow &amp;\neg &amp;p)\\
\hline
{\bf 0}  &amp; 1   &amp; {\bf 0} &amp; 0 &amp; {\bf 0}  &amp; 1    &amp; 1     &amp; 0 &amp; 1          &amp; 1    &amp; 0 &amp; 1          &amp; 1  &amp; 0\\
{\bf 0}  &amp; 1   &amp; {\bf 0} &amp; 1 &amp; {\bf 1}  &amp; 0    &amp; 0     &amp; 1 &amp; 1          &amp; 1    &amp; 0 &amp; 1          &amp; 1  &amp; 0\\
{\bf 0}  &amp; 1   &amp; {\bf 1} &amp; 1 &amp; {\bf 0}  &amp; 1    &amp; 1     &amp; 0 &amp; 1          &amp; 0    &amp; 1 &amp; 1          &amp; 1  &amp; 0\\
{\bf 0}  &amp; 1   &amp; {\bf 1} &amp; 1 &amp; {\bf 1}  &amp; 0    &amp; 0     &amp; 1 &amp; 1          &amp; 0    &amp; 1 &amp; 1          &amp; 1  &amp; 0\\
{\bf 1}  &amp; 0   &amp; {\bf 0} &amp; 0 &amp; {\bf 0}  &amp; 0    &amp; 1     &amp; 0 &amp; 1          &amp; 1    &amp; 0 &amp; 0          &amp; 0  &amp; 1\\
{\bf 1}  &amp; 1   &amp; {\bf 0} &amp; 1 &amp; {\bf 1}  &amp; 0    &amp; 0     &amp; 1 &amp; 1          &amp; 1    &amp; 0 &amp; 0          &amp; 0  &amp; 1\\
{\bf 1}  &amp; 1   &amp; {\bf 1} &amp; 1 &amp; {\bf 0}  &amp; 1    &amp; 1     &amp; 0 &amp; 1          &amp; 0    &amp; 1 &amp; 1          &amp; 0  &amp; 1\\
{\bf 1}  &amp; 1   &amp; {\bf 1} &amp; 1 &amp; {\bf 1}  &amp; 0    &amp; 0     &amp; 1 &amp; 1          &amp; 0    &amp; 1 &amp; 1          &amp; 0  &amp; 1\\
\end{array}\end{split}\]</div>
<p>Приметимо да смо у претходној истинитосној таблици вредности
променљивих писали испод њиховог назива, док смо испод сваког
везника писали истинитосну вредност потформуле којој је тај везник
водећи везник. Водећи везник у целој формули је импликација која
повезује конјункцију прва два исказа и трећи исказ, па је
истинитосна вредност целе формуле исписана испод тог
везника. Видимо да су у тој колони све јединице, што значи да је
формула увек тачна, без обзира на истинитосне вредности исказа
<span class="math notranslate nohighlight">\(p\)</span>, <span class="math notranslate nohighlight">\(q\)</span> и <span class="math notranslate nohighlight">\(r\)</span> и да је таутологија.</p>

    </div></div>
<p>Проблем метода истинитосних таблица је то што је тај метод веома
неефикасан. Наиме, за <span class="math notranslate nohighlight">\(n\)</span> исказних променљивих таблица има
<span class="math notranslate nohighlight">\(2^n\)</span> врста, па већ формуле од педесетак променљивих није могуће
обрадити на овакав начин, чак ни уз коришћење веома ефикасних
савремених рачунара. Таутологичност можемо доказати и неким другим
методама. Једна од популарнијих је и <strong>метода семантичких таблоа</strong>.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Покушавамо да пронађемо валуацију <span class="math notranslate nohighlight">\(v\)</span> у којој ће цела формула
бити нетачна тј.</p>
<div class="math notranslate nohighlight">
\[I_v\left((p \Rightarrow q \vee r) \wedge (\neg r) \Rightarrow (\neg q \Rightarrow \neg p)\right) = 0\]</div>
<p>Пошто је у питању импликација, она ће бити нетачна ако и само ако
су обе премисе тачне, а закључак нетачан. Дакле, потребно је да
нађемо валуацију у којој важи:</p>
<div class="math notranslate nohighlight">
\[\begin{split}I_v\left(p \Rightarrow q \vee r\right) = 1\\
I_v\left(\neg r\right) = 1\\
I_v\left(\neg q \Rightarrow \neg p\right) = 0\end{split}\]</div>
<p>Пошто формула <span class="math notranslate nohighlight">\(\neg r\)</span> мора бити тачна, у нашој траженој
валуацији исказ <span class="math notranslate nohighlight">\(r\)</span> мора бити нетачан, а пошто импликација
<span class="math notranslate nohighlight">\(\neg q \Rightarrow \neg p\)</span> мора бити нетачна, њена премиса
мора бити тачна, а закључак нетачан. Тако долазимо до следећих
услова:</p>
<div class="math notranslate nohighlight">
\[\begin{split}I_v\left(p \Rightarrow q \vee r\right) = 1\\
I_v\left(r\right) = 0\\
I_v\left(\neg q\right) = 1\\
I_v\left(\neg p\right) = 0\end{split}\]</div>
<p>Пошто формула <span class="math notranslate nohighlight">\(\neg q\)</span> мора бити тачна, исказ <span class="math notranslate nohighlight">\(q\)</span> мора
бити нетачан, а пошто формула <span class="math notranslate nohighlight">\(\neg p\)</span> мора бити нетачна,
исказ <span class="math notranslate nohighlight">\(p\)</span> мора бити тачан.</p>
<div class="math notranslate nohighlight">
\[\begin{split}I_v\left(p \Rightarrow q \vee r\right) = 1\\
I_v\left(r\right) = 0\\
I_v\left(q\right) = 0\\
I_v\left(p\right) = 1\end{split}\]</div>
<p>Међутим, ови услови су заједно неодрживи. Да би импликација
<span class="math notranslate nohighlight">\(p \Rightarrow q \vee r\)</span> била тачна потребно је или да је
њена претпоставка <span class="math notranslate nohighlight">\(p\)</span> нетачна или да је њен закључак <span class="math notranslate nohighlight">\(q
\vee r\)</span> тачан. Наш табло се зато грана на две могућности:</p>
<ul class="simple">
<li><p>Прва могућност је да важи <span class="math notranslate nohighlight">\(I_v(p)=0\)</span>, међутим то се коси са
условом <span class="math notranslate nohighlight">\(I_v(p)=1\)</span> који је раније изведен.</p></li>
<li><p>Друга могућност је да важи <span class="math notranslate nohighlight">\(I_v(q \vee r)=1\)</span>. Да би ова
импликација била тачна треба да важи или <span class="math notranslate nohighlight">\(I_v(q)=1\)</span> или да важи
<span class="math notranslate nohighlight">\(I_v(r)=1\)</span>. Наш табло се зато поново грана на две могућности,
међутим, лако се види да су обе неодрживе.</p>
<ul>
<li><p>Ако важи <span class="math notranslate nohighlight">\(I_v(q)=1\)</span>, тада није могуће да важи и
<span class="math notranslate nohighlight">\(I_v(q)=0\)</span>, што је услов који смо већ раније извели.</p></li>
<li><p>Ако важи <span class="math notranslate nohighlight">\(I_v(r)=1\)</span>, тада није могуће да важи и
<span class="math notranslate nohighlight">\(I_v(r)=0\)</span>, што је услов који смо већ раније извели.</p></li>
</ul>
</li>
</ul>
<p>Дакле, све гране нашег таблоа су контрадикторне и није могуће
пронаћи валуацију у којој би наша формула била нетачна.</p>

    </div></div>
<p>Често се у закључивању користи и чињеница да су две формуле <strong>логички
еквивалентне</strong>, што значи да је прва тачка ако и само ако је друга
тачна (логичка еквивалентност формула <span class="math notranslate nohighlight">\(\phi_1\)</span> и <span class="math notranslate nohighlight">\(\phi_2\)</span>
се некада обележва са <span class="math notranslate nohighlight">\(\phi_1 \equiv \phi_2\)</span>). На пример,
еквивалентно је да ли смо рекли <em>ако је суво, онда није падала киша</em> и
<em>ако је падала киша, онда није суво</em>. Уопште, формуле <span class="math notranslate nohighlight">\(p
\Rightarrow q\)</span> и <span class="math notranslate nohighlight">\(\neg q \Rightarrow \neg p\)</span> су логички
еквивалентне (овај конкретан пример се назива контрапозиција).  Да би
се доказало да су <span class="math notranslate nohighlight">\(\phi_1 \equiv \phi_2\)</span> еквиваленција, довољно
је доказати да је <span class="math notranslate nohighlight">\(\phi_1 \Leftrightarrow \phi_2\)</span> таутологија.
Дакле, логичка еквиваленција је у тесној вези са еквиваленцијом.</p>
<div class="section" id="sat">
<h2>SAT решавачи<a class="headerlink" href="#sat" title="Permalink to this heading">¶</a></h2>
<p>Постоји веома ефикасан софтвер који може да испита задовољивост
исказне формуле (који је, наравно, заснован на коришћењу другачијих
метода). Такви програми се називају <strong>SAT решавачи</strong> (енгл. SAT
solver). Постоје многи програми ове врсте, а најпознатији од њих је
вероватно решавач MiniSat (<a class="reference external" href="http://minisat.se/">http://minisat.se/</a>,
<a class="reference external" href="http://logicrunch.it.uu.se:4096/~wv/minisat/">http://logicrunch.it.uu.se:4096/~wv/minisat/</a>). Основни алгоритам на
ком су засновани SAT решавачи је DPLL алгоритам
(Дејвис-Патнам-Логеман-Ловеланд).</p>
<p>Иако они испитују само задовољивост формуле, могу се лако употребити
да провере и таутологичност. Наиме, решавач треба да провери
задовољивост негације формуле, па ако утврди да је негација
незадовољива, полазна формула је таутологија. Савремени SAT решавачи
могу да провере неке формуле са стотинама хиљада променљивих.</p>
<p>Да би се SAT решавачи могли користити, формула мора бити припремљена
на одговарајући начин. Потребно је превести формулу у
тзв. <strong>конјунктивну нормалну форму (КНФ)</strong> тј. представити је у облику
конјункције <strong>клаузула</strong> (каже се и клауза), где је свака клаузула
дисјункција <strong>литерала</strong>, а литерал је исказно слово или негација
исказног слова. На пример, наредна формула је у КНФ.</p>
<div class="math notranslate nohighlight">
\[(p \vee \neg q) \wedge (\neg p \vee q \vee r) \wedge \neg r\]</div>
<p>Она се састоји од 3 клаузуле: <span class="math notranslate nohighlight">\(p \vee \neg q\)</span> (она има два
литерала), <span class="math notranslate nohighlight">\(\neg p \vee q \vee r\)</span> (она има три литерала) и
<span class="math notranslate nohighlight">\(\neg r\)</span> (она има један литерал).</p>
<p>Превођење формуле у КНФ се може извршити коришћењем следећих логичких
еквиваленција:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray*}
A \Leftrightarrow B &amp;\equiv&amp; (A \Rightarrow B) \wedge (B \Rightarrow A)\\
A \Rightarrow B &amp;\equiv&amp; \neg A \vee B\\
\neg (A \wedge B) &amp;\equiv&amp; \neg A \vee \neg B\\
\neg (A \vee B) &amp;\equiv&amp; \neg A \wedge \neg B\\
\neg (\neg A) &amp;\equiv&amp; A\\
A \vee (B \wedge C) &amp;\equiv&amp; (A \vee B) \wedge (A \vee C)\\
(A \wedge B) \vee C &amp;\equiv&amp; (A \vee C) \wedge (B \vee C)
\end{eqnarray*}\end{split}\]</div>
<p>Прве две омогућавају да се из формуле уклоне сва појављивања везника
<span class="math notranslate nohighlight">\(\Leftrightarrow\)</span> и <span class="math notranslate nohighlight">\(\Rightarrow\)</span>, наредне три да се све
негације спусте до нивоа исказних слова, а последње две да се применом
дистрибутивности добије жељени однос конјункција и дисјункција. Када
је потребно, може се примењивати и асоцијативност конјункције и
дисјункције.</p>
<p>За вежбу вам остављамо да докажете да су све претходне везе заиста
логичке еквиваленције.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>КНФ облик негације формуле из претходног примера је:</p>
<div class="math notranslate nohighlight">
\[(\neg p \vee q \vee r) \wedge \neg r \wedge \neg q \wedge p\]</div>
<p>Формуле <span class="math notranslate nohighlight">\(\neg (A \Rightarrow B)\)</span> и <span class="math notranslate nohighlight">\(A \wedge \neg B\)</span>
еквивалентне (што се лако може утврдити провером таутологичности
формуле <span class="math notranslate nohighlight">\(\neg (A \Rightarrow B) \Leftrightarrow A \wedge \neg
B\)</span>). Зато је негација формуле облика <span class="math notranslate nohighlight">\(I_1 \wedge I_2
\Rightarrow I\)</span> еквивалентна формули <span class="math notranslate nohighlight">\(I_1 \wedge I_2 \wedge
\neg I\)</span>, па је негација полазне формуле еквивалентна формули:</p>
<div class="math notranslate nohighlight">
\[(p \Rightarrow q \vee r) \wedge \neg r \wedge \neg (\neg q \Rightarrow \neg p)\]</div>
<p>На основу истог правила претходна формула се може свести на:</p>
<div class="math notranslate nohighlight">
\[(p \Rightarrow q \vee r) \wedge \neg r \wedge (\neg q \wedge \neg \neg p)\]</div>
<p>Сада можемо употребити чињеницу да су <span class="math notranslate nohighlight">\(A \Rightarrow B\)</span> и
<span class="math notranslate nohighlight">\(\neg A \vee B\)</span> еквивалентне (што се може лако утврдити
испитивањем таутологичности формуле <span class="math notranslate nohighlight">\((A \Rightarrow B)
\Leftrightarrow (\neg A \vee B)\)</span>) и добити:</p>
<div class="math notranslate nohighlight">
\[(\neg p \vee (q \vee r)) \wedge \neg r \wedge (\neg q \wedge \neg \neg p)\]</div>
<p>На крају, применом чињенице да су <span class="math notranslate nohighlight">\(\neg \neg A\)</span> и <span class="math notranslate nohighlight">\(A\)</span>
еквивалентне и применом закона асоцијативности за конјункцију и
дисјунцкију (који нам омогућавају да неке заграде изоставимо) добијамо
КНФ облик:</p>
<div class="math notranslate nohighlight">
\[(\neg p \vee q \vee r) \wedge \neg r \wedge \neg q \wedge p\]</div>

    </div></div>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>Применом дистрибутивности може се добити КНФ формула која је много
већа од полазне (чак експоненцијално већа). Постоје и ефикасније
методе свођења формуле на КНФ.  Најпознатија од њих је <strong>Цајтинова
трансформација</strong> (енгл. Tseitin transform) која уводи нова исказна
слова којим се обележавају потформуле, пре превођења у КНФ. На
пример, размотримо следећу формулу:</p>
<div class="math notranslate nohighlight">
\[(p \vee (q \wedge r)) \wedge (\neg p \vee \neg r)\]</div>
<p>Њену потформулу <span class="math notranslate nohighlight">\(q \wedge r\)</span> можемо обележити новим словом
<span class="math notranslate nohighlight">\(s_1\)</span>, чиме добијамо формулу:</p>
<div class="math notranslate nohighlight">
\[(p \vee s_1) \wedge (\neg p \vee \neg r) \wedge (s_1 \Leftrightarrow q \wedge r)\]</div>
<p>Њену потформулу <span class="math notranslate nohighlight">\(p \vee s_1\)</span> можемо обележити новим словом
<span class="math notranslate nohighlight">\(s_2\)</span>, чиме добијамо формулу:</p>
<div class="math notranslate nohighlight">
\[s_2 \wedge (\neg p \vee \neg r) \wedge (s_1 \Leftrightarrow q \wedge r) \wedge (s_2 \Leftrightarrow p \vee s_1)\]</div>
<p>Њену потформулу <span class="math notranslate nohighlight">\(\neg p \vee \neg r\)</span> можемо обележити новим словом
<span class="math notranslate nohighlight">\(s_3\)</span>, чиме добијамо формулу:</p>
<div class="math notranslate nohighlight">
\[s_2 \wedge s_3 \wedge (s_1 \Leftrightarrow q \wedge r) \wedge (s_2 \Leftrightarrow p \vee s_1) \wedge (s_3 \Leftrightarrow \neg p \vee \neg r)\]</div>
<p>На крају, њену потформулу <span class="math notranslate nohighlight">\(s_2 \wedge s_3\)</span> можемо обележити
новим словом <span class="math notranslate nohighlight">\(s_4\)</span>, чиме добијамо формулу:</p>
<div class="math notranslate nohighlight">
\[s_4 \wedge (s_1 \Leftrightarrow q \wedge r) \wedge (s_2 \Leftrightarrow p \vee s_1) \wedge (s_3 \Leftrightarrow \neg p \vee \neg r) \wedge (s_4 \Leftrightarrow s_2 \wedge s_3)\]</div>
<p>Сада се свака од логичких еквиваленција лако може засебно превести
у КНФ чиме се добија коначан КНФ облик полазне формуле.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{l}
s_4 \\
(\neg s_1 \vee q) \wedge (\neg s_1 \vee r) \wedge (\neg q \vee \neg r \vee s_1)\ \wedge \\
(\neg s_2 \vee p \vee s_1) \wedge (\neg p \vee s_2) \wedge (\neg s_1 \vee s_2)\ \wedge\\
(\neg s_3 \vee \neg p \vee \neg r) \wedge (p \vee s_3)\wedge (r \vee s_3)\ \wedge \\
(\neg s_4 \vee s_2) \wedge (\neg s_4 \vee s_3)\wedge (\neg s_2 \vee \neg s_3 \vee s_4)
\end{array}\end{split}\]</div>
<p>Тиме се полазна формула увећава само за константни фактор.  Додуше
добијена формула неће више бити логички еквивалентна полазној, већ
само еквизадовољива, што значи да је КНФ облик задовољив ако и само
ако је задовољива полазна формула. Приметимо да нам је то сасвим
довољно за примену SAT решавача, јер утврђивањем незадовољивости
КНФ облика аутоматски знамо да је и полазна формула незадовољива,
док се утврђивањем задовољивости КНФ облика добија валуација која
је уједно и валуација у којој је полазна формула тачна (довољно је
просто занемарити вредности новоуведних променљивих у тој
валуацији).</p>

    </div></div>
<p>Формуле у КНФ облику се обично описују у DIMACS формату (то је
стандардни формат улаза SAT решавача). Променљиве се обележавају
бројевима 1, 2, 3 итд. Негативни бројеви означавају негације
променљивих. Свака клаузула се записује као низ бројева завршен нулом.
На пример, DIMACS запис формуле <span class="math notranslate nohighlight">\((p \vee \neg q) \wedge (\neg p
\vee q \vee r) \wedge \neg r\)</span> је:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="n">cnf</span> <span class="mi">3</span> <span class="mi">3</span>
<span class="mi">1</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">0</span>
<span class="o">-</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">0</span>
<span class="o">-</span><span class="mi">3</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Прва линија је заглавље и говори о томе да формула има 3 променљиве и
3 клаузуле. Променљиве <span class="math notranslate nohighlight">\(p\)</span>, <span class="math notranslate nohighlight">\(q\)</span> и <span class="math notranslate nohighlight">\(r\)</span> су означене
редом бројевима 1, 2 и 3.</p>
<p>Ако овај текст снимимо у датотеку <cite>formula.cnf</cite> и покренемо SAT
решавач (на пример, MiniSAT) или је унесемо у веб-интерфејс SAT
решавача MiniSAT (<a class="reference external" href="http://logicrunch.it.uu.se:4096/~wv/minisat/">http://logicrunch.it.uu.se:4096/~wv/minisat/</a>),
добићемо резултат</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SAT</span>
<span class="o">-</span><span class="mi">1</span> <span class="o">-</span><span class="mi">2</span> <span class="o">-</span><span class="mi">3</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Ово значи да је формула задовољива и једна валуација у којој је та
формула тачна је <span class="math notranslate nohighlight">\(p \mapsto 0, q \mapsto 0, r \mapsto 0\)</span>.</p>
<div class="section" id="id2">
<h3>Судоку<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h3>
<p>Прикажимо сада како можемо искористити SAT решавач да решимо логичку
загонетку Судоку. Ова загонетка захтева да се поље димензије <span class="math notranslate nohighlight">\(9
\times 9\)</span> попуни бројевима од 1 до 9 тако да су у свакој врсти, у
свакој колони и у сваком троуглу димензије <span class="math notranslate nohighlight">\(3 \times 3\)</span> бројеви
различити. Потребно је да кодирамо овај проблем коришћењем исказне
логике. Означимо поља табеле са <span class="math notranslate nohighlight">\(A_{ij}\)</span> за <span class="math notranslate nohighlight">\(1 \leq i, j
\leq 9\)</span>. На сваком пољу може бити уписан било који број од 1
до 9. Основни искази ће бити означени са <span class="math notranslate nohighlight">\(p_{ijv}\)</span> за <span class="math notranslate nohighlight">\(1
\leq i, j, v \leq 9\)</span> и означаваће да је на пољу <span class="math notranslate nohighlight">\(A_{ij}\)</span> уписана
вредност <span class="math notranslate nohighlight">\(v\)</span>. Сваки од ових исказа може бити или тачан или
нетачан. Потребно је да одредимо и везе између исказа које ће
осигурати да ће њихове истинитосне вредности одређивати исправно решење
загонетке Судоку.</p>
<p>За почетак, на сваком пољу треба да пише тачно једна вредност, што
значи да за сваки пар <span class="math notranslate nohighlight">\(i\)</span> и <span class="math notranslate nohighlight">\(j\)</span> од 1 до 9 тачно једна од
променљивих <span class="math notranslate nohighlight">\(p_{ij1}, \ldots, p_{ij9}\)</span> треба да има вредност
тачно. Ово можемо кодирати следећим формулама:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray*}
p_{ij1} \vee p_{ij2} \vee \ldots \vee p_{ij9}\\
p_{ij1} \Rightarrow \neg p_{ij2} \wedge \neg p_{ij3} \ldots \neg p_{ij9}\\
p_{ij2} \Rightarrow \neg p_{ij1} \wedge \neg p_{ij3} \ldots \neg p_{ij9}\\
\ldots\\
p_{ij9} \Rightarrow \neg p_{ij1} \wedge \neg p_{ij2} \ldots \neg p_{ij8}
\end{eqnarray*}\end{split}\]</div>
<p>Свака од ових импликација се може разбити на 8 мањих импликација, а
затим се трансформацијом <span class="math notranslate nohighlight">\(p \Rightarrow q\)</span> у <span class="math notranslate nohighlight">\(\neg p \vee
q\)</span> може добити следећи низ клаузула (генеришу се засебно клаузуле за
свако <span class="math notranslate nohighlight">\(i, j\)</span> од 1 до 9):</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray*}
p_{ij1} \vee p_{ij2} \vee \ldots \vee p_{ij9}\\
\neg p_{ij1} \vee \neg p_{ij2} \\
\neg p_{ij1} \vee \neg p_{ij3} \\
\ldots \\
\neg p_{ij1} \vee \neg p_{ij9} \\
\neg p_{ij2} \vee \neg p_{ij3} \\
\neg p_{ij2} \vee \neg p_{ij4} \\
\ldots \\
\neg p_{ij2} \vee \neg p_{ij9} \\
\ldots \\
\ldots \\
\neg p_{ij8} \vee \neg p_{ij9} \\
\end{eqnarray*}\end{split}\]</div>
<p>На сличан начин треба да кодирамо услове да ће за сваку врсту
<span class="math notranslate nohighlight">\(i\)</span> и сваку вредност <span class="math notranslate nohighlight">\(v\)</span> од 1 до 9 тачно једна променљива
<span class="math notranslate nohighlight">\(p_{i1v}, p_{i2v}, \ldots, p_{i9v}\)</span> бити тачна, а затим услове
да ће за сваку колону <span class="math notranslate nohighlight">\(j\)</span> и сваку вредност <span class="math notranslate nohighlight">\(v\)</span> од 1 до 9
тачно једна променљива <span class="math notranslate nohighlight">\(p_{1jv}, p_{2jv}, \ldots, p_{9jv}\)</span> бити
тачна. На крају је потребно додати и услове за сваки од квадрата
димензије <span class="math notranslate nohighlight">\(3\times 3\)</span>. Сваки од 9 квадрата се може задати паром
индекса <span class="math notranslate nohighlight">\((k, l)\)</span> између 0 и 2 (нпр. <span class="math notranslate nohighlight">\((0, 0)\)</span> означава
горњи леви квадрат, а <span class="math notranslate nohighlight">\((2, 2)\)</span> доњи десни). За сваки квадрат
<span class="math notranslate nohighlight">\((k, l)\)</span> и сваку вредност <span class="math notranslate nohighlight">\(v\)</span> између 1 и 9, тачно једна од
променљивих</p>
<div class="math notranslate nohighlight">
\[\begin{split}p_{(3k+1)(3l+1)v},\ p_{(3k+1)(3l+2)v},\ p_{(3k+1)(3l+3)v}\\
p_{(3k+2)(3l+1)v},\ p_{(3k+2)(3l+2)v},\ p_{(3k+2)(3l+3)v}\\
p_{(3k+3)(3l+1)v},\ p_{(3k+3)(3l+2)v},\ p_{(3k+3)(3l+3)v}\end{split}\]</div>
<p>треба да буде тачна.</p>
<p>У загонетнки Судоку обично су задате вредности које су уписане у нека
поља (и то често тако да се гарантује да се остала поља могу попунити
на јединствен начин тј. да постоји само једно тачно решење загонетке).
Задате вредности једноставно кодирамо тако што решавачу дамо
једночлане клаузуле које садрже само променљиве за које унапред знамо
да су тачне. Наредни програм у језику C# кодира загонетку Судоку у
формату DIMACS који је стандардни улазни формат SAT
решавача. Имплементација је прилично праволинијска. Потребно је
пресликати променљиве <span class="math notranslate nohighlight">\(p_{ijv}\)</span> на бројеве од <span class="math notranslate nohighlight">\(1\)</span> до
<span class="math notranslate nohighlight">\(9^3 = 729\)</span>. Најједноставнији начин да се то уради је да се
индекси <span class="math notranslate nohighlight">\(ijv\)</span> тумаче као цифре (увећане за 1) у основи 9 тј. да
се свака променљива <span class="math notranslate nohighlight">\(p_{ijv}\)</span> преслика у број <span class="math notranslate nohighlight">\((i-1) +
9\cdot (j-1) + 81\cdot (v-1) + 1\)</span>. Тада је и декодирање једноставно (и
своди се на одређивање вредности цифара у основи 9):</p>
<div class="math notranslate nohighlight">
\[\begin{split}i = (p - 1)\ \mathrm{mod}\ 9 + 1\\
j = ((p - 1)\ \mathrm{div}\ 9)\ \mathrm{mod}\ 9 + 1\\
v = ((p - 1)\ \mathrm{div}\ 81) + 1\end{split}\]</div>
<p>Програм генерише 81 услов јединствености броја на пољу (за 81 поље),
81 услов јединствености броја у врсти (за 9 врста и по 9 бројева), 81
услов јединствености броја у колони (за 9 колона и по 9 бројева) и 81
услов јединствености броја у мало квадрату (за 9 малих квадрата и по 9
бројева). Сваки услов јединствености има једну позитивну клаузулу са 9
литерала и <span class="math notranslate nohighlight">\({9 \choose 2} = 36\)</span> негативних клаузула са по 2
литерала. Укупан број општих клаузула је зато <span class="math notranslate nohighlight">\(4 \cdot 81 \cdot
37\)</span>, а њима се додају у једночлане клаузуле за свако унапред попуњено
поље.</p>
<p>Коначна верзија програма дата је у наставку.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// ispisuje DIMACS zaglavlje</span>
<span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Zaglavlje</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">BrojPromenljivih</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BrojKlauzula</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;p cnf {0} {1}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">BrojPromenljivih</span><span class="p">,</span><span class="w"> </span><span class="n">BrojKlauzula</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// ispisuje klauzulu kao red u formatu DIMACS</span>
<span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Klauzula</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="n">promenljive</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">foreach</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">promenljive</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="p">+</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="m">0</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// kodira se uslov da je tacno jedna od promenljivih iz datog niza tacna</span>
<span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">TacnoJedna</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="n">promenljive</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// klauzula koja dovodi do toga da bar jedna promenljiva iz niza</span>
<span class="w">    </span><span class="c1">// mora biti tacna</span>
<span class="w">    </span><span class="n">Klauzula</span><span class="p">(</span><span class="n">promenljive</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// klauzule koje za svaki par promenljivih zabranju da su obe</span>
<span class="w">    </span><span class="c1">// promenljive istovremeno tacne</span>
<span class="w">    </span><span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="n">kl</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="m">2</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="n">promenljive</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="p">++)</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">+</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="n">promenljive</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="p">++)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">kl</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">-</span><span class="n">promenljive</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="n">kl</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">-</span><span class="n">promenljive</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="n">Klauzula</span><span class="p">(</span><span class="n">kl</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// trojke (i, j, v) se kodiraju brojevima između 1 i 729</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">P</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">-</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="p">+</span><span class="w"> </span><span class="m">9</span><span class="p">*(</span><span class="n">j</span><span class="p">-</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="p">+</span><span class="w"> </span><span class="m">81</span><span class="p">*(</span><span class="n">v</span><span class="p">-</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="p">+</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ucitavamo vrednosti na zadatim poljima</span>
<span class="w">    </span><span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span><span class="w"> </span><span class="n">zadate</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span><span class="w"></span>
<span class="w">    </span><span class="kt">string</span><span class="w"> </span><span class="n">linija</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">linija</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">())</span><span class="w"> </span><span class="p">!=</span><span class="w"> </span><span class="k">null</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">delovi</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">linija</span><span class="p">.</span><span class="n">Split</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kt">int</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">delovi</span><span class="p">[</span><span class="m">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kt">int</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">delovi</span><span class="p">[</span><span class="m">1</span><span class="p">]);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kt">int</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">delovi</span><span class="p">[</span><span class="m">2</span><span class="p">]);</span><span class="w"></span>
<span class="w">        </span><span class="n">zadate</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// stampamo DIMACS zaglavlje</span>
<span class="w">    </span><span class="n">Zaglavlje</span><span class="p">(</span><span class="m">729</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">*</span><span class="m">81</span><span class="p">*</span><span class="m">37</span><span class="w"> </span><span class="p">+</span><span class="w"> </span><span class="n">zadate</span><span class="p">.</span><span class="n">Count</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// jedinstvenost vrednosti na svakom polju</span>
<span class="w">    </span><span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="n">promenljive</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="m">9</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">&lt;=</span><span class="w"> </span><span class="m">9</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="p">++)</span><span class="w"></span>
<span class="w">       </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="p">&lt;=</span><span class="w"> </span><span class="m">9</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="p">++)</span><span class="w"></span>
<span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="w">           </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">&lt;=</span><span class="w"> </span><span class="m">9</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="p">++)</span><span class="w"></span>
<span class="w">              </span><span class="n">promenljive</span><span class="p">[</span><span class="n">v</span><span class="p">-</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="w">           </span><span class="n">TacnoJedna</span><span class="p">(</span><span class="n">promenljive</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// jedinstvenost vrednosti u svakoj vrsti</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">&lt;=</span><span class="w"> </span><span class="m">9</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="p">++)</span><span class="w"></span>
<span class="w">       </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">&lt;=</span><span class="w"> </span><span class="m">9</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="p">++)</span><span class="w"></span>
<span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="w">           </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="p">&lt;=</span><span class="w"> </span><span class="m">9</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="p">++)</span><span class="w"></span>
<span class="w">              </span><span class="n">promenljive</span><span class="p">[</span><span class="n">j</span><span class="p">-</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="w">           </span><span class="n">TacnoJedna</span><span class="p">(</span><span class="n">promenljive</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// jedinstvenost vrednosti u svakoj koloni</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="p">&lt;=</span><span class="w"> </span><span class="m">9</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="p">++)</span><span class="w"></span>
<span class="w">       </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">&lt;=</span><span class="w"> </span><span class="m">9</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="p">++)</span><span class="w"></span>
<span class="w">       </span><span class="p">{</span><span class="w"></span>
<span class="w">           </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">&lt;=</span><span class="w"> </span><span class="m">9</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="p">++)</span><span class="w"></span>
<span class="w">              </span><span class="n">promenljive</span><span class="p">[</span><span class="n">i</span><span class="p">-</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="w">           </span><span class="n">TacnoJedna</span><span class="p">(</span><span class="n">promenljive</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// jedinstvenost vrednosti u svakom kvadratu 3x3</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="m">3</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="p">++)</span><span class="w"></span>
<span class="w">       </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="m">3</span><span class="p">;</span><span class="w"> </span><span class="n">l</span><span class="p">++)</span><span class="w"></span>
<span class="w">          </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">&lt;=</span><span class="w"> </span><span class="m">9</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="p">++)</span><span class="w"></span>
<span class="w">          </span><span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">&lt;=</span><span class="w"> </span><span class="m">3</span><span class="p">;</span><span class="w"> </span><span class="n">a</span><span class="p">++)</span><span class="w"></span>
<span class="w">                 </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">&lt;=</span><span class="w"> </span><span class="m">3</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="p">++)</span><span class="w"></span>
<span class="w">                     </span><span class="n">promenljive</span><span class="p">[</span><span class="m">3</span><span class="p">*(</span><span class="n">a</span><span class="p">-</span><span class="m">1</span><span class="p">)+(</span><span class="n">b</span><span class="p">-</span><span class="m">1</span><span class="p">)]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">P</span><span class="p">(</span><span class="m">3</span><span class="p">*</span><span class="n">k</span><span class="p">+</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">*</span><span class="n">l</span><span class="p">+</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="w">              </span><span class="n">TacnoJedna</span><span class="p">(</span><span class="n">promenljive</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// ispisujemo zadate promenljive</span>
<span class="w">    </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">zadate</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="n">kl</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">{</span><span class="n">p</span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="n">Klauzula</span><span class="p">(</span><span class="n">kl</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Програм учитава унапред попуњене вредности. На пример, судоку загонетка:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">.</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span> <span class="mi">3</span>
<span class="mi">9</span> <span class="o">.</span> <span class="o">.</span> <span class="mi">3</span> <span class="o">.</span> <span class="mi">2</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
<span class="mi">6</span> <span class="mi">8</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span> <span class="mi">5</span> <span class="o">.</span>
<span class="mi">1</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span> <span class="mi">5</span> <span class="o">.</span> <span class="o">.</span> <span class="mi">9</span>
<span class="mi">5</span> <span class="o">.</span> <span class="o">.</span> <span class="mi">7</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span> <span class="mi">6</span> <span class="mi">2</span>
<span class="o">.</span> <span class="o">.</span> <span class="mi">4</span> <span class="o">.</span> <span class="mi">1</span> <span class="o">.</span> <span class="mi">5</span> <span class="mi">3</span> <span class="mi">8</span>
<span class="mi">3</span> <span class="mi">4</span> <span class="o">.</span> <span class="mi">8</span> <span class="o">.</span> <span class="o">.</span> <span class="mi">7</span> <span class="o">.</span> <span class="o">.</span>
<span class="o">.</span> <span class="o">.</span> <span class="mi">1</span> <span class="mi">9</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
<span class="o">.</span> <span class="mi">5</span> <span class="o">.</span> <span class="o">.</span> <span class="mi">7</span> <span class="mi">3</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
</pre></div>
</div>
<p>се описује улазом:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="mi">9</span> <span class="mi">3</span>
<span class="mi">2</span> <span class="mi">1</span> <span class="mi">9</span>
<span class="mi">2</span> <span class="mi">4</span> <span class="mi">3</span>
<span class="mi">2</span> <span class="mi">6</span> <span class="mi">2</span>
<span class="mi">3</span> <span class="mi">1</span> <span class="mi">6</span>
<span class="mi">3</span> <span class="mi">2</span> <span class="mi">8</span>
<span class="mi">3</span> <span class="mi">8</span> <span class="mi">5</span>
<span class="mi">4</span> <span class="mi">1</span> <span class="mi">1</span>
<span class="mi">4</span> <span class="mi">6</span> <span class="mi">5</span>
<span class="mi">4</span> <span class="mi">9</span> <span class="mi">9</span>
<span class="mi">5</span> <span class="mi">1</span> <span class="mi">5</span>
<span class="mi">5</span> <span class="mi">4</span> <span class="mi">7</span>
<span class="mi">5</span> <span class="mi">8</span> <span class="mi">6</span>
<span class="mi">5</span> <span class="mi">9</span> <span class="mi">2</span>
<span class="mi">6</span> <span class="mi">3</span> <span class="mi">4</span>
<span class="mi">6</span> <span class="mi">5</span> <span class="mi">1</span>
<span class="mi">6</span> <span class="mi">7</span> <span class="mi">5</span>
<span class="mi">6</span> <span class="mi">8</span> <span class="mi">3</span>
<span class="mi">6</span> <span class="mi">9</span> <span class="mi">8</span>
<span class="mi">7</span> <span class="mi">1</span> <span class="mi">3</span>
<span class="mi">7</span> <span class="mi">2</span> <span class="mi">4</span>
<span class="mi">7</span> <span class="mi">4</span> <span class="mi">8</span>
<span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span>
<span class="mi">8</span> <span class="mi">3</span> <span class="mi">1</span>
<span class="mi">8</span> <span class="mi">4</span> <span class="mi">9</span>
<span class="mi">9</span> <span class="mi">2</span> <span class="mi">5</span>
<span class="mi">9</span> <span class="mi">5</span> <span class="mi">7</span>
<span class="mi">9</span> <span class="mi">6</span> <span class="mi">3</span>
</pre></div>
</div>
<p>Ако унесемо тај улаз нашем програму, добијамо исказну формулу
<a class="reference external" href="sudoku1.cnf">sudoku1.cnf</a>. Њеним решавањем помоћу SAT решавача добијамо
задовољавајућу валуацију у којој су тачне следеће променљиве (све
остале променљиве су нетачне):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="mi">4</span>  <span class="mi">11</span>  <span class="mi">26</span>  <span class="mi">30</span>  <span class="mi">42</span>  <span class="mi">52</span>  <span class="mi">59</span>  <span class="mi">64</span>  <span class="mi">81</span>
 <span class="mi">90</span>  <span class="mi">91</span> <span class="mi">103</span> <span class="mi">114</span> <span class="mi">125</span> <span class="mi">128</span> <span class="mi">138</span> <span class="mi">151</span> <span class="mi">158</span>
<span class="mi">169</span> <span class="mi">175</span> <span class="mi">183</span> <span class="mi">191</span> <span class="mi">203</span> <span class="mi">216</span> <span class="mi">224</span> <span class="mi">231</span> <span class="mi">235</span>
<span class="mi">244</span> <span class="mi">259</span> <span class="mi">267</span> <span class="mi">279</span> <span class="mi">281</span> <span class="mi">293</span> <span class="mi">301</span> <span class="mi">314</span> <span class="mi">318</span>
<span class="mi">329</span> <span class="mi">342</span> <span class="mi">344</span> <span class="mi">352</span> <span class="mi">367</span> <span class="mi">373</span> <span class="mi">384</span> <span class="mi">390</span> <span class="mi">404</span>
<span class="mi">408</span> <span class="mi">420</span> <span class="mi">432</span> <span class="mi">436</span> <span class="mi">442</span> <span class="mi">458</span> <span class="mi">461</span> <span class="mi">473</span> <span class="mi">484</span>
<span class="mi">492</span> <span class="mi">503</span> <span class="mi">505</span> <span class="mi">518</span> <span class="mi">531</span> <span class="mi">534</span> <span class="mi">547</span> <span class="mi">553</span> <span class="mi">560</span>
<span class="mi">575</span> <span class="mi">579</span> <span class="mi">590</span> <span class="mi">601</span> <span class="mi">607</span> <span class="mi">613</span> <span class="mi">630</span> <span class="mi">632</span> <span class="mi">645</span>
<span class="mi">650</span> <span class="mi">662</span> <span class="mi">673</span> <span class="mi">683</span> <span class="mi">687</span> <span class="mi">699</span> <span class="mi">703</span> <span class="mi">720</span> <span class="mi">724</span>
</pre></div>
</div>
<p>Њиховим декодирањем добијамо следеће решење:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">4</span> <span class="mi">2</span> <span class="mi">7</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">1</span> <span class="mi">3</span>
<span class="mi">9</span> <span class="mi">1</span> <span class="mi">5</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">2</span> <span class="mi">6</span> <span class="mi">8</span> <span class="mi">7</span>
<span class="mi">6</span> <span class="mi">8</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">9</span> <span class="mi">7</span> <span class="mi">2</span> <span class="mi">5</span> <span class="mi">4</span>
<span class="mi">1</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">6</span> <span class="mi">8</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">7</span> <span class="mi">9</span>
<span class="mi">5</span> <span class="mi">9</span> <span class="mi">8</span> <span class="mi">7</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">1</span> <span class="mi">6</span> <span class="mi">2</span>
<span class="mi">7</span> <span class="mi">6</span> <span class="mi">4</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">9</span> <span class="mi">5</span> <span class="mi">3</span> <span class="mi">8</span>
<span class="mi">3</span> <span class="mi">4</span> <span class="mi">9</span> <span class="mi">8</span> <span class="mi">5</span> <span class="mi">1</span> <span class="mi">7</span> <span class="mi">2</span> <span class="mi">6</span>
<span class="mi">8</span> <span class="mi">7</span> <span class="mi">1</span> <span class="mi">9</span> <span class="mi">2</span> <span class="mi">6</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span>
<span class="mi">2</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">4</span> <span class="mi">7</span> <span class="mi">3</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Вама препуштамо да сами напишете програм који ће приказати решење на
основу решења добијеног од SAT решавача (програм треба да прочита
решење, издвоји позитивне бројеве, декодира сваки од њих и да на
основу тога формира и испише Судоку матрицу). Покушајте и да проширите
формулу клаузулом која ће забранити добијање овог решења, да поново
покренете SAT решавач и на тај начин да проверите да ли је ово решење
јединствено.</p>
<p>Приметимо да је решавање Судоку загонетке свођењем на SAT веома
декларативно. У програму смо само морали да опишемо (клаузулама)
услове које решење мора да задовољава, а не и алгоритам како се до
решења долази (SAT решавач је коришћењем веома ефикасних метода до тог
решења дошао практично моментално).</p>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>Уместо да C# програм исписује излазну датотеку у формату DIMACS
која се онда шаље спољашњем SAT решавачу, могуће је SAT решавач
покренути директно из C# програма преко API које SAT решавачи
обично нуде. Препуштамо ти да, на пример, инсталираш библиотеку
<strong>Microsoft.Solver.Foundation</strong> (за то можеш користити NuGet), да
проучиш како се она користи и да прилагодиш претходни програм тако
да коришћењем ове библиотеке решава Судоку и приказује његово
решење.</p>

    </div></div>
</div>
</div>
</div>


    </div>
    
    <div>
<div class="lecture-prev-next-toggle">
  <a  href="01_logicka.html" id="prevLectureLink" class="lecture-toggler-arrows"><i class="fas fa-arrow-left fa"></i> <span> Претходна лекција </span> </a>
  
  <a id="nextLectureLink" class="lecture-toggler-arrows"><span> Следећа лекција</span>  <i class="fas fa-arrow-right fa"></i> </a>
</div>

<script type="text/javascript">
  $('#relations-prev').tooltip({'placement':'right', 'selector': '', 'delay': { show: 100, hide: 50}});
  $('#relations-next').tooltip({'placement':'left', 'selector': '', 'delay': { show: 100, hide: 50}});
</script>
</div>

    
  </div>
</div>

<div class="petljadoc-resources">
  <span class="pull-left">(Created using  <a href="https://pypi.org/project/Sphinx/">Swinx</a>, <a href="http://runestoneinteractive.org/">RunestoneComponents</a> and <a href="https://github.com/Petlja/PetljaDoc">PetljaDoc</a>) <br> © 2022 Petlja</span>
</div>


<div class="lectureToolbox">

  <label class="font-size-toggle" id="fontSizeToggle">

      <i class="fas fa-font"></i><label>Слова</label>
  </label>
  <div class="font-change d-none" id="fontChangeModal">
      <span class="dec-letter-icon" id="decLetterIcon">A-</span>
      <label id="currentFontSize">16</label>
      <span class="inc-letter-icon" id="incLetterIcon">A+</span>
  </div>
</div>

</div>

  </body>
</html>