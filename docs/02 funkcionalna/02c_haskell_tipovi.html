<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Алгебарски типови података</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/activecode.css" />
    <link rel="stylesheet" type="text/css" href="../_static/codemirror.css" />
    <link rel="stylesheet" type="text/css" href="../_static/qchoice.css" />
    <link rel="stylesheet" type="text/css" href="../_static/clickable.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pytutor.css" />
    <link rel="stylesheet" type="text/css" href="../_static/modal-basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/datafile.css" />
    <link rel="stylesheet" type="text/css" href="../_static/dragndrop.css" />
    <link rel="stylesheet" type="text/css" href="../_static/fitb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/matrixeq.css" />
    <link rel="stylesheet" type="text/css" href="../_static/parsons.css" />
    <link rel="stylesheet" type="text/css" href="../_static/lib/prettify.css" />
    <link rel="stylesheet" type="text/css" href="../_static/poll.css" />
    <link rel="stylesheet" type="text/css" href="../_static/showEval.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tabbedstuff.css" />
    <link rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/video.css" />
    <link rel="stylesheet" type="text/css" href="../_static/webgldemo.css" />
    <link rel="stylesheet" type="text/css" href="../_static/webglinteractive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/karel.css" />
    <link rel="stylesheet" type="text/css" href="../_static/notes.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/associations.css" />
    <link rel="stylesheet" type="text/css" href="../_static/editor.css" />
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/user-highlights.css" type="text/css" />
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.1/css/all.css" type="text/css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-4.0.0-dist/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/flatly.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/petlja-course.css" type="text/css" />
    <link rel="stylesheet" href="../_static/nbstyle.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/runestonebase.js"></script>
    <script src="../_static/skulpt.min.js"></script>
    <script src="../_static/skulpt-stdlib.js"></script>
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/jquery.highlight.js"></script>
    <script src="../_static/bookfuncs.js"></script>
    <script src="../_static/codemirror.js"></script>
    <script src="../_static/xml.js"></script>
    <script src="../_static/css.js"></script>
    <script src="../_static/python.js"></script>
    <script src="../_static/htmlmixed.js"></script>
    <script src="../_static/javascript.js"></script>
    <script src="../_static/jquery_i18n/CLDRPluralRuleParser.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.messagestore.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.fallbacks.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.language.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.parser.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.emitter.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.emitter.bidi.js"></script>
    <script src="../_static/activecode-i18n.en.js"></script>
    <script src="../_static/activecode-i18n.sr-Cyrl.js"></script>
    <script src="../_static/activecode.js"></script>
    <script src="../_static/clike.js"></script>
    <script src="../_static/timed_activecode.js"></script>
    <script src="../_static/animationbase.js"></script>
    <script src="../_static/mchoice.js"></script>
    <script src="../_static/timedmc.js"></script>
    <script src="../_static/timed.js"></script>
    <script src="../_static/mchoice-i18n.en.js"></script>
    <script src="../_static/mchoice-i18n.sr-Cyrl.js"></script>
    <script src="../_static/clickable.js"></script>
    <script src="../_static/timedclickable.js"></script>
    <script src="../_static/d3.v2.min.js"></script>
    <script src="../_static/jquery.ba-bbq.min.js"></script>
    <script src="../_static/jquery.jsPlumb-1.3.10-all-min.js"></script>
    <script src="../_static/pytutor.js"></script>
    <script src="../_static/codelens.js"></script>
    <script src="../_static/skulpt.min.js"></script>
    <script src="../_static/skulpt-stdlib.js"></script>
    <script src="../_static/datafile.js"></script>
    <script src="../_static/dragndrop.js"></script>
    <script src="../_static/timeddnd.js"></script>
    <script src="../_static/dragndrop-i18n.en.js"></script>
    <script src="../_static/dragndrop-i18n.sr-Cyrl.js"></script>
    <script src="../_static/fitb.js"></script>
    <script src="../_static/timedfitb.js"></script>
    <script src="../_static/fitb-i18n.en.js"></script>
    <script src="../_static/fitb-i18n.sr-Cyrl.js"></script>
    <script src="../_static/matrixeq.js"></script>
    <script src="../_static/lib/prettify.js"></script>
    <script src="../_static/lib/hammer.min.js"></script>
    <script src="../_static/parsons.js"></script>
    <script src="../_static/parsons-i18n.en.js"></script>
    <script src="../_static/parsons-i18n.sr-Cyrl.js"></script>
    <script src="../_static/timedparsons.js"></script>
    <script src="../_static/poll.js"></script>
    <script src="../_static/reveal.js"></script>
    <script src="../_static/shortanswer.js"></script>
    <script src="../_static/timed_shortanswer.js"></script>
    <script src="../_static/showEval.js"></script>
    <script src="../_static/tabbedstuff.js"></script>
    <script src="../_static/runestonevideo.js"></script>
    <script src="../_static/webglinteractive.js"></script>
    <script src="../_static/FileSaver.min.js"></script>
    <script src="../_static/Blob.js"></script>
    <script src="../_static/karelCorner.js"></script>
    <script src="../_static/karelRobot.js"></script>
    <script src="../_static/karelWorld.js"></script>
    <script src="../_static/karelChat.js"></script>
    <script src="../_static/karelRobotDrawer.js"></script>
    <script src="../_static/karelUI.js"></script>
    <script src="../_static/karel.js"></script>
    <script src="../_static/karel-i18n.en.js"></script>
    <script src="../_static/karel-i18n.sr-Cyrl.js"></script>
    <script src="../_static/notes.js"></script>
    <script src="../_static/pygamelib-init.js"></script>
    <script src="../_static/gallery.js"></script>
    <script src="../_static/associations.js"></script>
    <script src="../_static/associations-i18n.en.js"></script>
    <script src="../_static/associations-i18n.sr-Cyrl.js"></script>
    <script src="../_static/editor.js"></script>
    <script src="../_static/jszip.js"></script>
    <script src="../_static/editor-i18n.en.js"></script>
    <script src="../_static/editor-i18n.sr-Cyrl.js"></script>
    <script src="../_static/translations.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/jquery-ui-1.10.3.custom.min.js"></script>
    <script src="../_static/jquery-fix.js"></script>
    <script src="../_static/bootstrap-4.0.0-dist/js/bootstrap.min.js"></script>
    <script src="../_static/bootstrap-4.0.0-dist/js/bootstrap.bundle.min.js"></script>
    <script src="../_static/bootstrap-sphinx.js"></script>
    <script src="../_static/waypoints.min.js"></script>
    <script src="../_static/rangy-core.js"></script>
    <script src="../_static/rangy-textrange.js"></script>
    <script src="../_static/rangy-cssclassapplier.js"></script>
    <script src="../_static/user-highlights.js"></script>
    <script src="../_static/jquery.idle-timer.js"></script>
    <script src="../_static/processing-1.4.1.min.js"></script>
    <script src="../_static/jquery.hotkey.js"></script>
    <script src="../_static/jquery-migrate-1.2.1.min.js"></script>
    <script src="../_static/course-errors.js"></script>
    <script src="../_static/petlja.js"></script>
    <script src="../_static/require.js"></script>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
    <meta content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' name='viewport' />
    <link rel="shortcut icon" href="../_static/favicon.ico" type="image/ico" />
    <script type="text/javascript">
      eBookConfig = {};
      eBookConfig.host = 'http://127.0.0.1:8000' ? 'http://127.0.0.1:8000' : 'http://127.0.0.1:8000';
      eBookConfig.app = eBookConfig.host + '/runestone';
      eBookConfig.ajaxURL = eBookConfig.app + '/ajax/';
      eBookConfig.course = 'paradigme';
      eBookConfig.logLevel = '0';
      eBookConfig.loginRequired = 'false';
      eBookConfig.build_info = "";
      eBookConfig.isLoggedIn = false;
      eBookConfig.useRunestoneServices = false;
      eBookConfig.python3 = true;
      eBookConfig.basecourse = 'paradigme';
      eBookConfig.runestone_version = '';
      eBookConfig.imagesDir = '../_images/';
      eBookConfig.staticDir = '../_static/';
      if (typeof (Sk) != "undefined")
        Sk.imgPath = eBookConfig.imagesDir;
    </script>

  </head>

  <body>



<div id="navbar" class="content-header">
  <div class="right-side-nav">
    
    <div id="usefulLinksToggle" class="useful-links-toggle">
        <a class="dropdown-toggle dropdown-toggle-burger" role="button" href="#" id="usefulLinksDropdown" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-bars fa-2x"></i>
        </a>
        <div class="dropdown-menu dropdown-nav-links shadow-lg" aria-labelledby="usefulLinksDropdown" x-placement="bottom-start" style="position: absolute; transform: translate3d(-55px, 32px, 0px); top: 0px; left: 0px; will-change: transform;">
          <div class="links-title"> Корисни линкови</div>
          <div class="useful-link">
            <a href="https://www.sphinx-doc.org/en/master/usage/restructuredtext/index.html" target="_blank">Sphinx Docs</a></div>
          <div class="useful-link">
            <a href="https://github.com/Petlja/PetljaDoc/blob/master/README.md" target="_blank">Petljadoc</a></div>
          <div class="useful-link">
            <a href="https://github.com/RunestoneInteractive/overview" target="_blank">Runestone Interactive</a></div>
          
        </div>
    </div>

    
</div>

<div class="left-side-nav">
  <div class="course-logo-nav">
      <a target="_blank" href="https://petlja.org">
          <img src="../_static/img/petlja-logo-wt.svg" alt="petlja.org" id="lightPetljaLogo">
      </a>
  </div>
  <div class="course-logo-nav-kabinet">
      <a target="_blank" href="https://petlja.org/net.kabinet">
          <img src="../_static/img/netkabinet-logo-strelica-wt.svg" alt="petlja.org" id="lightNetKabinetLogo">
      </a>
  </div>
</div>


<div class="content-header-label" id = "content-header-label" href="../">Shrot description</div>

</div>




<div class="petljaCourseContainer">

<div class="petljaCourseContent">
  
           <div class="tableOfContent">
            <h5> Садржај </h5>
            </div>
           <div>
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-01%20paradigme>
                    <h5>О програмским парадигмама</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../01%20paradigme/01_o_paradigmama.html><div class="studioLecture" id=activity-01_o_paradigmama><i class="fas fa-file-alt activity-icon"></i>О програмским језицима и парадигмама</div></a>
                <a href=../01%20paradigme/02_imperativna.html><div class="studioLecture" id=activity-02_imperativna><i class="fas fa-file-alt activity-icon"></i>Императивна парадигма</div></a>
                </div>
            </div>
                
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-02%20funkcionalna>
                    <h5>Функционална парадигма</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../02%20funkcionalna/01_funkcionalna.html><div class="studioLecture" id=activity-01_funkcionalna><i class="fas fa-file-alt activity-icon"></i>О функционалној парадигми</div></a>
                <a href=../02%20funkcionalna/02_haskell.html><div class="studioLecture" id=activity-02_haskell><i class="fas fa-file-alt activity-icon"></i>Haskell - изрази и функције</div></a>
                <a href=../02%20funkcionalna/02b_haskell_liste.html><div class="studioLecture" id=activity-02b_haskell_liste><i class="fas fa-file-alt activity-icon"></i>Haskell - листе</div></a>
                <a href=../02%20funkcionalna/02c_haskell_tipovi.html><div class="studioLecture" id=activity-02c_haskell_tipovi><i class="fas fa-file-alt activity-icon"></i>Haskell - алгебарски типови података</div></a>
                <a href=../02%20funkcionalna/02z_haskell_vezba.html><div class="studioLecture" id=activity-02z_haskell_vezba><i class="fas fa-file-alt activity-icon"></i>Haskell - задаци за вежбу</div></a>
                </div>
            </div>
                
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-03%20logicka>
                    <h5>Логичка парадигма</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../03%20logicka/01_logicka.html><div class="studioLecture" id=activity-01_logicka><i class="fas fa-file-alt activity-icon"></i>О логичкој парадигми</div></a>
                <a href=../03%20logicka/01_iskazna_logika.html><div class="studioLecture" id=activity-01_iskazna_logika><i class="fas fa-file-alt activity-icon"></i>Исказна логика</div></a>
                <a href=../03%20logicka/02_predikatska_logika.html><div class="studioLecture" id=activity-02_predikatska_logika><i class="fas fa-file-alt activity-icon"></i>Предикатска логика</div></a>
                <a href=../03%20logicka/03_prolog.html><div class="studioLecture" id=activity-03_prolog><i class="fas fa-file-alt activity-icon"></i>PROLOG</div></a>
                </div>
            </div>
                </div>
</div>



<div class="lectureContent">

  <div id="errors">
  </div>
  
  <div class="lectureContentMaterial">
  
    <div id="main-content">
    
  <div class="section" id="id1">
<h1>Алгебарски типови података<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h1>
<p>Поред имплементације алгоритама, програмирање подразумева и дефинисање
структура података. У језику Haskell постоји неколико начина да
дефинишемо нове типове података. Ми ћемо се фокусирати на <strong>алгебарске
типове података</strong> који се дефинишу помоћу кључне речи <code class="docutils literal notranslate"><span class="pre">data</span></code>.</p>
<p>Најједноставнија употреба алгебарских типова је дефинисање набројивих
типова. На пример,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Color</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Red</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Green</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Blue</span><span class="w"></span>
</pre></div>
</div>
<p>Овим смо дефинисали тип <code class="docutils literal notranslate"><span class="pre">Color</span></code> и три константе (<code class="docutils literal notranslate"><span class="pre">Red</span></code>, <code class="docutils literal notranslate"><span class="pre">Green</span></code>
и <code class="docutils literal notranslate"><span class="pre">Blue</span></code>) које су овог типа.</p>
<p>Алгебарске типове можемо користити и за дефинисање структурних типова
података (по узору на <code class="docutils literal notranslate"><span class="pre">struct</span></code> у језику C#). На пример,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Person</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Person</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">name</span><span class="ow">::</span><span class="kt">String</span><span class="p">,</span><span class="w"> </span><span class="n">yearOfBirth</span><span class="ow">::</span><span class="kt">Int</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Овим смо дефинисали тип <code class="docutils literal notranslate"><span class="pre">Person</span></code>. Свака особа има име и годину
рођења. Уз тип смо добили и функцију (тзв. конструктор) <code class="docutils literal notranslate"><span class="pre">Person</span></code>
који прави податак типа <code class="docutils literal notranslate"><span class="pre">Person</span></code> од ниске и броја. На пример,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Person</span><span class="w"> </span><span class="s">&quot;Petar Petrović&quot;</span><span class="w"> </span><span class="mi">2007</span><span class="w"></span>
</pre></div>
</div>
<p>је податак типа <code class="docutils literal notranslate"><span class="pre">Person</span></code> (немојте се збунити тиме што смо име типа и
име конструктора означили исто – на то сте навикли и у
објектнооријентисаним језицима). Имена поља <code class="docutils literal notranslate"><span class="pre">name</span></code> и <code class="docutils literal notranslate"><span class="pre">yearOfBirth</span></code>
се могу користити за јаснију дефиницију података типа <code class="docutils literal notranslate"><span class="pre">Person</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Person</span><span class="w"> </span><span class="p">{</span><span class="n">name</span><span class="ow">=</span><span class="s">&quot;Petar Petrović&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">yearOfBirth</span><span class="ow">=</span><span class="mi">2007</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Имена поља су уједно функције које читају одговарајућа поља. На
пример, <code class="docutils literal notranslate"><span class="pre">name</span></code> је функција типа <code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">::</span> <span class="pre">Person</span> <span class="pre">-&gt;</span> <span class="pre">String</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="p">(</span><span class="kt">Person</span><span class="w"> </span><span class="s">&quot;Petar Petrović&quot;</span><span class="w"> </span><span class="mi">2007</span><span class="p">)</span><span class="w"></span>
<span class="s">&quot;Petar Petrović&quot;</span><span class="w"></span>
</pre></div>
</div>
<p>Имена поља се могу изоставити приликом дефиниције типа:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Person</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Person</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
</pre></div>
</div>
<p>Тип може имати и више конструктора. На пример, особа је или запослена
или је студент.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Person</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">   </span><span class="kt">Employee</span><span class="w"> </span><span class="p">{</span><span class="n">name</span><span class="ow">::</span><span class="kt">String</span><span class="p">,</span><span class="w"> </span><span class="n">salary</span><span class="ow">::</span><span class="kt">Double</span><span class="p">}</span><span class="w"></span>
<span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Student</span><span class="w"> </span><span class="p">{</span><span class="n">name</span><span class="ow">::</span><span class="kt">String</span><span class="p">,</span><span class="w"> </span><span class="n">int</span><span class="ow">::</span><span class="n">year</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Дефинисање функција над алгебарским типовима је обично засновано на
уклапању шаблона по разним конструкторима. На пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">hello</span> <span class="p">::</span> <span class="n">Person</span> <span class="o">-&gt;</span> <span class="n">String</span>
<span class="n">hello</span> <span class="p">(</span><span class="n">Employee</span> <span class="n">name</span> <span class="n">salary</span><span class="p">)</span> <span class="o">=</span> <span class="s2">&quot;Hello, my name is &quot;</span> <span class="o">++</span> <span class="n">name</span>
<span class="n">hello</span> <span class="p">(</span><span class="n">Student</span> <span class="n">name</span> <span class="n">year</span><span class="p">)</span> <span class="o">=</span> <span class="s2">&quot;Hello, I am &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">year</span> <span class="o">++</span> <span class="s2">&quot;. year student&quot;</span>
</pre></div>
</div>
<p>Уклапање шаблона може да се врши и у склопу израза <code class="docutils literal notranslate"><span class="pre">case-of</span></code>. На пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">personType</span> <span class="p">::</span> <span class="n">Person</span> <span class="o">-&gt;</span> <span class="n">String</span>
<span class="n">personType</span> <span class="n">person</span> <span class="o">=</span> <span class="n">case</span> <span class="n">person</span> <span class="n">of</span>
                      <span class="n">Employee</span> <span class="n">_</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="s2">&quot;employee&quot;</span>
                      <span class="n">Student</span> <span class="n">_</span> <span class="n">year</span> <span class="o">-&gt;</span> <span class="n">show</span> <span class="n">year</span> <span class="o">++</span> <span class="s2">&quot;. year student&quot;</span>
</pre></div>
</div>
<p>Наравно, исто је могло бити урађено на једноставнији начин:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">personType</span> <span class="p">::</span> <span class="n">Person</span> <span class="o">-&gt;</span> <span class="n">String</span>
<span class="n">personType</span> <span class="p">(</span><span class="n">Employee</span> <span class="n">_</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="s2">&quot;employee&quot;</span>
<span class="n">personType</span> <span class="p">(</span><span class="n">Student</span> <span class="n">_</span> <span class="n">year</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">show</span> <span class="n">year</span> <span class="o">++</span> <span class="s2">&quot;. year student&quot;</span>
</pre></div>
</div>
<p>Пуна снага алгебарских типова података види се у случају рекурзивних
(каже се и индуктивних) типова података. Листа је основни пример
таквог типа података. Листа је или празна или се добија надовезивањем
елемента на почетак неке листе (репа). Тип листе целих бројева би се
могао дефинисати на следећи начин:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">List</span> <span class="o">=</span>
  <span class="n">Empty</span>
<span class="o">|</span> <span class="n">Cons</span> <span class="n">Int</span> <span class="n">List</span>
</pre></div>
</div>
<p>Листа је или празна (конструктор <code class="docutils literal notranslate"><span class="pre">Empty</span></code>) или се добија
надовезивањем броја на листу (конструктор <code class="docutils literal notranslate"><span class="pre">Cons</span></code>). Пример податка
овог типа је</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cons</span> <span class="mi">1</span> <span class="p">(</span><span class="n">Cons</span> <span class="mi">2</span> <span class="p">(</span><span class="n">Cons</span> <span class="mi">3</span> <span class="n">Empty</span><span class="p">))</span>
</pre></div>
</div>
<p>којим се суштински представља листа <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code>. Функције које
обрађују индуктивне типове података обично су рекурзивне.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span> <span class="p">::</span> <span class="n">List</span> <span class="o">-&gt;</span> <span class="n">Int</span>
<span class="nb">sum</span> <span class="n">Empty</span> <span class="o">=</span> <span class="mi">0</span>
<span class="nb">sum</span> <span class="p">(</span><span class="n">Cons</span> <span class="n">x</span> <span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="nb">sum</span> <span class="n">xs</span>
</pre></div>
</div>
<p>Примећујете велику сличност са рекурзивним функцијама за обраду
уграђених листа (једина разлика је то што се тамо празна листа
обележава са <code class="docutils literal notranslate"><span class="pre">[]</span></code> уместо са <code class="docutils literal notranslate"><span class="pre">Empty</span></code>, а надовезивање са <code class="docutils literal notranslate"><span class="pre">x:xs</span></code>
уместо са <code class="docutils literal notranslate"><span class="pre">Cons</span> <span class="pre">x</span> <span class="pre">xs</span></code>).</p>
<p>У наставку ћемо приказати како је коришћењем индуктивних алгебарских
типова података могуће дефинисати неколико веома корисних структура
података.</p>
<div class="section" id="id2">
<h2>Бинарно дрво<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h2>
<p>Циљ нам је да направимо структуру података којом можемо да
представљамо скупове елемената тако да ефикасно можемо да убацујемо
нове елементе и да проверавамо да ли елементи припадају скупу. Једна
погодна структура података за представљање скупа је бинарно
дрво. Бинарно дрво је рекурзивна структура података која се састоји од
чворова. У чвору је уписана нека вредност (претпоставићемо,
једноставности ради, да је у питању вредност типа <code class="docutils literal notranslate"><span class="pre">Int</span></code>), а лево и
десно се налазе мања дрвета. Излаз из ове рекурзије представља празно
дрво које нема ни вредност ни наследнике. Тип података за представљање
дрвета може бити дефинисан на следећи начин:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">   </span><span class="kt">Empty</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">   </span><span class="kt">Node</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Tree</span><span class="w"></span>
</pre></div>
</div>
<p>Дрво је, дакле, или празно (<code class="docutils literal notranslate"><span class="pre">Empty</span></code>) или је у питању чвор који
садржи три податка: лево поддрво, вредност типа <code class="docutils literal notranslate"><span class="pre">int</span></code> и десно
поддрво.</p>
<p>Сада можемо лако да формирамо изразе чији је тип <code class="docutils literal notranslate"><span class="pre">Tree</span></code>. На пример</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Node</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="kt">Empty</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="kt">Empty</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>Нажалост, приликом њиховог уноса у интерпретатор добићемо поруку да
систем не уме да прикаже дрво. Најједноставнији начин да се то реши је
да се аутоматски генеришу функције за приказ дрвета, што се постиже
тиме што се након дефиниције типа дода <code class="docutils literal notranslate"><span class="pre">deriving</span> <span class="pre">Show</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">   </span><span class="kt">Empty</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">   </span><span class="kt">Node</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">Tree</span><span class="w"></span>
<span class="w">   </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">Show</span><span class="w"></span>
</pre></div>
</div>
<p>За представљање скупа ми ћемо користити уређена тј. претраживачка
дрвета (енгл. binary search tree). Основна њихова особина је да сваки
чвор задовољава особину да се у левом поддрвету налазе вредности које
су мање или једнаке од вредности у том чвору, а у десном поддрвету
вредности које су веће или једнаке од вредности у том чвору. Ако не
желимо дупликате (а скуп обично не садржи дупликате), онда захтевамо
да важе стриктне неједнакости (лево су строго мањи, а десно строго
већи елементи од оног уписаног у чвору). На основу овога можемо
дефинисати рекурзивну функцију за уметање елемента у дрво. Она прима
дрво и вредност која се умеће и враћа ново дрво. Приметимо да се већи
део полазног дрвета задржава, тако да овај приступ није меморијски
превише захтеван (пошто се у функционалном програмирању обично не врши
модификација података, они могу бити дељени, без копирања).</p>
<p>Уметање вредности у право дрво даје дрво коме је та вредност у корену,
а лево и десно су празна поддрвета.  Уметање у непразно дрво
подразумева поређење вредности <code class="docutils literal notranslate"><span class="pre">x</span></code> која се умеће са вредношћу
уписаном у корен дрвета.  Ако је <code class="docutils literal notranslate"><span class="pre">x</span></code> мање од корена, врши се
рекурзивно убацивање у лево поддрво (вредност у корену и десно поддрво
остају неизмењени), ако је већа врши се рекурзивно убацивање у десно
поддрво (вредност у корену и лево поддрво остају неизмењени), а ако је
једнака вредности у корену онда се цело дрво враћа неизмењено (не
желимо да убацујемо дупликате).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">insert</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"></span>
<span class="nf">insert</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">Empty</span><span class="w"></span>
<span class="nf">insert</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">root</span><span class="w">  </span><span class="ow">=</span><span class="w">  </span><span class="kt">Node</span><span class="w"> </span><span class="p">(</span><span class="n">insert</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">right</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">root</span><span class="w">  </span><span class="ow">=</span><span class="w">  </span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="p">(</span><span class="n">insert</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w">  </span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">right</span><span class="w"></span>
</pre></div>
</div>
<p>Понављањем ове функције лако можемо да формирамо дрво од листе
бројева. Тај поступак можемо имплементирати кроз функцију која формира
дрво од елемената листе.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">treeOfList</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"></span>
<span class="nf">treeOfList</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="n">insert</span><span class="w"> </span><span class="kt">Empty</span><span class="w"></span>
</pre></div>
</div>
<p>Сложеност функције <code class="docutils literal notranslate"><span class="pre">insert</span></code> и <code class="docutils literal notranslate"><span class="pre">treeOfList</span></code> зависи од распореда
чворова дрвета. У најгорем случају, када је листа од које се формира
дрво сортирана, сви чворови ће завршити на једној страни (увек ће лево
или ће увек десно поддрво бити празно, у зависности од тога како је
листа сортирана). Тада је сложеност функције <code class="docutils literal notranslate"><span class="pre">insert</span></code> линеарна, а
функције <code class="docutils literal notranslate"><span class="pre">treeOfList</span></code> квадратна. Ипак, ако су елементи који се
убацују у дрво насумични, можемо очекивати да ће дрво бити прилично
балансирано (да ће број чворова са леве и са десне стране сваког чвора
бити отприлике једнак) и тада ће висина дрвета логаритамски зависити
од броја чворова дрвета, па ће сложеност функције <code class="docutils literal notranslate"><span class="pre">insert</span></code> бити
<span class="math notranslate nohighlight">\(O(\log n)\)</span>, а сложеност функције <code class="docutils literal notranslate"><span class="pre">treeOfList</span></code> бити <span class="math notranslate nohighlight">\(O(n
\log n)\)</span>.</p>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>Уместо обичних претраживачких дрвета могуће је користити и
тзв. самобалансирајућа дрвета. Најпознатије врсте таквих дрвета су
<strong>АВЛ</strong> дрвета и <strong>Црвено-црна дрвета</strong>. Алгоритам уметања у ова
дрвета је такав да се приликом уметања проверава да ли је нарушена
равнотежа између левог и десног дела и ако јесте, дрво се ротира
тако да би се та равнотежа поново успоставила.</p>

    </div></div>
<p>Када је формирано дрво, тада можемо вршити његову претрагу тј. можемо
имплементирати функцију која проверава да ли дрво садржи дати елемент.
Празно дрво не садржи ни један елемент. Непразно дрво претражујемо
тако што елемент који тражимо поредиом са вредношћу у корену. Ако је
вредност мања од корена, тражимо је рекурзивно у левом поддрвету, ако
већа у десном, а ако је једнака вредности у корену, онда знамо да дрво
садржи тражену вредност.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">contains</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">contains</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span><span class="w"></span>
<span class="nf">contains</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">root</span><span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="n">contains</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">root</span><span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="n">contains</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
</pre></div>
</div>
<p>У уређеном дрвету је лако пронаћи минимални и максимални елемент (они
се налазе у крајње левом и крајње десном чвору).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">minTree</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">minTree</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="nf">minTree</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">minTree</span><span class="w"> </span><span class="n">left</span><span class="w"></span>
</pre></div>
</div>
<p>Дефинишимо и функцију која уклања тај најмањи елемент дрвета (под
претпоставком да је дрво непразно). Функција враћа урећен пар који се
састоји од укоњене вредности и измењеног дрвета. Ако не постоји лево
поддрво корен дрвета је најмањи елемент, а његовим брисањем остаје
само десно поддрво. У супротном бришемо најмањи елемент левог
поддрвета.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">deleteMin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">Tree</span><span class="p">)</span><span class="w"></span>
<span class="nf">deleteMin</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"></span>
<span class="nf">deleteMin</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">left&#39;</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">deleteMin</span><span class="w"> </span><span class="n">left</span><span class="w"></span>
<span class="w">                                  </span><span class="kr">in</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">left&#39;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Ова се функција може искористити и за уклањање дате вредности из скупа
(тј. дрвета). Брисањем било чега из празног дрвета дрво остаје празно.
Ако је дрво непразно, а вредност која се брише мања од корена,
рекурзивно се та вредност брише из левог поддрвета. Ако је вредност
већа од корена, рекурзивно се та вредност брише из десног поддрвета.
Најкомпликованији је случај када је вредност која се брише једнака
вредности у корену. Ако је тада десно поддрво празно, можемо само
вратити лево поддрво. У супротном можемо обрисати најмању вредност из
десног поддрвета и њу ставити на место корена (аналогно бисмо могли
обрисати највећу вредност из левог поддрвета и њу ставити на место
корена). Да бисмо анализирали да ли је десно поддрво празно или
непразно можемо употребити израз <code class="docutils literal notranslate"><span class="pre">case-of</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">delete</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"></span>
<span class="nf">delete</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Empty</span><span class="w"></span>
<span class="nf">delete</span><span class="w"> </span><span class="n">x&#39;</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">x&#39;</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">x</span><span class="w">      </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="p">(</span><span class="n">delete</span><span class="w"> </span><span class="n">x&#39;</span><span class="w"> </span><span class="n">left</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">right</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">x&#39;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="w">      </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">delete</span><span class="w"> </span><span class="n">x&#39;</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">left</span><span class="w"></span>
<span class="w">                             </span><span class="kr">_</span><span class="w">     </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">right&#39;</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">deleteMin</span><span class="w"> </span><span class="n">right</span><span class="w"></span>
<span class="w">                                       </span><span class="kr">in</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">right&#39;</span><span class="w"></span>
</pre></div>
</div>
<p>Од елемената дрвета можемо формирати листу. Ако прво покупимо елементе
из левог поддрвета, затим корен, па затим елементе из десног
поддрвета, захваљујући уређености дрвета, добијена листа ће бити
сортирана. На тај начин добијамо још један алгоритам сортирања
(енгл. tree sort).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">listOfTree</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w"></span>
<span class="nf">listOfTree</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
<span class="nf">listOfTree</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">   </span><span class="n">listOfTree</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">listOfTree</span><span class="w"> </span><span class="n">right</span><span class="w"></span>

<span class="nf">treeSort</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w"></span>
<span class="w">   </span><span class="n">treeSort</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">listOfTree</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">treeOfList</span><span class="w"></span>
</pre></div>
</div>
<p>У дрвету које смо дефинисали налазе се увек подаци типа <code class="docutils literal notranslate"><span class="pre">Int</span></code>,
међутим, јасно је да би се на исти начин могли чувати и подаци других
типова. Могуће је дефинисати и дрво којем је тип података записаних у
чвору параметар (навикли сте на овакве „генеричке” типове у језику C#
где сте користили типове попут <code class="docutils literal notranslate"><span class="pre">List&lt;int&gt;</span></code> где је тип елемената
колекције задат као параметарски тип те колекције).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">   </span><span class="kt">Empty</span><span class="w"></span>
<span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="p">(</span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="kr">deriving</span><span class="w"> </span><span class="kt">Show</span><span class="w"></span>
</pre></div>
</div>
<p>У овом случају тип означен са <code class="docutils literal notranslate"><span class="pre">a</span></code> је параметар типа дрво. Дрво
садржи лево и десно поддрво (која такође имају елементе типа <code class="docutils literal notranslate"><span class="pre">a</span></code>) и
вредност типа <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>Да бисмо могли формирати претраживачко дрво, тип <code class="docutils literal notranslate"><span class="pre">a</span></code> мора да подржи
поређење елемената тј. мора бити класе <code class="docutils literal notranslate"><span class="pre">Ord</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">insert</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Tree</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">insert</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="kt">Empty</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">Empty</span><span class="w"></span>
<span class="nf">insert</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">root</span><span class="w">  </span><span class="ow">=</span><span class="w">  </span><span class="kt">Node</span><span class="w"> </span><span class="p">(</span><span class="n">insert</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">right</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">root</span><span class="w">  </span><span class="ow">=</span><span class="w">  </span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="p">(</span><span class="n">insert</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w">  </span><span class="kt">Node</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">right</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>Ред<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h2>
<p>Листа једноставно може да се користи као стек. Елементи могу да се
додају са почетка и скидају са почетка листе у линеарној сложености.
Међутим, ред је мало компликованије имплементирати (наравно, постоје
библиотечке имплементације, али ћемо га овде, вежбе ради,
имплементирати ручно).</p>
<p>Додавање елемената на крај листе има линеарну сложеност, па ред није
добро имплементирати помоћу листе. Уобичајени начин имплементације
реда у функционалнм језицима је тзв. амортизовани ред (енгл. amortized
queue) који се састоји од две листе.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>У празном реду су обе листе празне.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">emptyQueue</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">emptyQueue</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
</pre></div>
</div>
<p>Елементи се увек додају на почетак прве листе, а скидају са почетка друге.</p>
<p>Операцију додавања елемента у ред је тривијално имплементирати.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">push</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">push</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="kt">Queue</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">left</span><span class="p">)</span><span class="w"> </span><span class="n">right</span><span class="w"></span>
</pre></div>
</div>
<p>Уклањање елемента из реда је мало компликованије. Функцију ћемо
дефинисати тако да врати уклоњени елемент и нови ред. Пошто уклањање
из празног реда није могуће, уместо да функција враћа пар типа <code class="docutils literal notranslate"><span class="pre">(a,</span>
<span class="pre">Queue</span> <span class="pre">a)</span></code>, она ће враћати пар типа <code class="docutils literal notranslate"><span class="pre">(Maybe</span> <span class="pre">a,</span> <span class="pre">Queue</span> <span class="pre">a)</span></code>. Тип
<code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code> омогућава представљање опционих вредности типа <code class="docutils literal notranslate"><span class="pre">a</span></code>, при
чему конструктор <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> означава недостајућу вредност, а <code class="docutils literal notranslate"><span class="pre">Just</span></code>
нормалну вредност. На пример, ако функција успе и треба да врати
вредност <code class="docutils literal notranslate"><span class="pre">3</span></code>, она ће вратити вредност <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">3</span></code>, а ако не успе она
ће вратити вредност <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> (ово одговара вредности <code class="docutils literal notranslate"><span class="pre">null</span></code> у
програмском језику C#, која служи да означи недостатак исправне
вредности). Aко је цео ред празан, наша функција <code class="docutils literal notranslate"><span class="pre">pop</span></code> враћа
<code class="docutils literal notranslate"><span class="pre">Nothing</span></code> и празан ред. Ако десна листа није празна, враћамо њен
први елемент (упакован у конструктор <code class="docutils literal notranslate"><span class="pre">Just</span></code>), док ред мењамо тако да
му лева листа остаје неизмењена, а десна скраћена за њен почетни
елемент. Ако је само десна листа празна, тада обрћемо леву листу и
пребацујемо је на десну страну и затим уклањамо први елемент тако
добијене листе.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pop</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">Maybe</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="nf">pop</span><span class="w"> </span><span class="p">(</span><span class="kt">Queue</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="kt">[]</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Nothing</span><span class="p">,</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="kt">[]</span><span class="p">)</span><span class="w"></span>
<span class="nf">pop</span><span class="w"> </span><span class="p">(</span><span class="kt">Queue</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"></span>
<span class="nf">pop</span><span class="w"> </span><span class="p">(</span><span class="kt">Queue</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="kt">[]</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">reverse</span><span class="w"> </span><span class="n">left</span><span class="w"></span>
<span class="w">                       </span><span class="kr">in</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Сложеност најгорег случаја операције <code class="docutils literal notranslate"><span class="pre">pop</span></code> је линеарна, јер је
функција <code class="docutils literal notranslate"><span class="pre">reverse</span></code> линеарне сложености. Ипак, након једног
пребацивања елемената са леве на десну страну, пуно наредних операција
<code class="docutils literal notranslate"><span class="pre">pop</span></code> ће бити могуће извршити веома брзо. Ако анализирамо пут сваког
елемента кроз ред видимо да ће он једном бити додат на почетак леве
листе, једном бити склоњен са почетка леве и додат на почетак десне
листе (ово се догађа током извршавања функције <code class="docutils literal notranslate"><span class="pre">reverse</span></code>) и на крају
једном скинут са десне листе. Дакле, сваки елемент учествује у тачно 4
операције константне сложености, па се <span class="math notranslate nohighlight">\(n\)</span> елемената реда може
обрадити у сложености <span class="math notranslate nohighlight">\(O(n)\)</span>, што значи да операције додавања и
уклањања елемената имају константну амортизовану сложеност.</p>
<p>Да бисмо могли да експериментишемо са овом структуром података,
пожељно је да можемо да је испишемо. Аутоматски генерисана функција
исписа (коју можемо добити ако након дефиниције типа ставимо
<code class="docutils literal notranslate"><span class="pre">deriving</span> <span class="pre">Show</span></code>) приказује одвојено обе листе. Ако желимо да
прикажемо садржај елемената реда у једној листи (дакле, онако како га
замишљамо, а не какоко је имплементирам), можемо дефинисати своју
функцију приказа. То радимо на следећи начин.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Show</span><span class="w"> </span><span class="p">(</span><span class="kt">Queue</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w"></span>
<span class="w">   </span><span class="n">show</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Queue</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"></span>
<span class="w">   </span><span class="n">show</span><span class="w"> </span><span class="p">(</span><span class="kt">Queue</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="p">(</span><span class="n">right</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">reverse</span><span class="w"> </span><span class="n">left</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Овим смо рекли да тип <code class="docutils literal notranslate"><span class="pre">Queue</span> <span class="pre">a</span></code> припада класи <code class="docutils literal notranslate"><span class="pre">Show</span></code> тј. може да
се прикаже (део <code class="docutils literal notranslate"><span class="pre">Show</span> <span class="pre">(Queue</span> <span class="pre">a)</span></code>), под условом да тип <code class="docutils literal notranslate"><span class="pre">а</span></code> припада
класи <code class="docutils literal notranslate"><span class="pre">Show</span></code> тј. може да се прикаже (део <code class="docutils literal notranslate"><span class="pre">Show</span> <span class="pre">a</span> <span class="pre">=&gt;</span></code>). Затим
дефнишемо функцију <code class="docutils literal notranslate"><span class="pre">show</span></code> која дати ред представља у облику ниске
карактера. Ниску добијамо тако што спојимо десну и обрнуту леву листу
(тиме је елемент који је први на реду за скидање приказан на
почетку). Приметите да ту листу претварамо у ниску позивом функције
<code class="docutils literal notranslate"><span class="pre">show</span></code>, међутим, ово није рекурзивни позив јер је позвана функција
<code class="docutils literal notranslate"><span class="pre">show</span></code> другог типа (она претвара листу, а не ред у ниску карактера).</p>
</div>
<div class="section" id="id4">
<h2>Вежба - алгебарски типови података<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h2>
<p>Као вежбу алгебарских типова података имплементирајмо структуру
података речник.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати тип података за представљање речника (мапе) елемената
типа <code class="docutils literal notranslate"><span class="pre">k</span></code> у елементе типа <code class="docutils literal notranslate"><span class="pre">v</span></code>. Речник треба да буде реализован
помоћу уређеног бинарног дрвета.</p>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w">  </span><span class="kt">Null</span><span class="w"></span>
<span class="w">              </span><span class="o">|</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">(</span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">Show</span><span class="w"></span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати функцију која проверава да ли је речник празан.</p>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">empty</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">empty</span><span class="w"> </span><span class="kt">Null</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
<span class="nf">empty</span><span class="w"> </span><span class="kr">_</span><span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span><span class="w"></span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати функције за уметање тј. ажурирање вредности у речнику.</p>
<ul class="simple">
<li><p>Дефинисати прво функцију <code class="docutils literal notranslate"><span class="pre">insertWithKey</span></code> која датом кључу
придружује дату вредност ако тај кључ већ не постоји у раченику,
а ако постоји онда му придружује нову вредност применом задате
функције на тај кључ, стару вредност и нову вредност.</p></li>
<li><p>Коришћењем претходне функције дефинисати затим функцију
<code class="docutils literal notranslate"><span class="pre">insert</span></code> која датом кључу придружује дату вредност (ако кључ
већ постоји у речнику, стара вредност се занемарује).</p></li>
</ul>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">insertWithKey</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
<span class="nf">insertWithKey</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kt">Null</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kt">Null</span><span class="w"> </span><span class="kt">Null</span><span class="w"></span>
<span class="nf">insertWithKey</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">k&#39;</span><span class="w"> </span><span class="n">v&#39;</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">k&#39;</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k&#39;</span><span class="w"> </span><span class="n">v&#39;</span><span class="w"> </span><span class="p">(</span><span class="n">insertWithKey</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="n">r</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">k&#39;</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k&#39;</span><span class="w"> </span><span class="n">v&#39;</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">(</span><span class="n">insertWithKey</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">k&#39;</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k&#39;</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v&#39;</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="w"></span>

<span class="nf">insert</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
<span class="nf">insert</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">insertWith</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">v&#39;</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v&#39;</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати функцију која листу парова (кључ, вредност) претвара у
речник.</p>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fromList</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
<span class="nf">fromList</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">insert</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="kt">Null</span><span class="w"></span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати функцију <code class="docutils literal notranslate"><span class="pre">find</span></code> која проналази вредност придружену
датом кључу у речнику. Резултат треба да буде типа <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">v</span></code>, што
значи да треба да буде <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> ако кључ не постоји у речнику
тј. <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">v</span></code> ako je кључу придружена вредност <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<p>Коришћењем функције <code class="docutils literal notranslate"><span class="pre">find</span></code> дефинисати функцију
<code class="docutils literal notranslate"><span class="pre">findWithDefault</span></code> која враћа вредност придружену датом кључу или
задату подразумевану вредност ако кључ не постоји у речнику.</p>
<p>Коришћењем функције <code class="docutils literal notranslate"><span class="pre">find</span></code> дефинисати функцију <code class="docutils literal notranslate"><span class="pre">containsKey</span></code>
која за дату мапу враћа функцију која проверава да ли кључ постоји
у речнку.</p>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">find</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
<span class="nf">find</span><span class="w"> </span><span class="kt">Null</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"></span>
<span class="nf">find</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="n">k&#39;</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">k&#39;</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">k</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">find</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">k&#39;</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">k&#39;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">k</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">find</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">k&#39;</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">k&#39;</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="n">v</span><span class="w"></span>

<span class="nf">findWithDefault</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
<span class="nf">findWithDefault</span><span class="w"> </span><span class="n">dflt</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">find</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">dflt</span><span class="w"></span>
<span class="w">                                            </span><span class="kt">Just</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"></span>

<span class="nf">containsKey</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)</span><span class="w"></span>
<span class="nf">containsKey</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">search</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">False</span><span class="w"></span>
<span class="w">                                     </span><span class="kt">Just</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати функцију <code class="docutils literal notranslate"><span class="pre">adjustWithKey</span></code> која мења вредност датом
кључу тако што нову вреднос одређује применом дате функције на кључ
и стару вредност.</p>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">adjustWithKey</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
<span class="nf">adjustWithKey</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="kt">Null</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Null</span><span class="w"></span>
<span class="nf">adjustWithKey</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">k&#39;</span><span class="w"> </span><span class="n">v&#39;</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">k&#39;</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k&#39;</span><span class="w"> </span><span class="n">v&#39;</span><span class="w"> </span><span class="p">(</span><span class="n">adjustWithKey</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="n">r</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">k&#39;</span><span class="w">   </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k&#39;</span><span class="w"> </span><span class="n">v&#39;</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">(</span><span class="n">adjustWithKey</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">k&#39;</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k&#39;</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v&#39;</span><span class="p">)</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="w"></span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати функцију која уклања најмањи кључ из речника.</p>
<p>Дефиниасти затим функцију која уклања дати кључ из речника.</p>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">deleteMin</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">),</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<span class="nf">deleteMin</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="kt">Null</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"></span>
<span class="nf">deleteMin</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="p">((</span><span class="n">k&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">v&#39;</span><span class="p">),</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">deleteMin</span><span class="w"> </span><span class="n">l</span><span class="w"></span>
<span class="w">                            </span><span class="kr">in</span><span class="w"> </span><span class="p">((</span><span class="n">k&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">v&#39;</span><span class="p">),</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"></span>

<span class="nf">delete</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
<span class="nf">delete</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="kt">Null</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Null</span><span class="w"></span>
<span class="nf">delete</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">k&#39;</span><span class="w"> </span><span class="n">v&#39;</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"></span>
<span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">k&#39;</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k&#39;</span><span class="w"> </span><span class="n">v&#39;</span><span class="w"> </span><span class="p">(</span><span class="n">delete</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="n">r</span><span class="w"></span>
<span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">k&#39;</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k&#39;</span><span class="w"> </span><span class="n">v&#39;</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">(</span><span class="n">delete</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"></span>
<span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">k&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="kt">Null</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">l</span><span class="w"></span>
<span class="w">                       </span><span class="kr">_</span><span class="w">    </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="p">((</span><span class="n">k&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">v&#39;</span><span class="p">),</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">deleteMin</span><span class="w"> </span><span class="n">r</span><span class="w"></span>
<span class="w">                                </span><span class="kr">in</span><span class="w"> </span><span class="kt">Node</span><span class="w"> </span><span class="n">k&#39;</span><span class="w"> </span><span class="n">v&#39;</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">d</span><span class="w"></span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати функционал <code class="docutils literal notranslate"><span class="pre">fold</span></code> за речник. Он као први аргумент
прима функцију која на основу претходног резултата, кључа и
вредности придружене кључу ажурира резултат, као други аргумент
прима почетну вредност резултата, а као трећи аргумент прима
речник.</p>
<p>Коришћењем тако дефинисаног функционала <code class="docutils literal notranslate"><span class="pre">fold</span></code> дефинисати
функцију <code class="docutils literal notranslate"><span class="pre">size</span></code> која израчунава величину речника (број кључева у
речнику), затим функцију <code class="docutils literal notranslate"><span class="pre">toList</span></code> која креира листу парова (кључ,
вредност) из речника, сортирану по кључевима и на крају функцију
<code class="docutils literal notranslate"><span class="pre">union</span></code> која прави унију два речника (ако кључ постоји у оба
речника потребно је придружити му вредност из другог.</p>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foldMap</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">foldMap</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="kt">Null</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">i</span><span class="w"></span>
<span class="nf">foldMap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">(</span><span class="kt">Node</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">  </span><span class="n">foldlMap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">foldlMap</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="n">r</span><span class="w"></span>

<span class="nf">size</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">size</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldMap</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>

<span class="nf">toList</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)]</span><span class="w"></span>
<span class="nf">toList</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">reverse</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">foldlMap</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>

<span class="nf">union</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Map</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"></span>
<span class="nf">union</span><span class="w"> </span><span class="n">m1</span><span class="w"> </span><span class="n">m2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldlMap</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">insert</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="n">m1</span><span class="w"> </span><span class="n">m2</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>


    </div>
    
    <div>
<div class="lecture-prev-next-toggle">
  <a  href="02b_haskell_liste.html" id="prevLectureLink" class="lecture-toggler-arrows"><i class="fas fa-arrow-left fa"></i> <span> Претходна лекција </span> </a>
  
  <a id="nextLectureLink" class="lecture-toggler-arrows"><span> Следећа лекција</span>  <i class="fas fa-arrow-right fa"></i> </a>
</div>

<script type="text/javascript">
  $('#relations-prev').tooltip({'placement':'right', 'selector': '', 'delay': { show: 100, hide: 50}});
  $('#relations-next').tooltip({'placement':'left', 'selector': '', 'delay': { show: 100, hide: 50}});
</script>
</div>

    
  </div>
</div>

<div class="petljadoc-resources">
  <span class="pull-left">(Created using  <a href="https://pypi.org/project/Sphinx/">Swinx</a>, <a href="http://runestoneinteractive.org/">RunestoneComponents</a> and <a href="https://github.com/Petlja/PetljaDoc">PetljaDoc</a>) <br> © 2022 Petlja</span>
</div>


<div class="lectureToolbox">

  <label class="font-size-toggle" id="fontSizeToggle">

      <i class="fas fa-font"></i><label>Слова</label>
  </label>
  <div class="font-change d-none" id="fontChangeModal">
      <span class="dec-letter-icon" id="decLetterIcon">A-</span>
      <label id="currentFontSize">16</label>
      <span class="inc-letter-icon" id="incLetterIcon">A+</span>
  </div>
</div>

</div>

  </body>
</html>