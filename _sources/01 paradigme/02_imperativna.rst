Императивна парадигма
=====================

Императивна парадигма је најстарија парадигма и тесно је везана за
начин функционисања хардвера. Императивни програми се састоје из
**наредби** којима се рачунару задаје како да измени податке који су
смештени у меморији рачунара. Сви машински и асемблерски језици су
императивни (при чему су наредбе тамо заправо инструкције којима се
процесору задаје како да податке обради).

Кључан појам при извршавању сваког императивног програма је његово
текуће **стање** које је одређено променљивама које тај програм
користи и које се мења током извршавања програма (кажемо да је стање
**мутабилно**). Основна наредба којом се мења стање програма је
**наредба доделе**, којом се променљивој додељује вредност. Поред
наредбе доделе користе се наредбе за контролу тока: гранање
(нпр. наредба ``if``) и петље (нпр. наредбе ``while`` и ``for``). У
изградњи наредби користе се **изрази** (на пример, изрази се наводе са
десне стране наредбе доделе и у условима петљи и наредби
гранања). Алгоритам се описује низом наредби које рачунар извршава
секвенцијално, једну за другом (при чему гранање и петље дефинишу
другачију контролу тока).

На пример, размотримо нареди фрагмент императивног кода у језику C#:

.. code-block:: csharp

   int x = 3;
   int n = 4;
   int i = 0;
   int stepen = 1;
   while (i < n) {
       stepen = stepen * x;
       i = i + 1;
   }

У њему учествују 4 променљиве (``x``, ``n``, ``i`` и ``stepen``). На
почетку програма врши се њихова иницијализација и пре уласка у петљу
вредности ових променљивих су редом 3, 4, 0 и 1. Током петље стање
програма се мења на следећи начин:

+-----+-----+-----+--------+
|  x  |  n  |  i  | stepen |
+=====+=====+=====+========+
|  3  |  4  |  0  |   1    |
+-----+-----+-----+--------+
|  3  |  4  |  1  |   3    |
+-----+-----+-----+--------+
|  3  |  4  |  2  |   9    |
+-----+-----+-----+--------+
|  3  |  4  |  3  |   27   |
+-----+-----+-----+--------+
|  3  |  4  |  4  |   81   |
+-----+-----+-----+--------+

Промена вредности променљиве је специфична особина императивних
програма и не среће се у математици. Почетнике често збуњује наредба
доделе ``i = i + 1;``, јер је тумаче као математичку једначину, што,
наравно, нема смисла. Семантика ове наредбе је *променљивој i
треба доделити вредност која је за један већа од тренутне вредности
променљиве i*.

Основна техника изражавања алгоритама је **итерација** која
подразумева да се до коначне вредности долази тако што се мало по мало
ажурира вредност неке променљиве (као што је у претходном примеру
вредност променљиве ``stepen`` ажурирана мало по мало, све док није
достигла жељену вредност 81). Итерација се остварује уз помоћ петљи и
често се појам итерације поистовећује са петљама (додуше, ако је
унапред познато колико пута је потребно променити вредност неке
променљиве, итерацију је могуће извршити и без петљи).

Наредба доделе јесте главни, али није и једини начин да се промени
вредност неке променљиве тј. стање програма. На пример, оператори
``++`` и ``--`` у програмском језику C# увећавају тј. умањују вредност
променљиве за 1. Кажемо да ти оператори имају **бочне ефекте** (можемо
рећи и *пропратне ефекте* или *споредне ефекте*, енгл. side
effect). Бочни ефекат могу имати и функције које приликом позива
мењају вредности неких глобалних променљивих.

Основно стање програма заиста сачињава вредност његових променљивих,
међутим, сви програми врше и неку интеракцију са улазно-излазним
уређајима (исписују или исцртавају нешто на екран, реагују на тастере
тастатуре или померање миша и слично, записују нешто у датотеку или
читају нешто из датотеке, комуницирају преко мреже и слично). И за
функције које врше овакве интеракције се такође каже да имају бочне
ефекте.

Структурирано програмирање
--------------------------

Процесор контролу тока програма остварује помоћу условних и
безусловних скокова. Наредбе у програму могу бити означене
тзв. лабелама и постоје инструкције којима се задаје скок на неку
лабелу (што значи да извршавање програма треба да се настави од
инструкције на задатој лабели) и инструкције којима се задаје скок на
неку лабелу под неким условом (ако тај услов није испуњен, онда се
програм наставља нормалним током, од инструкције која се налази иза
инструкције скока). На пример:

.. code-block:: asm

      mov eax, 5
   pocetak:
      cmp eax, 0
      je kraj
      dec eax
      jmp pocetak
   kraj:
      call print

У претходном асемблерском програму је реализована једна једноставна
петља. У првој инструкцији уписује се вредност 5 у регистар ``eax``.
У наредној се помоћу инструкције ``cmp`` пореди вредност у регистру
``eax`` са 0. Затим следи условни скок на крај петље где се налази
инструкција којом се позива функција исписа. Инструкција ``je`` врши
скок, ако је у претходном поређењу откривена једнакост. Дакле, ако у
``eax`` јесте вредност 0, скаче се на крај петље, а ако није, наставља
се са следећом инструкцијом у петљи, а то је ``dec eax`` којом се
вредност у регистру ``eax`` умањује за 1. Након тога следи инструкција
безусловног скока ``jmp`` којом се контрола тока враћа на почетак наше
петље. Дакле, у телу петље се вредност у регистру ``eax`` смањује за 1
све док не дође до нуле, када се искаче из тела петље. У савременом
програмском језику овај алгоритам би се записао као

.. code-block:: csharp

   int x = 5;
   while (x != 0)
       x--;
   print(x);

Под утицајем хардвера тј. асемберских језика који директно осликавају
процесорске инструкције рани виши програмски језици имали су наредбу
скока која је обично називана GOTO. Она је била веома карактеристична
за језике попут језика FORTRAN и BASIC. Претходна петља би се у језику
BASIC могла записати овако.

.. code-block:: basic

   10 X = 5
   20 IF X = 0 THEN GOTO 50
   30 X = X - 1
   40 GOTO 20
   50 PRINT(X)

Свака наредба има свој број и наредбом GOTO врши се скок на наредбу са
задатим бројем.

Парадигма у којој се наредбе извршавају секвенцијално, једна за
другом, а ток програма се меља наредбом скока (GOTO) назива се понекад
**композитна парадигма**.

Иако је овакав стил програмирања успешно коришћен у раном развоју
рачунарства, врло брзо је уочено да су програми који користе наредбу
GOTO могу да постану веома тешки за разумевање и одржавање. Из овог
доба долазе и чувени дијаграми тока програма на којима се графички
приказују скокови и везе измећу наредби. У компликованијим програмима
наредбе скока толико "запетљају" контролу тока, да су такви програми
шаљиво називани "шпагети" програми. Долази до тзв. "софтверске кризе",
што је термин у ком се описује период када због лоше методологије није
могуће довољно брзо развити софтвер који би искористио све расположиве
могућности савременог хардвера тј. када развој софтвера значајно
заостаје за развојем хардвера. Криза током 1960-их је прва софтверска
криза. Чувени информатичар Дајкстра је
1968. објавио чланак `GOTO statement considered harmful
<https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf>`_. у
ком је критиковао коришћење наредбе GOTO. Још пре тога Бем и Јакопини
су показали да се наредба GOTO може изоставити из програмских језика
ако програмски језици подржавају следећа три типа наредби за контролу
тока:

1. секвенцијално извршавање наредби, једну за другом
2. наредбу гранања
3. наредбу понављања (петљу)

И један тип петље у комбинацији са наредбом гранања је довољно
изражајан да одмени произвољан ток изражен помоћу скокова тј. наредбе
GOTO. Ипак, с временом се усталило да програмски језици обично имају
три типа петљи: бројачку петљу у којој променљива редом узима
вредности неког правилног скупа бројева (петља ``for``), условну петљу
с провером услова на почетку (петља ``while``) и условну петљу с
провером услова на крају (петља ``do-while``). Информатичари
инсистирају на томе да се "структура програма" (данас кажемо контрола
тока) одређује без коришћења скокова, само коришћењем гранања и петљи
(тј. фиксног броја "програмских структура", како је то тада називано).
Тако се долази до парадигме која је названа **структурирано
програмирање**. Теоријску основу структурног програмирања даје
поменута теорема Бема и Јакопинија. Појављују се и програмски језици
који подржавају ову дисциплину (пре свега Pascal, па затим и
C). Структурирано програмирање уноси дисциплину и доводи до побољшања
квалитета програма (програми се лакше разумеју и одржавају) и данас се
у свим императивним програмским језицима инсистира на дисциплини
структурираног програмирања. Наредба GOTO у данашњим језицима или
уопште не постоји или се јако ретко користи (можда једини "оправдани"
случај коришћења GOTO може бити ситуација у којој се жели прекид
неколико угнежђених петљи). Ако програм уопште нема скокова, тада
сваки блок наредби има тачно једну улазну и једну излазну тачку, што
знатно олакшава анализу програма.

И у структурираном програмирању неки програмски језици уводе две
посебне наредбе које донекле одговарају наредбама скока. То су наредба
``break`` којом се безусловно врши прекид петље и наредба ``continue``
којом се врши прекид тренутног корака (тренутне итерације) у
петљи. Слично, и наредба ``return`` може довести до прекида петље
током њеног извршавања. Иако су неки аутори сматрали да и ове наредбе,
слично осталим наредбама скока доприносе конфузији и компликују
програме, с временом се показало да ако се оне користе у разумној
мери, програми остају читљиви и разумљиви, тако да се у савременом
програмирању оне користе.

.. infonote::

   Овде видимо први "сукоб" између доследног држања парадигме и
   потреба практичног програмирања. Теоретичари обично инсистирају на
   "чистом" коду који се остварује тиме што се стриктно увек држимо
   принципа које нека парадигма прописује (у овом примеру тај принцип
   би био "програм не сме да садржи наредбе скока"). Практичари, са
   друге стране, заговарају често став да је одступање од строгих
   закона неке парадигме допуштено у неким изнимним ситуацијама, у
   којима процењују да то доводи до кода који је на неки начин бољи
   (ефикаснији, краћи, ...). У овом примеру, увођење наредби ``break``
   и ``continue`` јесте нарушавање правила да не сме бити наредби
   скокова. То заиста компликује анализу програма, јер, на пример, ако
   смо сигурни да нема наредби скокова, знаћемо сигурно да након петље
   ``while`` услов петље није више испуњен, али ако петља садржи
   наредбу ``break`` то више не мора бити тачно. Ипак, пракса показује
   да је корист коришћења наредбе ``break`` већа него штета (нарочито
   ако се она користи ограничено, у складу са неким честим идиомима) и
   данас се та два облика скока користе у програмирању, одступајући
   тиме од строгог канона који структурна парадигма заговара.

   
Процедурално програмирање (у смислу потпрограма)
------------------------------------------------

Структурирано програмирање и изгегавање скокова су један важан начин
увођења дисциплине у императивну парадигму. Други важан корак је
разбијање програма у мање целине. Основни механизам за то је
дефинисање **потпрограма** (некада се каже и **подрутине**,
енгл. subroutine). Суштински постоје две врсте потпрограма:

- **Функције** одговарају функцијама у математици и њихова улога је да
  на основу датих вредности аргумената израчунају резултат.

- **Процедуре** служе да остваре неки бочни ефекат (испишу нешто на
  екран, упишу нешто у датотеку, али и промене стање програма мењајући
  вредности неких глобалних променљивих).

Програмски језик Pascal је чак користио различите кључне речи
(``function`` и ``procedure``) за ове две врсте потпрограма, док се у
језику C процедуре остварују као функције које не враћају вредност тј.
функције чији је повратни тип ``void``. Пошто у већини програмских
језика и функције често могу да имају бочне ефекте, раздвајање на
процедуре и функције није претерано значајно (отуда се у језику C и
његовим наследницима, а и многим другим савременим језицима помињу
само функције).

Као што је то обично случај у рачунарству, комплексни проблеми се
најбоље решавају тако што се разложе на мање, једноставније
потпроблеме. **Процедурално програмирање** (при чему под термином
процедура подразумевамо потпрограм, а не поступак тј. алгоритам)
подразумева да се за сваки јасно дефинисан потрпроблем дефинише
засебна функција тј. процедура којом се он решава. Потпрограми
позивају једни друге, све до главног програма (који и сам може бити
потпрограм, попут функције ``main`` у језику C) од кога креће
извршавање. Изградња програма обично тече **одозго-наниже**
(енгл. top-down) и програмер даје опис главног програма у терминима
позива потпрограма које тек касније разрађује.

Пожељно је да развој сваке процедуре буде што независнији од остатка
програма. Стога програмски језици увод концепт **локалних
променљивих**, преноса вредности у потпрограм и повратка резултата из
њега. Комуникација између потпрограма се може вршити и преко глобалног
стања програма, али то ствара велике зависности између различитих
потпрограма и пожељно је избегавати тај облик комуникације.

Подела великих програма на мање потпрограме је добар корак ка
**модуларизацији**. Након издвајања појединачних потпрограме, јавља се
потреба за организовањем сродних функција и података којима оне
оперишу у модуле тј. библиотеке које се затим могу укључити и
користити у већем броју програма. То постаје уобичајена пракса у
програмирању и припрема за нову, објектно-оријентисану парадигму у
којој такви модули (објекти, класе) добијају и нове карактеристике
(наслеђивање, полиморфизам).

Имплементација потпрограма је захтевала унапређивање компилатора и
реорганизацију меморије (поделу на програмски стек, хип, сегмент
података и сегмент кода), а када су ти проблеми решени, дошло се до
много боље организације сложених програма.

Једна важна техничка могућност је та да потрпограми могу да позивају
сами себе, чиме се долази до могућности **рекурзивног** описа
алгоритама, који је често много једноставнији.

На пример, упоредимо класичну итеративну имплементацију алгоритма
степеновања и рекурзивну:

.. code-block:: csharp

   long stepen(int x, int n) {
        long s = 1;
        for (int i = 0; i < n; i++)
            s *= x;
        return s;
   }

.. code-block:: csharp

   long stepen(int x, int n) {
      if (n == 0) return 1;
      return x * stepen(x, n-1);
   }

Друга, рекурзивна, дефинција је веома блиска класичној математичкој
дефиницији степена

.. math::

   \begin{align*}
   & x^0 = 1 \\
   & x^n = x \cdot x^{n-1}, \text{ za } n > 0
   \end{align*}

Рекурзивна функција је много декларативнији него класични итеративни
опис, јер се рачунару заправо не описује како ова вредност треба да се
израчуна (алгоритам израчунавања вредности рекурзивних функција помоћу
стека је познат и њега компилатор генерише на основу нашег рекурзивног
описа). Рекурзија се много интензивније користи у склопу функционалног
програмирања, о чему ће много више речи бити касније.

Предности и мане императивне парадигме
--------------------------------------

Основна предност императивне парадигме је то што је она веома блиска
принципима функционисања хардвера тако да се програми прилично
директно могу превести на асемблерски и машински језик. Императивни
програми су у принципу најефикаснији.

Мане су низак степен декларативности и обавеза програмера да опише
велики број детаља алгоритма (што штеди "процесорско време", али троши
"програмерско време"). Бочни ефектни могу прилично да закомпликују
анализу програма. Ако функција користи и мења глобалне променљиве,
тада је могуће да се иста функција позове са истим аргументима више
пута и да сваки пут да различит резултат и произведе различит ефекат
(кажемо да функције немају особину референцијалне транспарентности).
Због тога није могуће анализирати функцију само гледањем њеног кода,
већ је увек потребно анализирати је у контексту целокупног стања
програма тј. гледајући цео програм као целину (јер свака функција може
да приступи и измени глобално стање програма). На пример, ако нека
глобална променљива има погрешну вредност, пошто било која функција
може да јој приступи и да је промени, дебаговање подразумева да се
проанализирају све функције и да се провери која од њих приступа и
мења ту глобалну променљиву, што може бити веома
компликовано. Наравно, увођење дисциплине у програмирање и обичај
избегавања глобалног стања и бочних ефеката доводи до бољих програма,
међутим, програмски језици не терају програмера да се придржава тих
правила.
