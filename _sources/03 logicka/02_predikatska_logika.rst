Предикатска логика
==================

У претходном поглављу смо видели да се исказна логика може успешно
примењивати у ситуацијама у којима је природно било моделовати проблем
тако да се траже решења која задовољавају неке услове над коначним
скупом променљивих које имају вредности или 0 или 1 (променљиве могу
бити или тачне или нетачне). На пример, код загонетке Судоку свако
поље може бити променљива чија је вредност од 1 до 9, међутим, да
бисмо дошли до исказног модела, увели смо нове променљиве које (по
једну променљиву за свако поље и сваку вредност од 1 до 9) и те
променљиве представљају појединачне исказе (који могу бити или тачни
или нетачни). Ово има смисла када је скуп вредности коначан (и
релативно мали) и када нисмо вршили никакве променљиве над бројевним
вредностима. Исказна логика је сасвим природна за моделовање хардвера
(где се природно ради са променљивима које имају само вредности 0
или 1) и SAT решавачи се интензивно примењују у дизајну и верификацији
хардвера.

Друге примене (пре свега оне које нису над коначним доменима)
захтевају богатије логике и другачије механизме закључивања.

Исказна логика не разматра унутрашњу структуру исказа. Исказ се
представља словом (исказном променљивом) и не анализира се како је он
изграђен нити шта говори (само се анализирају могућности да буде тачан
и да буде нетачан). Са друге стране, у предикатској логици разматрамо
како се искази формирају. Сваки исказ говори о својству неког објекта
или о вези између нека два или више објеката. На пример, исказ *„Број
7 је прост“* говори да број 7 има својство *је прост број*, исказ
*„Пера је Миленин отац“* говори о односу између Пере и Милене, док
исказ *„Тачка А се налази између тачака B и C“* говори о односу између
три тачке. Дакле, :math:`\mathrm{prost}(x)`,
:math:`\mathrm{је\_otac\_od}(x, y)`, :math:`\mathrm{između}(x, y, z)`
означавају неке односе тј. **релације** између објеката. Релација
обухвата неколико објеката (видели смо пример унарне, бинарне и
тернарне релације) и исказ да су објекти у релацији може бити тачан
или нетачан (број је или прост или није, неко је нечији отац или није,
тачка је између неке две тачке или није). Дакле, сваки исказ
подразумева да се говори о некој релацији између објеката.


Објекти могу бити конкретни објекти, који се означавају
**константама**. У прва два примера објекти су били константе (на
пример, 7 означава неки конкретан број, а Пера и Милена неке конкретне
особе). У трећем примеру су уместо константи употребљене променљиве
(нису у питању константе, јер није баш унапред јасно на које три тачке
се односе :math:`A`, :math:`B` и :math:`C`). Као што ћемо касније
видети, да бисмо могли одредити истинитосну вредност таквих исказа,
морамо знати вредности променљивих које се у њима јављају (док не
знамо на које тачке се односе имена :math:`A`, :math:`B` и :math:`C`
не можемо знати да ли је исказ тачан).

Искази могу говорити и о објектима који су добијени од неких
једноставнијих објеката применом неких **функција** или
**операција**. На пример, *„Следбеник броја 6 је прост“*, *„Збир
бројева 3 и 5 је паран“*, *„Перин отац је Миленин деда“*. У овим
примерима :math:`\mathrm{sledbenik}(x)`, :math:`\mathrm{zbir}(x, y)`
tj. :math:`x + y` и :math:`\mathrm{otac\_od}(x)` су функције које
примају неке објекте и враћају неке друге објекте. На пример, функција
следбеник прима број 6 и враћа број 7. Обратимо пажњу на разлику
између функције :math:`\mathrm{otac}` и релације
:math:`\mathrm{je\_otac\_od}`. Када смо рекли *„Перин отац“* применили
смо функцију која прими особу „Пера“ и врати особу (његовог оца).
Када смо рекли *„Пера је Миленин отац“* применили смо релацију која
прима две особе и враћа тачно ако и само ако је прва особа отац од
друге.

.. infonote::

   Функције примају објекте и враћају објекте. Релације примају
   објекте, а враћају тачно или нетачно.

Применом функција на константе, променљиве и резултате других функција
добијамо изразе (кажемо **термове**). Сваки исказ (говорићемо и
**атомичка формула**) се добија применом релације на неке термове,
тј. тако што се крене од неких константи или променљивих, на њих се
примењују функције (угнежђене на произвољан начин) и на крају се на
добијене термове примени једна релација. Пошто је говорни језик
непрецизан, у математици користимо прецизнији запис, који подразумева
да смо се у старту договорили којим симболима означавамо константе,
функције и релације. Да бисмо формално могли да запишемо неки исказ,
тј. атомичку формулу, потребно је да знамо **језик** (кажемо и
**сигнатуру**) -- списак симбола којима записујемо константе, функције
и релације. Исказе које смо раније анализирали у математичком запису
можемо представити следећим атомичким формулама (при чему смо језик
уводили постепено).


.. math::

   \mathrm{prost}(7)\\
   \mathrm{je\_otac\_od}(Pera, Milena)\\
   \mathrm{između}(A, B, C)\\
   \mathrm{prost}(\mathrm{sledbenik(6)})\\
   \mathrm{paran}(3 + 5)\\
   \mathrm{je\_deda\_od}(\mathrm{otac\_od}(Pera), Milena)\\
 
Када се применом функција и релација добију искази, они се даље
комбинују истим везницима као и у исказној логици. На пример, *„Број 7
је непаран прост број“* се записује формулом (не више атомичком)

.. math::

   \mathrm{neparan}(7)\wedge\mathrm{prost}(7)

Ако се знају истинитосне вредности исказа који су повезани везником,
може се одредити и вредност сложеног исказа (на потпуно исти начин као
у исказној логици).

Веома важан начин грађења сложених исказа у предикатској логици је уз
помоћ **квантификатора**. Они су у тесној вези са променљивама које
учествују у исказима. Основни квантификатори су егзистенцијални
квантификатор *„постоји“* (:math:`\exists`) и универзални
квантификатор *„за сваки“* (:math:`\forall`). На пример, исказ
:math:`x < 1` садржи **слободну** променљиву :math:`x` и не можемо
знати његову истинитосну вредност док не знамо вредност те променљиве.
Са друге стране, на овај исказ можемо применити неки квантификатор и
тиме добити исказе :math:`(\exists x)(x < 1)` и :math:`(\forall x)(x <
1)`.  Ови искази више не садрже слободне променљиве (променљива
:math:`x` је у оба случаја **везана** квантификатором) и њихова
истинитосна вредност се може одредити без познавање конкретне
вредности променљиве :math:`x` (квантификатори кодирају знање о
вредностима исказа :math:`x < 1` за разне вредности променљиве
:math:`x` -- универзални квантификатор представља одређено уопштење
конјункције, а егзистенцијални дисјункције). Ипак, да бисмо могли
одредити истинитосне вредности ових исказа, морамо још знати домен
могућих вредности променљиве :math:`x`. Свака квантификација
подразумева да знамо које су све могуће вредности променљиве. Некада
је то имплицитно јасно и подразумева се из контекста (на пример, ако
је формула у делу књиге о природним бројевима, подразумеваћемо да
:math:`x` може бити било који природан број), а некада је потребно
бити пажљив и експлицитно нагласити домен променљивих.

- Формула :math:`(\forall x)(x < 1)` ће бити нетачна без обзира на
  домен, јер том домену мора припадати и константа 1, а не важи да је
  :math:`1 < 1` (наиме, уобичајено је да се подразумева да постоји
  јединствен домен у ком се налазе сви објекти, па и објекти који
  представљају константе које се јављају у формулама).

- Формула :math:`(\exists x)(x < 1)` ће бити нетачна у домену
  природних бројева (јер се обично подразумева да је 1 најмањи
  природан број), а тачна у домену целих бројева (као и рационалних,
  реалних, итд.).

Дакле, да би се могла одредити истинитосна вредност произвољне
формуле, потребно је да неколико услова буде испуњено.

- Ако формула садржи слободне променљиве (променљиве које нису под
  дејством квантификатора), њену истинитосну вредност је могуће
  одредити само у односу на неке конкретне вредности тих променљивих
  (кажемо вредност при некој валуацији променљивих). Такве формуле се
  обично избегавају и у запису математичких тврђења се користе
  искључиво формуле без слободних променљивих (тзв. **реченице**).
  Истинитосна вредност реченица не зависи од вредности, тј. валуације
  променљивих. Некада се усваја договор да се користе само реченице,
  али да се неки квантификатори могу изоставити -- када год је
  изостављен квантификатор, подразумева се универзална квантификација.
  Да не би долазило до забуне, ми ћемо увек експлицитно записивати све
  квантификаторе.

- Потребно је знати **домен** у ком се налазе објекти о којима формула
  говори. У том (јединственом) домену налазе се све константе и све
  променљиве узимају вредност из тог домена.

- Морамо знати шта означавају сви симболи који се јављају у запису
  формуле: симболи константи, симболи релација, симболи функција. Када
  се формула напише она је само синтаксички објекат и да бисмо
  одредили њену истинитосну вредност, потребно је да му некако
  доделимо и значење, тј. семантику. Кажемо да је потребно да знамо
  **интерпретацију** сваког симбола. На пример, ако у формули пише
  :math:`(\forall x)(x \star 1 = x)`, морамо знати коју операцију
  означава симбол :math:`\star` да бисмо разумели о чему формула
  говори и одредили њену истинитосну вредност (ако је у питању
  операција множења, формула је тачна (нпр. у домену реалних бројева),
  а ако је у питању операција сабирања, формула је нетачна). Неки
  симболи су стандардни и њихова интерпретација се подразумева (на
  пример, у претходном примеру смо подразумевали да симбол :math:`<`
  означава релацију поретка бројева). Ако то није случај, неопходно је
  прецизирати интерпретацију сваког симбола у запису формуле (симболе
  константи интерпретирамо објектима из домена, функцијске симболе
  функцијама у том домену, а релацијске симболе релацијама у том
  домену).

У предикатској логици првог реда квантификатори се примењују искључиво
на променљиве. У предикатској логици вишег реда допуштено је да се
квантификатори примене и на релацијске и функцијске симболе. На
пример, наредна формула је исправна формула логике вишег, али не и
логике првог реда, јер је на десној страни квантификатор примењен
на функцијски симбол (:math:`\exists f`).

.. math::

   (\forall x)(\exists y)P(x, y) \Loftrigtharrow (\exists f)P(x, f(x))
  
.. infonote::

   Синтакса и семантика предикатске логике се могу и мало прецизније
   дефинисати.

   Дефинишимо прво **синтаксу**. Крећемо од **језика** :math:`L`, који
   се састоји од скупа функцијских и скупа релацијских симбола. Сваки
   симбол има своју арност. Функцијски симболи арности 0 се називају
   константе, а релацијски симболи арности 0 логичке константе (њих
   увек обележавамо са :math:`\top` и :math:`\bot`).

   **Термови** се рекурзивно дефинишу следећом контекстно слободном
   граматиком:

   .. math::

      \begin{eqnarray*}
      term &\rightarrow& x, \quad x\ \textrm{je promenljiva}\\
      term &\rightarrow& f(term_1, \ldots, term_n), \quad f\ \textrm{je funkcijski simbol arnosti}\ n
      \end{eqnarray*}

   **Формуле** се дефинишу на следећи начин:

   .. math::

      \begin{eqnarray*}
      \mathit{formula} &\rightarrow& \top\\
      \mathit{formula} &\rightarrow& \bot\\
      \mathit{formula} &\rightarrow& P(term_1, \ldots, term_n), \quad P\ \textrm{je relacijski simbol arnosti}\ n\\
      \mathit{formula} &\rightarrow& \neg \mathit{formula}\\
      \mathit{formula} &\rightarrow& \mathit{formula} \wedge \mathit{formula}\\
      \mathit{formula} &\rightarrow& \mathit{formula} \vee \mathit{formula}\\
      \mathit{formula} &\rightarrow& \mathit{formula} \Rightarrow \mathit{formula}\\
      \mathit{formula} &\rightarrow& \mathit{formula} \Leftrightarrow \mathit{formula}\\
      \mathit{formula} &\rightarrow& (\forall x)(\mathit{formula})\\
      \mathit{formula} &\rightarrow& (\exists x)(\mathit{formula})\\
      \mathit{formula} &\rightarrow& (\mathit{formula})\\
      \end{eqnarray*}

   Дефинишимо сада **семантику**. **Структура** језика :math:`L`
   (скр. :math:`L`-структура) је уређени пар :math:`(D, I)` где је
   :math:`D` непразан скуп (домен), а :math:`I` функција
   интерпретације која сваком :math:`n`-арном функцијском симболу
   :math:`f` језика :math:`L` додељује функцију :math:`f^d : D^n
   \rightarrow D`, а сваком :math:`n`-арном релацијском симболу
   :math:`f` језика :math:`L` додељује релацију :math:`P^d \subseteq
   D^n`. **Валуација** :math:`v` пресликава променљиве у елементе
   домена :math:`D`.

   Тада се може дефинисати функција :math:`T_{D, I, v}(t)` која
   израчунава **вредност термова**, тј. сваки терм пресликава у
   елементе домена :math:`D`. Дефиниција је рекурзивна у односу на
   структуру терма.

   - :math:`T_{D, I, v}(x) = v(x)`
   - :math:`T_{D, I, v}(f(t_1, \ldots, t_n)) = f^d(T_{D, I, v}(t_1), \ldots, T_{D, I, v}(t_1))`

   Затим се може дефинисати функција :math:`I_{D, I, v}(F)` којом се
   одређује истинитосна **вредност формуле**. Њена рекурзивна
   дефиниција наслеђује велики број случајева из исказне логике, тако
   да ћемо приказати само оне који су специфични за предикатску
   логику.

   - :math:`I_{D, I, v}(P(t_1, \ldots, t_n)) = 1` ако и само ако важи
     :math:`P^d(T_{D, I, v}(t_1), \ldots, T_{D, I, v}(t_1))`
   - :math:`I_{D, I, v}((\forall x)F) = 1` ако и само ако за сваку
     валуацију :math:`v'` која се поклапа са :math:`v` на свим
     променљивим, осим на :math:`x` важи :math:`I_{D, I, v'}(F) = 1`
     (другим речима, за било који избор вредности :math:`x` формула
     :math:`F` је тачна за ту вредност :math:`x`).
   - :math:`I_{D, I, v}((\exists x)F) = 1` ако и само ако постоји
     валуација :math:`v'` која се поклапа са :math:`v` на свим
     променљивим осим на :math:`x` и важи :math:`I_{D, I, v'}(F) = 1`
     (другим речима, постоји вредност :math:`x` таква да је формула
     :math:`F` тачна за ту вредност :math:`x`).
           
   Доказује се да за реченице (формуле без слободних променљивих)
   функција :math:`I_{D, I, v}` враћа исту вредност за све валуације
   :math:`v`, тј. да истинитосна вредност реченица не зависи од
   валуације. Зато се за реченице разматра функција :math:`I_{D, I}`.
   Кажемо да је :math:`L`-структура **модел** реченице :math:`F` ако и
   само ако важи :math:`I_{D, I}(F) = 1`. Ово обележавамо и са
   :math:`(D, I) \vDash F`. У супротном, :math:`L`-структура је
   **контра-модел** реченице :math:`F`.
  
Размотримо следеће формуле и покушајмо да одредимо њихову истинитосну
вредност:

.. math::

   (\forall x)(\exists y)(\rho(x, y))\\
   (\forall x)(\neg P(x)) \Leftrightarrow \neg(\exists x)(P(x))\\
   (\forall x)(P(x) \wedge \neg P(x))

   
Јасно је да у првој формули не знамо шта означава бинарни релацијски
симбол :math:`\rho`, а да у другој не знамо шта означава унарни
релацијски симбол :math:`P`, као и да ни за једну формулу не знамо
домен. Ако у првој формули интерпретирамо симбол :math:`\rho`
релацијом :math:`<` формула говори да од сваког броја постоји већи
број и тачна је у свим уобичајеним бројевним доменима (природним
бројевима, целим, рационалним, реалним). Ако симбол :math:`\rho`
релацијом :math:`<` формула говори да од сваког броја постоји мањи
број и она није тачна у домену природних бројева, а јесте тачна у
домену целих, рационалних и реалних бројева. Дакле, истинитосна
вредност прве формуле зависи од интерпретације симбола :math:`\rho` и
од домена на који се односи. Та формула има и модел (може бити тачна)
и контра-модел (може бити нетачна). Формуле које имају модел зовемо
**задовољиве**, а које имају контра-модел **порециве**.

Са друге стране, друга формула је тачна на које год својство се односи
симбол :math:`P` и који год домен да посматрамо (подразумевамо да увек
разматрамо непразне домене). Такве формуле, дакле, не зависе од
математичких појмова на које се односе већ су тачне искључиво на
основу своје логичке структуре. За такве формуле кажемо да су
**универзално ваљане** (или краће, ваљане). Ваљане формуле су на неки
начин уопштење појма таутологије и исправност закључивања се може
свести на испитивање ваљаности одређених формула. Појам **логичке
последице** и **логички еквивалентних** формула се у предикатској
логици дефинише на исти начин као и у исказној и испитивање ових
односа између формула (који су основа исправног закључивања) се своди
на испитивање ваљаности одговарајућих формула.

Ако, на пример, кренемо од претпоставки *„Сви Грци су људи“* и *„Сви
људи су смртни“*, тада можемо да изведемо закључак *„Сви Грци су
смртни“*. Тврдимо, дакле, да је формула

.. math::

   (\forall x)(\mathrm{grk}(x) \Rightarrow \mathrm{smrtan}(x))

логичка последица формула

.. math::

   (\forall x)(\mathrm{grk}(x) \Rightarrow \mathrm{covek}(x))\\
   (\forall x)(\mathrm{covek}(x) \Rightarrow \mathrm{smrtan}(x))

Ово је чувени први Аристотелов **силогизам** (правило исправног
закључивања). Овај закључак јесте исправан пошто је следећа формула
ваљана.


.. math::

   (\forall x)(\mathrm{grk}(x) \Rightarrow \mathrm{covek}(x))\ \wedge \\
   (\forall x)(\mathrm{covek}(x) \Rightarrow \mathrm{smrtan}(x)) \Rightarrow\\
   (\forall x)(\mathrm{grk}(x) \Rightarrow \mathrm{smrtan}(x))

Кључни проблем је то што је испитивање ваљаности, тј. задовољивости у
предикатској логици неупоредиво тежи проблем него испитивање исказне
таутологичности, тј. задовољивости и у општем случају не постоји
алгоритам који би могао да испита ваљаност произвољне формуле
предикатске логике (и доказано је да такав алгоритам не само да није
тренутно измишљен, него не може ни да постоји). Постоје алгоритми који
успевају да испитају ваљаност неких формула, али они су често
неефикасни, треба им пуно времена и меморије и не могу да увек дају
одговор. Кажемо да је проблем испитивања ваљаности **неодлучив**.  Са
друге стране, проблем јесте полу-одлучив, што значи да постоје
алгоритми који (под претпоставком да им се да довољно времена и
меморије) за било коју ваљану формулу у неком тренутку могу да утврде
да је ваљана. Међутим, за формуле које нису ваљане ти алгоритми раде
бесконачно, никада се не заустављајући и никада не утврђујући да дата
формула није ваљана.

Трећа формула :math:`(\forall x)(P(x) \wedge \neg P(x))` је
**незадовољива** јер је нетачна у свим доменима и за све могуће
интерпретације симбола :math:`P`. Она нема ниједан модел (сваки домен
и интерпретација су јој контра-модел).

Примена аутоматских доказивача теорема
--------------------------------------

Један од најуспешнијих аутоматских доказивача теорема је *Vampire*
(https://vprover.github.io/). Преузми га на свој рачунар. Улаз
доказивача се обично задаје у формату TPTP. Прикажимо како можемо
доказати коректност претходног закључка применом аутоматског
доказивача. Две претпоставке задајемо као аксиоме. Формуле логике
првог реда се у формату TPTP означавају са `fof`, након чега се задаје
име формуле, статус (са `axiom` обележавамо претпоставке, а са
`conjecture` закључке) и на крају сама формула. Приметимо да се
импликација обележава са `=>`, а универзални квантификатор sa `!`.

::

   fof(premisa1, axiom, ![X]: (grk(X) => covek(X))).
   fof(premisa2, axiom, ![X]: (covek(X) => smrtan(X))).
   fof(zakljucak, conjecture, ![X]: (grk(X) => smrtan(X))).

Ако ово сачувамо у датотеку `syllogysm1.tptp` и затим покренемо
*Vampire* из командне линије, командом `vampire syllogysm1.tpt` добијамо
поруку:

::

   % Refutation found. Thanks to Tanya!

Ово значи да је формула успешно доказана.

.. questionnote::

   Коришћењем аутоматског доказивача оправдајте и следеће Аристотелове
   силогизме.

   - Ниједан рептил нема крзно.
   - Све змије су рептили.
   - Дакле, ниједна змија нема крзно.

   ::

      fof(prem1, axiom, ~(?[X]: (reptil(X) & krzno(X)))).
      fof(prem2, axiom, ![X]: (zmija(X) => reptil(X))).
      fof(concl, conjecture, ~(?[X]: (zmija(X) & krzno(X)))).
     
   - Сви зечеви имају крзно.
   - Неки љубимци су зечеви.
   - Дакле, неки љубимци имају крзно.

   ::

      fof(prem1, axiom, ![X]: (zec(X) => krzno(X))).
      fof(prem2, axiom, ?[X]: ljubimac(X) & zec(X)).
      fof(concl, conjecture, ?[X]: (zec(X) & krzno(X))).
     

   - Нема забавног домаћег.
   - Неке књиге се читају за домаћи.
   - Неке књиге нису забавне.

   ::

      fof(prem1, axiom, ~(?[X]: (domaci(X) & zabavan(X)))).
      fof(prem2, axiom, ?[X]: knjiga(X) & domaci(X)).
      fof(concl, conjecture, ?[X]: (knjiga(X) & ~zabavan(X))).
     
   - Сви људи су смртни.
   - Сви Грци су људи.
   - Неки Грци су смртни.
     
   ::

      fof(premisa1, axiom, ![X]: (grk(X) => covek(X))).
      fof(premisa2, axiom, ![X]: (covek(X) => smrtan(X))).
      fof(dodatna_premisa, axiom, ?[X]: grk(X)).
      fof(zakljucak, conjecture, ?[X]: (grk(X) & smrtan(X))).

   Приметимо да је у овом примеру било неопходно додати претпоставку
   да постоји бар један Грк. Наиме, Аристотел је подразумевао
   имплицитно да сваки предикат о коме се говори мора да буде
   задовољен за бар неки објекат (да су сви скупови објеката које
   разматрамо непразни), док у савременој логици та имплицитна
   претпоставка не постоји и потребно је експлицитно навести. Поставља
   се питање шта се дешава са тачношћу исказа „Сви Грци су смртни“ ако
   не постоји ни један Грк. Ово може бити донекле збуњујуће, али је у
   савременој логици недвосмислено да је исказ и тада тачан. Ипак, у
   неким ранијим разматрањима логике исказ је у тој ситуацији сматран
   тачним, у неким погрешим, а у неким неодређеним.
    
      
.. questionnote::

    Употребимо сада аутоматски доказивач теорема да докажемо да смо
    успешно решили један детективски случај.
     
    - Алиса, њен муж, син, ћерка и брат су ликови у роману Агате Кристи.
    - Једно од њих петоро је убило неког од преосталих четворо.
    - Мушка и женска особа су биле заједно у бару у време убиства.
    - Жртва и убица су били заједно на плажи у време убиства.
    - Једно дете је било само у време убиства.
    - Жртвин близанац/близнакиња није убица.
    - Убица је млађи од жртве.
     
    Кодирајмо сада ово знање помоћу предикатске логике (вама за вежбу
    остављамо да исто урадите помоћу исказне логике и случај решите помоћу
    SAT решавача).
     
    У случај је укључено пет особа. Уведимо предикат
    :math:`\mathrm{osoba}(x)` и пет константи :math:`\mathrm{alisa}`,
    :math:`\mathrm{muz}`, :math:`\mathrm{cerka}`, :math:`\mathrm{sin}` и
    :math:`\mathrm{brat}`. Једине особе које су релевантне за овај случај
    су ове, што можемо кодирати следећом формулом.
     
    .. math::
     
       (\forall x)(\mathrm{osoba}(x) \Rightarrow x=\mathrm{alisa} \vee x=\mathrm{muz} \vee x=\mathrm{cerka} \vee x=\mathrm{sin} \vee x=\mathrm{brat})
     
    Нагласимо да се не подразумева да различите константе означавају
    различите објекте и да је понекад потребно увести експлицитно
    претпоставке типа :math:`\mathrm{alisa} \neq \mathrm{muz}`. Ипак, у
    овом задатку то неће бити потребно.
     
    Уводимо још две константе: :math:`\mathrm{ubica}` и
    :math:`\mathrm{zrtva}`. Из текста задатка је познато је да су оне међу
    ових пет особа, као и да су у питању различите особе. То кодирамо
    следећом формулом.
     
    .. math::
       \mathrm{osoba}(\mathrm{ubica}) \wedge \mathrm{osoba}(\mathrm{zrtva}) \wedge \mathrm{ubica} \neq \mathrm{zrtva}
       
    Мушка и женска особа су биле заједно у бару у време убиства. Можемо
    увести константе :math:`\mathrm{u\_baru\_musko}` и
    :math:`\mathrm{u\_baru\_zensko}` и формулу која описује особине ових
    константи. Имплицитно је јасно ко су мушке, а ко су женске особе, али
    то је потребно експлицитно кодирати. Женске особе можемо експлицитно
    набројати, а мушке особе дефинисати као оне особе које нису женске.
     
    .. math::
       (\forall x)(\mathrm{zensko}(x) \Leftrightarrow x=\mathrm{alisa} \vee x=\mathrm{cerka})\\
       (\forall x)(\mathrm{musko}(x) \Leftrightarrow \mathrm{osoba}(x) \wedge \neg\mathrm{zensko}(x))
     
    Сада можемо описати особине особа у бару.
     
    .. math::
     
       \mathrm{musko}(\mathrm{u\_baru\_musko}) \wedge \mathrm{zensko}(\mathrm{u\_baru\_zensko})
     
    Жртва и убица су били на плажи у време убиства. Ово можемо
    кодирати или тако што уведемо нове две константе за особе које су
    биле на плажи или, можда мало једноставније, тако што уведемо
    предикат :math:`\mathrm{na\_plazi}(x)`.
     
    .. math::
     
       \mathrm{na\_plazi}(\mathrm{zrtva}) \wedge \mathrm{na\_plazi}(\mathrm{ubica})
     
    Из текста задатка се имплицитно подразумева да особе не могу
    истовремено бити и на плажи и у бару, али то је неопходно експлицитно
    кодирати.
     
    .. math::
     
       \neg \mathrm{na\_plazi}(\mathrm{u\_baru\_musko}) \wedge \neg \mathrm{na\_plazi}(\mathrm{u\_baru\_zensko})
     
    Једно дете је било само у време убиства. Имплицитно је јасно да су
    једино деца син и ћерка, као и да особе у бару ни особе на плажи нису
    саме. То морамо експлицитно да кодирамо (а уједно ћемо искористити
    прилику и да дефинишемо ко су родитељи). Уводимо предикате
    :math:`\mathrm{dete}(x)`, :math:`\mathrm{roditelj}(x)` и
    :math:`\mathrm{samo}(x)`.
     
    .. math::
     
       (\forall x)(\mathrm{dete}(x) \Leftrightarrow x = \mathrm{cerka} \vee x = \mathrm{sin})\\
       (\forall x)(\mathrm{roditelj}(x) \Leftrightarrow x = \mathrm{alisa} \vee x = \mathrm{muz})\\
       (\forall x)(\mathrm{samo}(x) \Leftrightarrow \neg \mathrm{na\_plazi}(x) \wedge x \neq \mathrm{u\_baru\_musko} \wedge x \neq \mathrm{u\_baru\_zensko})
     
    Сада можемо да искажемо да постоји дете које је било само.
     
    .. math::
     
       (\exists x)(\mathrm{dete}(x) \wedge \mathrm{samo}(x))
     
    Алиса није била заједно са мужем у време убиства. То значи да њих
    двоје нису могли бити заједно на плажи нити заједно у бару. Довољно је
    да дефинишемо да су две различите особе на плажи заједно, и да су две
    особе у бару заједно и да кажемо да Алиса и муж нису били
    заједно. Приметимо да овим кодирамо само потребан смер (јер предикат
    :math:`\mathrm{zajedno}` не дефинишемо коришћењем еквиваленције, него
    само импликације).
     
    .. math::
     
       \mathrm{zajedno}(\mathrm{u\_baru\_musko}, \mathrm{u\_baru\_zensko})\\
       (\forall x_1)(\forall x_2)(x_1 \neq x_2 \wedge \mathrm{na\_plazi}(x_1) \wedge \mathrm{na\_plazi}(x_2) \Rightarrow \mathrm{zajedno}(x_1, x_2))\\
       (\forall x_1)(\forall x_2)(\mathrm{zajedno}(x_1, x_2) \Rightarrow \mathrm{zajedno}(x_2, x_1))\\
       \neg \mathrm{zajedno}(\mathrm{alisa}, \mathrm{muz})
       
       
    Жртвин близанац није убица. Ово значи да жртва сигурно има близанца
    (или близнакињу). Постоје два могућа пара близанаца: син и ћерка и
    Алиса и њен брат. Један од њих сигурно јесте пар близанаца, а други не
    мора бити, међутим, безбедно је кодирати да су оба пара близанци (јер
    за пар у коме није жртва није битно да ли јесу или нису близанци, па
    не смета да се кодира да јесу).
     
    .. math::
     
       (\forall x_1)(\forall x_2)(\mathrm{blizanci}(x_1, x_2) \Leftrightarrow \\
          (x_1 = \mathrm{sin} \wedge x_2 = \mathrm{cerka}) \vee \\
          (x_1 = \mathrm{cerka} \wedge x_2 = \mathrm{sin}) \vee \\
          (x_1 = \mathrm{alisa} \wedge x_2 = \mathrm{brat}) \vee \\
          (x_1 = \mathrm{brat} \wedge x_2 = \mathrm{alisa}))
     
    Постоји жртвин близанац и он није убица.
     
    .. math::
     
       (\exists x)(\mathrm{blizanci}(\mathrm{zrtva}, x) \wedge x \neq \mathrm{ubica})
     
    На крају још кодирамо услов да је убица млађи од жртве. To једино
    значи да убица не може да буде родитељ, а жртва дете (јер остале
    односе година заправо не познајемо). Довољно је да кодирамо да
    родитељи не могу бити млађи од деце и да је убица млађи од жртве.
     
    .. math::
     
       (\forall x_1)(\forall x_2)(\mathrm{roditelj}(x_1) \wedge \mathrm{dete}(x_2) \Rightarrow \neg \mathrm{mladji}(x_1, x_2))\\
       \mathrm{mladji}(\mathrm{ubica}, \mathrm{zrtva})
     
    Претходне услове можемо записати у формату TPTP, предати их
    доказивачу *Vampire* и он ће практично моментално потврдити да су
    наши закључци исправни. Можемо редом пробати закључке облика
    :math:`\mathrm{ubica} = \mathrm{alisa}`, :math:`\mathrm{ubica} =
    \mathrm{muz}` итд. и само један од њих ће успети да буде доказан
    (једино решење је да је муж убио брата, да је Алиса била са сином
    у бару, а да је ћерка била сама код куће).
       
    ::
     
       % Alisa, njen muž, sin, ćerka i brat su likovi u romanu Agate Kristi.
       % Jedno od njih petoro je ubilo nekog od preostalih četvoro.
       fof(osoba_def, axiom, ![X] : (osoba(X) <=>
                      X = alisa | X = muz | X = sin | X = cerka | X = brat)).
       fof(ubica_zrtva, axiom, osoba(ubica) & osoba(zrtva) & ubica != zrtva).
        
       % Muska i zenska osoba su bile zajedno u baru u vreme ubistva.
       fof(zensko_def, axiom, ![X] : (zensko(X) <=> X = alisa | X = cerka)).
       fof(musko_def, axiom, ![X] : (musko(X) <=> osoba(X) & ~zensko(X))).
       fof(u_baru, axiom, musko(u_baru_musko) & zensko(u_baru_zensko)).
        
       % Zrtva i ubica su bili zajedno na plazi u vreme ubistva.
       fof(na_plazi, axiom, na_plazi(ubica) & na_plazi(zrtva)).
       fof(plaza_bar, axiom, ~na_plazi(u_baru_musko) & ~na_plazi(u_baru_zensko)).
        
       % Jedno dete je bilo samo u vreme ubistva.
       fof(dete_def, axiom, ![X] : (dete(X) <=> X = sin | X = cerka)).
       fof(roditelj_def, axiom, ![X] : (roditelj(X) <=> X = alisa | X = muz)).
       fof(samo_def, axiom, ![X] : (samo(X) <=>
                     ~na_plazi(X) & X != u_baru_musko & X != u_baru_zensko)).
       fof(samo_dete, axiom, ?[X] : (dete(X) & samo(X))).
        
       % Alisa i muz nisu bili zajedno u vreme ubistva.
       fof(zajedno_bar, axiom, zajedno(u_baru_musko, u_baru_zensko)).
       fof(zajedno_na_plazi, axiom, ![X1, X2] :
              (na_plazi(X1) & na_plazi(X2) & X1 != X2 => zajedno(X1, X2))).
       fof(zajedno_sym, axiom, ![X1, X2] :
              (zajedno(X1, X2) => zajedno(X2, X1))).
       fof(zajedno_alisa_muz, axiom, ~zajedno(alisa, muz)).
        
       % Zrtvin blizanac nije ubica.
       fof(blizanci_def, axiom, ![X1, X2] :
              (blizanci(X1, X2) <=> (X1 = sin & X2 = cerka) |
                                    (X1 = cerka & X2 = sin) |
                                    (X1 = alisa & X2 = brat) |
                                    (X1 = brat & X2 = alisa))).
       fof(zrtvin_blizanac, axiom, ?[X] : (blizanci(zrtva, X) & X != ubica)).
        
       % Ubica je mladji od zrtve.
       fof(mladji_def, axiom, ![X1, X2] :
            (roditelj(X1) & dete(X2) => ~mladji(X1, X2))).
       fof(mladji_ubica, axiom, mladji(ubica, zrtva)).
        
       % Resenje slucaja
       fof(solution, conjecture,
             ubica = muz &
             zrtva = brat &
             u_baru_zensko = alisa &
             u_baru_musko = sin &
             samo(cerka)).

Метода резолуције
-----------------

Најпознатија техника за испитивање ваљаности формула јесте **метода
резолуције** и она представља основу великог броја доказивача теорема
(програма који се користе у математици и верификацији софтвера), али и
теоријску основу логичког програмирања (пре свега кроз језик
PROLOG). Циљ овог поглавља је да вам да неки наговештај како ова
метода функционише, а не да детаљно научите све њене детаље.

У питању је метода побијања, што значи да се ваљаност доказује тако
што се покаже да је негација формуле незадовољива. Слично као што су
се SAT решавачи примењивали на формуле у КНФ, тако се метода
резолуције примењује превођењем формуле у **клаузалну форму**.

- Први корак превођења у ту форму је да се формула доведе у
  тзв. нормалну форму **prenex**, тј. облик :math:`Q_1\ x_1.\ \ldots\
  Q_n\ x_n.\ F`, где су :math:`Q_i` квантификатори, а формула
  :math:`F` не садржи квантификаторе.

- Други корак је да се тело формуле (део испред извучених
  квантификатора) преведе у **КНФ**.

- На крају се примењује ослобађање егзистенцијалних квантифитора
  (корак познат као **Сколемизација**).

Крећемо од негације наше формуле и преводимо је у клаузалну
форму. Наша формула има облик :math:`\phi_1 \wedge \phi_2 \Rightarrow
\theta` (две премисе имплицирају закључак), па је њена негација
логички еквивалентна формули :math:`\phi_1 \wedge \phi_2 \wedge \neg
\theta`.  Превођење у клаузалну форму вршимо, између осталог, применом
логичких еквиваленција које смо навели у опису превођења формуле у
КНФ. Додатно примењујемо и следећа правила која се односе на
квантифкаторе:

.. math::

   \neg (\forall x)(P(x)) \equiv (\exists x)(\neg P(x))\\
   \neg (\exists x)(P(x)) \equiv (\forall x)(\neg P(x))\\

Циљ нам је да све квантификаторе извучемо напоље и да добијемо
нормалну форму prenex. За превођење користимо следеће логичке
еквиваленције:

.. math::

  \begin{eqnarray*}
    (\forall x)(A) \wedge B &\equiv& (\forall x)(A \wedge B)\\
    (\forall x)(A) \vee B &\equiv& (\forall x)(A \vee B)\\
    B \wedge (\forall x)(A) &\equiv& (\forall x)(B \wedge A)\\
    B \vee (\forall x)(A) &\equiv& (\forall x)(B \vee A)\\
    (\exists x)(A) \wedge B &\equiv& (\exists x)(A \wedge B)\\
    (\exists x)(A) \vee B &\equiv& (\exists x)(A \vee B)\\
    B \wedge (\exists x)(A) &\equiv& (\exists x)(B \wedge A)\\
    B \vee (\exists x)(A) &\equiv& (\exists x)(B \vee A)
  \end{eqnarray*}

при чему, ако се променљива :math:`x` јавља слободна у :math:`B`,
потребно је да је преименујемо у формули :math:`(\forall x)(A)`, тј.
:math:`(\exists x)(A)`. Да бисмо уштедели на броју квантификатора,
можемо да користимо и следеће формуле.

.. math::

  \begin{eqnarray*}
   (\forall x)(A) \wedge (\forall x)(B) &\equiv& (\forall x)(A \wedge B)\\
   (\exists x)(A) \vee (\exists x)(B) &\equiv& (\exists x)(A \vee B)\\
  \end{eqnarray*}

Међутим, обратите пажњу на то да наредне две формуле нису исправне
(квантификатор „за сваки“ се слаже са конјункцијом, али не и са
дисјункцијом, док се квантификатор „постоји“ слаже само са
дисјункцијом, а не и са конјункцијом.

.. math::

  \begin{eqnarray*}
   (\forall x)(A) \vee (\forall x)(B) &\equiv& (\forall x)(A \vee B)\\
   (\exists x)(A) \wedge (\exists x)(B) &\equiv& (\exists x)(A \wedge B)\\
  \end{eqnarray*}

Вратимо се на формулу из нашег примера. Њена негација је еквивалентна
формули

.. math::

   (\forall x)(\mathrm{grk}(x) \Rightarrow \mathrm{covek}(x))\ \wedge \\
   (\forall x)(\mathrm{covek}(x) \Rightarrow \mathrm{smrtan}(x)) \wedge\\
   \neg (\forall x)(\mathrm{grk}(x) \Rightarrow \mathrm{smrtan}(x))

Ослобађамо се унутрашњих импликација и увлачимо негацију.


.. math::

   (\forall x)(\neg \mathrm{grk}(x) \vee \mathrm{covek}(x))\ \wedge \\
   (\forall x)(\neg \mathrm{covek}(x) \vee \mathrm{smrtan}(x))\ \wedge\\
   (\exists x)(\mathrm{grk}(x) \wedge \neg \mathrm{smrtan}(x))

Извлачимо сада прво егзистенцијални квантификатор на почетак формуле
на основу правила :math:`B \wedge (\exists x)(A) \equiv (\exists x)(B
\wedge A)`. Пошто се :math:`x` не јавља слободно у делу :math:`B`,
нема потребе за преименовањем, па добијамо:

.. math::

   (\exists x)\left((\forall x)(\neg \mathrm{grk}(x) \vee \mathrm{covek}(x))\ \wedge
   (\forall x)(\neg \mathrm{covek}(x) \vee \mathrm{smrtan}(x))\ \wedge
   (\mathrm{grk}(x) \wedge \neg \mathrm{smrtan}(x))\right)

Извлачимо сада универзални квантификатор истовремено испред две
премисе на основу правила :math:`(\forall x)(A) \wedge (\forall x)(B)
\equiv (\forall x)(A \wedge B)` и добијамо:

.. math::

   (\exists x)\left((\forall x)\left((\neg \mathrm{grk}(x) \vee \mathrm{covek}(x))\ \wedge (\neg \mathrm{covek}(x) \vee \mathrm{smrtan}(x))\right)\ \wedge
   (\mathrm{grk}(x) \wedge \neg \mathrm{smrtan}(x))\right)

На крају извлачимо универзални квантификатор на почетак тела
егзистенцијално квантификованог дела формуле на основу правила
:math:`(\forall x)(A) \wedge B \equiv (\forall x)(A \wedge B)`, али
пошто се сада променљива :math:`x` јавља као слободна у делу :math:`B`,
тј. у делу :math:`\mathrm{grk}(x) \wedge \neg \mathrm{smrtan}(x)`,
вршимо преименовање квантификоване променљиве и добијамо.


.. math::

   (\exists x)(\forall x')((\neg \mathrm{grk}(x') \vee \mathrm{covek}(x'))\ \wedge (\neg \mathrm{covek}(x') \vee \mathrm{smrtan}(x'))\ \wedge
   \mathrm{grk}(x) \wedge \neg \mathrm{smrtan}(x))

Добијена формула је логички еквивалентна полазној, и у нормалној форми
prenex, при чему је тело формуле (део испред квантификатора) у КНФ.

Наредни корак при превођењу у клаузалну форму је ослобађање од
егзистенцијалних квантификатора. То се ради процедуром која се назива
**Сколемизација** (у част логичара Сколема). На тај начин се не добија
формула која је еквивалентна полазној, али се добија формула која је
еквизадовољива, што је нама довољно (јер ми ваљаност доказујемо тиме
што доказујемо да негација полазне формуле није
задовољива). Сколемизација се врши тако што се уместо егзистенцијално
квантификованих променљивих уводе нове константне.

- Формула :math:`(\exists x)(P(x))` је еквизадовољива формули
  :math:`P(c)`, где је :math:`c` нови симбол константе (не сме да се
  јавља нигде другде у формули).

- Ако је егзистенцијални квантификатор испред једног или више
  универзалних, онда се уместо константе мора увести функција. На
  пример, формула :math:`(\forall x)(\exists x)(P(x, y))` је
  еквизадовољива формули :math:`(\forall x)P(x, f(x))`, где је
  :math:`f` нови симбол функције (не сме да се јавља негде другде у
  формули)

Сколемизацијом наше формуле добијамо формулу

.. math::

   (\forall x')((\neg \mathrm{grk}(x') \vee \mathrm{covek}(x'))\ \wedge (\neg \mathrm{covek}(x') \vee \mathrm{smrtan}(x'))\ \wedge
   \mathrm{grk}(c) \wedge \neg \mathrm{smrtan}(c))

Можемо се сада вратити корак назад увлачећи квантификаторе до сваке
клаузуле и формулу представити као конјункцију следеће 4 (универзално
квантификоване) клаузуле (преименоваћемо и променљиве, ради
једноставности):

.. math::

   (\forall x)(\neg \mathrm{grk}(x) \vee \mathrm{covek}(x))\\
   (\forall x)(\neg \mathrm{covek}(x) \vee \mathrm{smrtan}(x))\\
   \mathrm{grk}(c)\\
   \neg \mathrm{smrtan}(c)

Потребно је да докажемо да је овај скуп клаузула незадовољив. То се
ради методом резолуције. Пошто смо се ослободили универзалних
квантификатора, све преостале променљиве су универзално
квантификоване, па се обично приликом примене метода резолуције
квантификатори не пишу.


.. math::

   \neg \mathrm{grk}(x) \vee \mathrm{covek}(x)\\
   \neg \mathrm{covek}(x) \vee \mathrm{smrtan}(x)\\
   \mathrm{grk}(c)\\
   \neg \mathrm{smrtan}(c)

Овај скуп клаузула је незадовољив. То можемо видети на следећи начин.
Пошто прва клаузула важи за свако :math:`x` она важи и за :math:`x=c`,
тј.  важи и :math:`\neg \mathrm{grk}(c) \vee \mathrm{covek}(c)`. Пошто
на основу треће клаузуле знамо да важи :math:`\mathrm{grk}(c)`, мора
да важи :math:`\mathrm{covek}(c)`. Пошто и друга клаузула важи за
свако :math:`x`, она важи и за :math:`x=c`, тј.  важи и :math:`\neg
\mathrm{covek}(c) \vee \mathrm{smrtan}(c)`. Пошто важи
:math:`\mathrm{covek}(c)` мора да важи :math:`\mathrm{smrtan}(c)`,
међутим, то је у супротности са нашом четвртом клаузулом.

Формално, правило резолуције се примењује тако што се пронађу две
клаузуле које садрже неки супротан литерал и затим се у скуп клаузуле
дода њихова резолвента, која се добија обједињавањем свих осталих
литерала осим тог супротног. Правило резолуције за исказну логику се
примењује на клаузуле облика

.. math::

   p \vee q_1 \vee \ldots \vee q_m\\
   \neg p \vee r_1 \vee \ldots \vee r_n

и добија се резолвента

.. math::

   q_1 \vee \ldots \vee q_m \vee r_1 \vee \ldots \vee r_n.

Када год су полазне две клаузуле тачне, тачна је и њихова резолвента
(она је њихова логичка последица). Доказ овога је једноставан и
остављамо ти га за вежбу. Централна теорема метода резолуције за
исказну логику је следећа:

.. infonote::

   Скуп исказних клаузула је незадовољив ако и само ако се
   резолвирањем може извести празна клауза (клауза која не садржи
   ниједан литерал).

Иако би се SAT решавач могао засновати на методу резолуције за исказну
логику, SAT решавачи користе друге алгоритме (у којима се ипак
резолуција јавља као један од корака).
   
Правило резолуције за предикатску логику је компликованије, јер
литерали нису више само исказна слова, већ атомичке формуле које
садрже променљиве. Литерали преко којих се врши резолуција се не
разликују само по томе што је један негиран, а други није. Допуштено
је да се они могу изједначити процесом **унификације**, што значи да
је допуштено да се променљиве замене произвољним изразима да би се
добила иста атомичка формула. На пример, могуће је извршити резолуцију
клаузула :math:`\neg \mathrm{grk}(x) \vee \mathrm{covek}(x)` и
:math:`grk(c)`. Заиста, :math:`\mathrm{grk}(x)` и :math:`grk(c)` нису
једнаки, али се могу унификовати тиме што се :math:`x` замени са
:math:`c`. Након те замене се добија прва клаузула :math:`\neg
\mathrm{grk}(c) \vee \mathrm{covek}(c)` и сада се може извршити
резолуција те инстанциране клаузуле и клаузуле :math:`grk(c)` и добити
резолвента :math:`\mathrm{covek}(c)`.

Наведимо још неколико примера унификације.

- Литерали :math:`\rho(x, f(x))` и :math:`\rho(g(y), z)` се могу
  унификовати (пошто литерали долазе из различитих клаузула које су
  засебно универзално квантификоване, увек можемо претпоставити да су
  им променљиве различито назване). Можемо да заменимо :math:`x` са
  :math:`g(y)`, а :math:`z` са :math:`f(g(y))`, чиме у оба случаја
  добијамо :math:`\rho(g(y), f(g(y)))`.

- Са друге стране, литерали :math:`\rho(x)` и :math:`\sigma(y)` се не
  могу унификовати (јер им се разликују релацијски симболи и никаква
  замена променљивих не може довести до њиховог изједначавања).

- Не могу се унификовати ни литерали :math:`\rho(f(x))` и :math:`\neg
  \rho(g(x))`, јер им се разликују функцијски симболи на првој
  позицији (никаквом заменом променљивих :math:`f` не може постати
  исто што и :math:`g`).

Постоји алгоритам који за свака два литерала проверава да ли се могу
унификовати и ако могу, проналази најопштији унификатор (замену
променљивих).

Резолуција у предикатској логици, дакле, покушава да пронађе два
супротна литерала који се могу унификовати и ако успе, примењује
унификатор (замену променљивих) на обе клаузуле и након тога као
резолвенту у скуп клаузула убацује клаузулу која садржи све остале
литерале, осим та два супротна (али инстанциране на основу пронађеног
унификатора). Наведимо још један пример примене правила резолуције у
предикатској логици. Резолвирајмо следећи пар клаузула:

.. math::

   \mathrm{zivotinja}(g(x)) \vee \mathrm{voli}(f(x), x)\\
   \neg \mathrm{voli}(y, a) \vee \mathrm{pazi}(y, a)

Могуће је унификовати формуле :math:`\mathrm{voli}(f(x), x)` и
:math:`\neg \mathrm{voli}(y, a)` тако што се променљива :math:`x`
замени са :math:`a`, а променљива :math:`y` са :math:`f(a)`. Након
инстанцирања, тј. примене ове замене променљивих добијамо:

.. math::

   \mathrm{zivotinja}(g(a)) \vee \mathrm{voli}(f(a), a)\\
   \neg \mathrm{voli}(f(a), a) \vee \mathrm{pazi}(f(a), a)

Сада се може извршити резолуција и добити резолвента:

.. math::

   \mathrm{zivotinja}(g(a)) \vee \mathrm{pazi}(f(a), a)

У нашем примеру могуће је извршити и резолуцију клаузула

.. math::
   
   \neg \mathrm{grk}(x) \vee \mathrm{covek}(x)\\
   \neg \mathrm{covek}(x) \vee \mathrm{smrtan}(x)\\

чиме би се добила клазула

.. math::
   
   \neg \mathrm{grk}(x) \vee \mathrm{smrtan}(x)

Приметимо да правило резолуције на неки начин одговара правилу
транзитивности импликације.
   
Поред правила резолуције потребно је да се допусти и примена правила
**факторисања**, које допушта да се у скуп клаузула дода клаузула која
се добија када се у некој полазној клаузули изврши унификација
неколико њених литерала. На пример, ако имамо клаузлу :math:`P(x,
f(y)) \vee P(g(z), f(z)) \vee \neg R(f(x), z)`, можемo унификовати
њена прва два литерала заменом :math:`x` са :math:`g(z)` и :math:`y`
са :math:`z` и тиме добити нову клаузулу (фактор полазне)
:math:`P(g(z), f(z)) \vee \neg R(f(g(z)), z)`.

Основна теорема метода резолуције за предикатску логику је следећа:

.. infonote::
   
   Скуп клаузула је незадовољив ако и само ако се применом правила
   резолуције и факторисања из њега може извести празна клаузула.

Правила (бинарне) резолуције и факторисања се могу спојити у једно
правило n-арне резолуције које допушта да се истовремено унификује
неколико литерала из једне и неколико њима супротних литерала из друге
клаузуле.
   
Главни проблем у имплементацији је навођење резолуције, јер се
додавањем резолвенти скуп клаузула веома брзо шири што заузима пуно
меморије и успорава извођење нових корисних резолвенти. Научници су
годинама радили на осмишљавању стратегија које би што ефикасније
усмериле процес резолуције тако да се што пре изведе празна
клаузула. Као што смо рекли, ако је полазна формула задовољива, процес
резолуције може да траје бесконачно и да се никада не дође до празне
клаузуле (програм се тада никада неће зауставити).
