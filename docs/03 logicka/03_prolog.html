<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Програмски језик PROLOG</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/activecode.css" />
    <link rel="stylesheet" type="text/css" href="../_static/codemirror.css" />
    <link rel="stylesheet" type="text/css" href="../_static/qchoice.css" />
    <link rel="stylesheet" type="text/css" href="../_static/clickable.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pytutor.css" />
    <link rel="stylesheet" type="text/css" href="../_static/modal-basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/datafile.css" />
    <link rel="stylesheet" type="text/css" href="../_static/dragndrop.css" />
    <link rel="stylesheet" type="text/css" href="../_static/fitb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/matrixeq.css" />
    <link rel="stylesheet" type="text/css" href="../_static/parsons.css" />
    <link rel="stylesheet" type="text/css" href="../_static/lib/prettify.css" />
    <link rel="stylesheet" type="text/css" href="../_static/poll.css" />
    <link rel="stylesheet" type="text/css" href="../_static/showEval.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tabbedstuff.css" />
    <link rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/video.css" />
    <link rel="stylesheet" type="text/css" href="../_static/webgldemo.css" />
    <link rel="stylesheet" type="text/css" href="../_static/webglinteractive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/karel.css" />
    <link rel="stylesheet" type="text/css" href="../_static/notes.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/associations.css" />
    <link rel="stylesheet" type="text/css" href="../_static/editor.css" />
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/user-highlights.css" type="text/css" />
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.1/css/all.css" type="text/css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-4.0.0-dist/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/flatly.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/petlja-course.css" type="text/css" />
    <link rel="stylesheet" href="../_static/nbstyle.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/runestonebase.js"></script>
    <script src="../_static/skulpt.min.js"></script>
    <script src="../_static/skulpt-stdlib.js"></script>
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/jquery.highlight.js"></script>
    <script src="../_static/bookfuncs.js"></script>
    <script src="../_static/codemirror.js"></script>
    <script src="../_static/xml.js"></script>
    <script src="../_static/css.js"></script>
    <script src="../_static/python.js"></script>
    <script src="../_static/htmlmixed.js"></script>
    <script src="../_static/javascript.js"></script>
    <script src="../_static/jquery_i18n/CLDRPluralRuleParser.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.messagestore.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.fallbacks.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.language.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.parser.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.emitter.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.emitter.bidi.js"></script>
    <script src="../_static/activecode-i18n.en.js"></script>
    <script src="../_static/activecode-i18n.sr-Cyrl.js"></script>
    <script src="../_static/activecode.js"></script>
    <script src="../_static/clike.js"></script>
    <script src="../_static/timed_activecode.js"></script>
    <script src="../_static/animationbase.js"></script>
    <script src="../_static/mchoice.js"></script>
    <script src="../_static/timedmc.js"></script>
    <script src="../_static/timed.js"></script>
    <script src="../_static/mchoice-i18n.en.js"></script>
    <script src="../_static/mchoice-i18n.sr-Cyrl.js"></script>
    <script src="../_static/clickable.js"></script>
    <script src="../_static/timedclickable.js"></script>
    <script src="../_static/d3.v2.min.js"></script>
    <script src="../_static/jquery.ba-bbq.min.js"></script>
    <script src="../_static/jquery.jsPlumb-1.3.10-all-min.js"></script>
    <script src="../_static/pytutor.js"></script>
    <script src="../_static/codelens.js"></script>
    <script src="../_static/skulpt.min.js"></script>
    <script src="../_static/skulpt-stdlib.js"></script>
    <script src="../_static/datafile.js"></script>
    <script src="../_static/dragndrop.js"></script>
    <script src="../_static/timeddnd.js"></script>
    <script src="../_static/dragndrop-i18n.en.js"></script>
    <script src="../_static/dragndrop-i18n.sr-Cyrl.js"></script>
    <script src="../_static/fitb.js"></script>
    <script src="../_static/timedfitb.js"></script>
    <script src="../_static/fitb-i18n.en.js"></script>
    <script src="../_static/fitb-i18n.sr-Cyrl.js"></script>
    <script src="../_static/matrixeq.js"></script>
    <script src="../_static/lib/prettify.js"></script>
    <script src="../_static/lib/hammer.min.js"></script>
    <script src="../_static/parsons.js"></script>
    <script src="../_static/parsons-i18n.en.js"></script>
    <script src="../_static/parsons-i18n.sr-Cyrl.js"></script>
    <script src="../_static/timedparsons.js"></script>
    <script src="../_static/poll.js"></script>
    <script src="../_static/reveal.js"></script>
    <script src="../_static/shortanswer.js"></script>
    <script src="../_static/timed_shortanswer.js"></script>
    <script src="../_static/showEval.js"></script>
    <script src="../_static/tabbedstuff.js"></script>
    <script src="../_static/runestonevideo.js"></script>
    <script src="../_static/webglinteractive.js"></script>
    <script src="../_static/FileSaver.min.js"></script>
    <script src="../_static/Blob.js"></script>
    <script src="../_static/karelCorner.js"></script>
    <script src="../_static/karelRobot.js"></script>
    <script src="../_static/karelWorld.js"></script>
    <script src="../_static/karelChat.js"></script>
    <script src="../_static/karelRobotDrawer.js"></script>
    <script src="../_static/karelUI.js"></script>
    <script src="../_static/karel.js"></script>
    <script src="../_static/karel-i18n.en.js"></script>
    <script src="../_static/karel-i18n.sr-Cyrl.js"></script>
    <script src="../_static/notes.js"></script>
    <script src="../_static/pygamelib-init.js"></script>
    <script src="../_static/gallery.js"></script>
    <script src="../_static/associations.js"></script>
    <script src="../_static/associations-i18n.en.js"></script>
    <script src="../_static/associations-i18n.sr-Cyrl.js"></script>
    <script src="../_static/editor.js"></script>
    <script src="../_static/jszip.js"></script>
    <script src="../_static/editor-i18n.en.js"></script>
    <script src="../_static/editor-i18n.sr-Cyrl.js"></script>
    <script src="../_static/translations.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/jquery-ui-1.10.3.custom.min.js"></script>
    <script src="../_static/jquery-fix.js"></script>
    <script src="../_static/bootstrap-4.0.0-dist/js/bootstrap.min.js"></script>
    <script src="../_static/bootstrap-4.0.0-dist/js/bootstrap.bundle.min.js"></script>
    <script src="../_static/bootstrap-sphinx.js"></script>
    <script src="../_static/waypoints.min.js"></script>
    <script src="../_static/rangy-core.js"></script>
    <script src="../_static/rangy-textrange.js"></script>
    <script src="../_static/rangy-cssclassapplier.js"></script>
    <script src="../_static/user-highlights.js"></script>
    <script src="../_static/jquery.idle-timer.js"></script>
    <script src="../_static/processing-1.4.1.min.js"></script>
    <script src="../_static/jquery.hotkey.js"></script>
    <script src="../_static/jquery-migrate-1.2.1.min.js"></script>
    <script src="../_static/course-errors.js"></script>
    <script src="../_static/petlja.js"></script>
    <script src="../_static/require.js"></script>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
    <meta content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' name='viewport' />
    <link rel="shortcut icon" href="../_static/favicon.ico" type="image/ico" />
    <script type="text/javascript">
      eBookConfig = {};
      eBookConfig.host = 'http://127.0.0.1:8000' ? 'http://127.0.0.1:8000' : 'http://127.0.0.1:8000';
      eBookConfig.app = eBookConfig.host + '/runestone';
      eBookConfig.ajaxURL = eBookConfig.app + '/ajax/';
      eBookConfig.course = 'paradigme';
      eBookConfig.logLevel = '0';
      eBookConfig.loginRequired = 'false';
      eBookConfig.build_info = "";
      eBookConfig.isLoggedIn = false;
      eBookConfig.useRunestoneServices = false;
      eBookConfig.python3 = true;
      eBookConfig.basecourse = 'paradigme';
      eBookConfig.runestone_version = '';
      eBookConfig.imagesDir = '../_images/';
      eBookConfig.staticDir = '../_static/';
      if (typeof (Sk) != "undefined")
        Sk.imgPath = eBookConfig.imagesDir;
    </script>

  </head>

  <body>



<div id="navbar" class="content-header">
  <div class="right-side-nav">
    
    <div id="usefulLinksToggle" class="useful-links-toggle">
        <a class="dropdown-toggle dropdown-toggle-burger" role="button" href="#" id="usefulLinksDropdown" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-bars fa-2x"></i>
        </a>
        <div class="dropdown-menu dropdown-nav-links shadow-lg" aria-labelledby="usefulLinksDropdown" x-placement="bottom-start" style="position: absolute; transform: translate3d(-55px, 32px, 0px); top: 0px; left: 0px; will-change: transform;">
          <div class="links-title"> Корисни линкови</div>
          <div class="useful-link">
            <a href="https://www.sphinx-doc.org/en/master/usage/restructuredtext/index.html" target="_blank">Sphinx Docs</a></div>
          <div class="useful-link">
            <a href="https://github.com/Petlja/PetljaDoc/blob/master/README.md" target="_blank">Petljadoc</a></div>
          <div class="useful-link">
            <a href="https://github.com/RunestoneInteractive/overview" target="_blank">Runestone Interactive</a></div>
          
        </div>
    </div>

    
</div>

<div class="left-side-nav">
  <div class="course-logo-nav">
      <a target="_blank" href="https://petlja.org">
          <img src="../_static/img/petlja-logo-wt.svg" alt="petlja.org" id="lightPetljaLogo">
      </a>
  </div>
  <div class="course-logo-nav-kabinet">
      <a target="_blank" href="https://petlja.org/net.kabinet">
          <img src="../_static/img/netkabinet-logo-strelica-wt.svg" alt="petlja.org" id="lightNetKabinetLogo">
      </a>
  </div>
</div>


<div class="content-header-label" id = "content-header-label" href="../">Shrot description</div>

</div>




<div class="petljaCourseContainer">

<div class="petljaCourseContent">
  
           <div class="tableOfContent">
            <h5> Садржај </h5>
            </div>
           <div>
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-01%20paradigme>
                    <h5>О програмским парадигмама</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../01%20paradigme/01_o_paradigmama.html><div class="studioLecture" id=activity-01_o_paradigmama><i class="fas fa-file-alt activity-icon"></i>О програмским језицима и парадигмама</div></a>
                <a href=../01%20paradigme/02_imperativna.html><div class="studioLecture" id=activity-02_imperativna><i class="fas fa-file-alt activity-icon"></i>Императивна парадигма</div></a>
                </div>
            </div>
                
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-02%20funkcionalna>
                    <h5>Функционална парадигма</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../02%20funkcionalna/01_funkcionalna.html><div class="studioLecture" id=activity-01_funkcionalna><i class="fas fa-file-alt activity-icon"></i>О функционалној парадигми</div></a>
                <a href=../02%20funkcionalna/02_haskell.html><div class="studioLecture" id=activity-02_haskell><i class="fas fa-file-alt activity-icon"></i>Haskell - изрази и функције</div></a>
                <a href=../02%20funkcionalna/02b_haskell_liste.html><div class="studioLecture" id=activity-02b_haskell_liste><i class="fas fa-file-alt activity-icon"></i>Haskell - листе</div></a>
                <a href=../02%20funkcionalna/02c_haskell_tipovi.html><div class="studioLecture" id=activity-02c_haskell_tipovi><i class="fas fa-file-alt activity-icon"></i>Haskell - алгебарски типови података</div></a>
                <a href=../02%20funkcionalna/02z_haskell_vezba.html><div class="studioLecture" id=activity-02z_haskell_vezba><i class="fas fa-file-alt activity-icon"></i>Haskell - задаци за вежбу</div></a>
                </div>
            </div>
                
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-03%20logicka>
                    <h5>Логичка парадигма</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../03%20logicka/01_logicka.html><div class="studioLecture" id=activity-01_logicka><i class="fas fa-file-alt activity-icon"></i>О логичкој парадигми</div></a>
                <a href=../03%20logicka/01_iskazna_logika.html><div class="studioLecture" id=activity-01_iskazna_logika><i class="fas fa-file-alt activity-icon"></i>Исказна логика</div></a>
                <a href=../03%20logicka/02_predikatska_logika.html><div class="studioLecture" id=activity-02_predikatska_logika><i class="fas fa-file-alt activity-icon"></i>Предикатска логика</div></a>
                <a href=../03%20logicka/03_prolog.html><div class="studioLecture" id=activity-03_prolog><i class="fas fa-file-alt activity-icon"></i>PROLOG</div></a>
                </div>
            </div>
                </div>
</div>



<div class="lectureContent">

  <div id="errors">
  </div>
  
  <div class="lectureContentMaterial">
  
    <div id="main-content">
    
  <div class="section" id="prolog">
<h1>Програмски језик PROLOG<a class="headerlink" href="#prolog" title="Permalink to this heading">¶</a></h1>
<p>Најзначајнији представник логичке парадигме је програмски језик
PROLOG.</p>
<div class="section" id="id1">
<h2>Кратак историјат развоја<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h2>
<p>Пролог (Prolog) је декларативни, логички програмски језик који је
развијен током 1970-их година, намењен пре свега решавању задатака
симболичке природе.Творцима овог језика сматрају се Алаин Колмерауер
(енгл. Alain Colmerauer) и Филипе Роусел (енгл. Philippe Roussel) на
Универзитету у Марсељу (енгл. University of Aix-Marseille) и Роберт
Ковалски (енгл. Robert Kowalski) са Универзитета у Единбургу
(енгл. University of Edinburgh). На развој пролога значајно је утицао
метод резолуције који је развио Алан Робертсон 1965.</p>
<p>Осамдесетих година прошлог века је постојала група научника која се
бавила рачунарством, која је веровала да је логичко програмирање
најбољи начин да се превазиђе сложеност и непоузданост императивних
језика. У Јапану који је у то доба био у великој технолошкој
експанзији направљен је велики пројекат развоја
рачунара 5. генерације, заснованих на логичком програмирању и
PROLOG-у. Ипак, логичко програмирање није заживело колико и остале
парадигме, пре свега јер програми написани у логичком програмском
језику нису довољно ефикасни као програми написани у неком
еквивалентном императивном језику, као и зато што је област примене
релативно мала (коришћен је углавном у домену аутоматског доказивања
теорема, у имплементацији експертских система, презаписивању термова,
аутоматском планирању).</p>
<p>Постоје савремене надоградње основног језика PROLOG које су веома
ефикасне у решавању неких специјализованих проблема (на пример,
B-PROLOG је веома ефикасан систем за решавање проблема задовољења
ограничења, engl. constraint programming).</p>
</div>
<div class="section" id="id2">
<h2>Развојно окружење<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h2>
<p>Програмски језик PROLOG може и да се интерпретира и да се компилира,
мада се чешће интерпретира. Популарне савремене имплементације су
SWI-Prolog и GNU-Prolog. Ми вам препоручујемо коришћење онлјан
окружења за SWI-Prolog (<a class="reference external" href="https://swish.swi-prolog.org/">https://swish.swi-prolog.org/</a>).</p>
</div>
<div class="section" id="id3">
<h2>Основни појмови језика<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h2>
<p>Логичко програмирање и језик PROLOG су у тесној вези са математичком
логиком. PROLOG програм се задаје помоћу <strong>базе знања</strong> која садржи
чињенице и правила закључивања. Чињенице су атомичке формуле облика:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nv">P</span><span class="p">(</span><span class="s s-Atom">c1</span><span class="p">,</span> <span class="p">...,</span> <span class="s s-Atom">cn</span><span class="p">).</span>
</pre></div>
</div>
<p>Ово одговара атомичкој формули <span class="math notranslate nohighlight">\(P(c_1, \ldots, c_n)\)</span> у којој
је предикат <span class="math notranslate nohighlight">\(P\)</span> примењен на низ константи <span class="math notranslate nohighlight">\(c_1\)</span> до
<span class="math notranslate nohighlight">\(c_n\)</span>. На пример, једна чињеница у бази знања може бити:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">grk</span><span class="p">(</span><span class="s s-Atom">sokrat</span><span class="p">).</span>
</pre></div>
</div>
<p>Приметимо да су и име предиката <code class="docutils literal notranslate"><span class="pre">grk</span></code> и име <code class="docutils literal notranslate"><span class="pre">sokrat</span></code> написани
малим словима (што није правописно исправно), јер се називи свих
предиката и називи свих константи морају писати малим словима.</p>
<p>Правила извођења су облика</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nv">H</span> <span class="p">:-</span> <span class="nv">B1</span><span class="p">,</span> <span class="p">...,</span> <span class="nv">Bn</span><span class="p">.</span>
</pre></div>
</div>
<p>где су и <code class="docutils literal notranslate"><span class="pre">H</span></code> и <code class="docutils literal notranslate"><span class="pre">B1</span></code> до <code class="docutils literal notranslate"><span class="pre">Bn</span></code> атомичке формуле облика</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nv">Bi</span><span class="p">(</span><span class="s s-Atom">t1</span><span class="p">,</span> <span class="p">...,</span> <span class="s s-Atom">tm</span><span class="p">)</span>
</pre></div>
</div>
<p>у којима су <code class="docutils literal notranslate"><span class="pre">t1</span></code> до <code class="docutils literal notranslate"><span class="pre">tm</span></code> обично променљиве (мада могу бити и
константе).</p>
<p>Свако правило извођења одговара импликацији <span class="math notranslate nohighlight">\(B_1 \wedge \ldots
\wedge B_n \Rightarrow H\)</span> тј. клаузули <span class="math notranslate nohighlight">\(\neg B_1 \vee \ldots
\wedge \neg B_n \vee H\)</span> (обратите пажњу на необичан смер импликације
тј. на запис <span class="math notranslate nohighlight">\(H \Leftarrow B_1 \wedge \ldots \wedge
B_n\)</span>. Формула <code class="docutils literal notranslate"><span class="pre">H</span></code> се назива глава правила, формуле <code class="docutils literal notranslate"><span class="pre">B1</span></code> до <code class="docutils literal notranslate"><span class="pre">Bn</span></code>
тело, а симбол <code class="docutils literal notranslate"><span class="pre">:-</span></code> се назива врат и он представља наопако записану
импликацију тј. логички везник <span class="math notranslate nohighlight">\(\Leftarrow\)</span>.</p>
<p>Све променљиве су имплицитно универзално квантификоване. На пример,
правила</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">covek</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">grk</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
<span class="nf">smrtan</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">covek</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>означавају реченице <span class="math notranslate nohighlight">\((\forall X)(\mathrm{grk}(X) \Rightarrow
\mathrm{covek}(X))\)</span> тј. <em>сви Грци су људи</em> и <span class="math notranslate nohighlight">\((\forall
x)(\mathrm{covek}(X) \Rightarrow \mathrm{smrtan}(X))\)</span> тј. <em>сви људи су
смртни</em>.</p>
<p>Поред базе знања, последњи део PROLOG програма је <strong>упит</strong> који је
облика</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nv">A1</span><span class="p">,</span> <span class="p">...,</span> <span class="nv">An</span>
</pre></div>
</div>
<p>где су <code class="docutils literal notranslate"><span class="pre">A1</span></code> до <code class="docutils literal notranslate"><span class="pre">An</span></code> предикати облика:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nv">Ai</span><span class="p">(</span><span class="s s-Atom">t1</span><span class="p">,</span> <span class="p">...,</span> <span class="s s-Atom">tm</span><span class="p">)</span>
</pre></div>
</div>
<p>Упит одговара клаузули <span class="math notranslate nohighlight">\(\neg A_1 \vee \ldots \vee \neg A_n\)</span>.
која је негација формуле <span class="math notranslate nohighlight">\(A_1 \wedge \ldots \wedge A_n\)</span>. Та
формула је логичка последица базе знања акко и само ако се додавањем
клаузуле упита међу клаузуле базе знања може добити празна формула.</p>
<p>На пример, циљ може бити:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">smrtan</span><span class="p">(</span><span class="s s-Atom">sokrat</span><span class="p">).</span>
</pre></div>
</div>
<p>На овај упит PROLOG одговара са <code class="docutils literal notranslate"><span class="pre">true</span></code>, што значи да је та формула
логичка последица базе знања. Заиста, ако је Сократ Грк, ако су сви
Грци људи и ако су сви људи смртни, тада је и сократ смртан.</p>
<p>Дакле PROLOG програм (база знања и упит) представља скуп клаузула
специјалног облика. Такве клаузуле се називају <strong>Хорнове клаузуле</strong> и
за њих је карактеристично да имају највише један позитиван и све
остале негативне литерале. PROLOG методом резолуције изводи празну
клаузулу и ако успе показује вредности променљивих које су до тога
довеле. Захваљујући специјалној структури Хорнових клаузула механизам
резолуције је много ефикаснији него у случају коришћења клаузула
произвољног облика. Са друге стране, наравно, не може се било која
логичка формула изразити у клаузалној форми коришћењем искључиво
Хорнових клаузула.</p>
<p>У нашем примеру, клаузуле нашег програма</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">grk</span><span class="p">(</span><span class="s s-Atom">sokrat</span><span class="p">).</span>
<span class="nf">covek</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">grk</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
<span class="nf">smrtan</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="s s-Atom">:=</span> <span class="nf">covek</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
<span class="s s-Atom">?-</span> <span class="nf">smrtan</span><span class="p">(</span><span class="s s-Atom">sokrat</span><span class="p">).</span>
</pre></div>
</div>
<p>су</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{grk}(\mathrm{sokrat})\\
\neg \mathrm{grk}(X) \vee \mathrm{covek}(X)\\
\neg \mathrm{covek}(X) \vee \mathrm{smrtan}(X)\\
\neg \mathrm{smrtan}(\mathrm{sokrat})\end{split}\]</div>
<p>Резолуцијом средње две клаузуле добија се клаузула <span class="math notranslate nohighlight">\(\neg
\mathrm{grk}(X) \vee \mathrm{smrtan}(X)\)</span>, која се онда може
резолвирати са првом и четвртом клаузулом (након инстанцијације
<span class="math notranslate nohighlight">\(X=\mathrm{sokrat}\)</span>) и тако извести празна клаузула.</p>
<p>Обратите пажњу на то да PROLOG закључке изводи искључиво на основу
чињеница и правила које су екплицитно кодирани кроз базу знања. На
пример, одговор на упит</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">smrtan</span><span class="p">(</span><span class="s s-Atom">platon</span><span class="p">).</span>
</pre></div>
</div>
<p>је <code class="docutils literal notranslate"><span class="pre">false</span></code>, јер се додавањем клаузуле <span class="math notranslate nohighlight">\(\neg
\mathrm{smrtan}(\mathrm{platon})\)</span> из базе знања не може извести празна
клаузула (јер се на основу наше базе знања не може закључити да је
Платон Грк).</p>
<p>Ако упит садржи променљиве, PROLOG исписује и вредности тих
променљивих које доводе до извођења празне клаузуле. На пример, на
упит</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">smrtan</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>PROLOG одговара са <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">sokrat</span></code>. Ако после затражимо друга решења,
добићемо одговор <code class="docutils literal notranslate"><span class="pre">false</span></code>, јер друга решења не постоје. Ако би база
знања садржала и чињеницу</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">grk</span><span class="p">(</span><span class="s s-Atom">platon</span><span class="p">).</span>
</pre></div>
</div>
<p>Добили бисмо решења <code class="docutils literal notranslate"><span class="pre">X=sokrat</span></code>, <code class="docutils literal notranslate"><span class="pre">X=platon</span></code> и након тога одговор
<code class="docutils literal notranslate"><span class="pre">false</span></code>, што значи да осим ових нема више решења.</p>
</div>
<div class="section" id="id4">
<h2>Пример: породично стабло<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h2>
<p>Кодирајмо за почетак које особе чине ужу породицу Симпсон (све су
представљене константама) и ког су пола.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">musko</span><span class="p">(</span><span class="s s-Atom">homer</span><span class="p">).</span>
<span class="nf">zensko</span><span class="p">(</span><span class="s s-Atom">mardz</span><span class="p">).</span>
<span class="nf">musko</span><span class="p">(</span><span class="s s-Atom">bart</span><span class="p">).</span>
<span class="nf">zensko</span><span class="p">(</span><span class="s s-Atom">liza</span><span class="p">).</span>
<span class="nf">zensko</span><span class="p">(</span><span class="s s-Atom">megi</span><span class="p">).</span>
</pre></div>
</div>
<p>Дефинишимо правила којима закључујемо ко су особе у породици Симпсон.
Мушке особе су особе и женске особе су особе. Додајемо зато следећа
два правила извођења.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% osobe u porodici Simpson su ili muske ili zenske osobe</span>
<span class="nf">osoba</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">musko</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
<span class="nf">osoba</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">zensko</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>Не заборавимо да импликација тече здесна налево тј. овде су дата
правила <span class="math notranslate nohighlight">\((\forall X)(\mathrm{musko}(X) \Rightarrow
\mathrm{osoba}(X))\)</span> и <span class="math notranslate nohighlight">\((\forall X)(\mathrm{zensko}(X)
\Rightarrow \mathrm{osoba}(X))\)</span>. Уместо два правила могуће је навести
и једно правило:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% osobe u porodici Simpson su ili muske ili zenske osobe</span>
<span class="nf">osoba</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">musko</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">;</span> <span class="nf">zensko</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>Оператор <code class="docutils literal notranslate"><span class="pre">;</span></code> је оператор дисјункције, па је овим задана импликација
<span class="math notranslate nohighlight">\((\forall X)(\mathrm{musko}(X) \vee \mathrm{zensko}(X)
\Rightarrow \mathrm{osoba}(X))\)</span>, која приликом превођења у клаузалну
форму даје потпуно исте две клаузуле <span class="math notranslate nohighlight">\(\neg \mathrm{musko}(X)
\vee \mathrm{osoba}(X)\)</span> и <span class="math notranslate nohighlight">\(\neg \mathrm{zensko}(X) \vee
\mathrm{osoba}(X)\)</span> као и када се особа опише помоћу два независна
правила.</p>
<p>Коректност овог правила можемо проверити постављањем упита</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">osoba</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>Ако је све како треба, требало би да добијемо пет одговора
<code class="docutils literal notranslate"><span class="pre">X=homer</span></code>, <code class="docutils literal notranslate"><span class="pre">X=mardz</span></code>, <code class="docutils literal notranslate"><span class="pre">X=bart</span></code>, <code class="docutils literal notranslate"><span class="pre">X=liza</span></code>, <code class="docutils literal notranslate"><span class="pre">X=megi</span></code> и затим
одговор <code class="docutils literal notranslate"><span class="pre">false</span></code> који означава да су ово једина решења.</p>
<p>Прошириом базу знања односима родитељ-дете</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">roditelj</span><span class="p">(</span><span class="s s-Atom">homer</span><span class="p">,</span> <span class="s s-Atom">bart</span><span class="p">).</span>
<span class="nf">roditelj</span><span class="p">(</span><span class="s s-Atom">homer</span><span class="p">,</span> <span class="s s-Atom">liza</span><span class="p">).</span>
<span class="nf">roditelj</span><span class="p">(</span><span class="s s-Atom">homer</span><span class="p">,</span> <span class="s s-Atom">megi</span><span class="p">).</span>
<span class="nf">roditelj</span><span class="p">(</span><span class="s s-Atom">mardz</span><span class="p">,</span> <span class="s s-Atom">bart</span><span class="p">).</span>
<span class="nf">roditelj</span><span class="p">(</span><span class="s s-Atom">mardz</span><span class="p">,</span> <span class="s s-Atom">liza</span><span class="p">).</span>
<span class="nf">roditelj</span><span class="p">(</span><span class="s s-Atom">mardz</span><span class="p">,</span> <span class="s s-Atom">megi</span><span class="p">).</span>
</pre></div>
</div>
<p>Дефинишимо на основу овога предикате <code class="docutils literal notranslate"><span class="pre">otac</span></code>, <code class="docutils literal notranslate"><span class="pre">majka</span></code>, <code class="docutils literal notranslate"><span class="pre">sin</span></code> и
<code class="docutils literal notranslate"><span class="pre">cerka</span></code>.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% osfalsevna pravila izvodjenja za uzu porodicu</span>
<span class="nf">otac</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">musko</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nf">majka</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">zensko</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nf">sin</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">musko</span><span class="p">(</span><span class="nv">Y</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nf">cerka</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">zensko</span><span class="p">(</span><span class="nv">Y</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
</pre></div>
</div>
<p>Прво правило се може тумачити као импликација</p>
<div class="math notranslate nohighlight">
\[(\forall X)(\forall Y)(\mathrm{musko}(X) \wedge \mathrm{roditelj}(X, Y) \Rightarrow \mathrm{otac}(X, Y))\]</div>
<p>тј. <em>ако је X мушко и родитељ је особи Y онда је X отац особи
Y</em>. Остала правила се тумаче аналогно.</p>
<p>Можемо проверити ова правила постављањем разних упита. На пример,
ко су Хомерове ћерке</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">cerka</span><span class="p">(</span><span class="s s-Atom">homer</span><span class="p">,</span> <span class="nv">X</span><span class="p">)</span>
</pre></div>
</div>
<p>PROLOG проналази два решења <code class="docutils literal notranslate"><span class="pre">X=liza</span></code> и <code class="docutils literal notranslate"><span class="pre">X=megi</span></code>.</p>
<p>Покушајмо да дефинишемо сада релације брат и сестра.  Особа X је брат
особи Y ако је X мушко и ако имају заједничког родитеља. Желимо,
дакле, да кодирамо импликацију</p>
<div class="math notranslate nohighlight">
\[(\forall x)(\forall y)(\mathrm{musko}(x) \wedge ((\exists z)\mathrm{roditelj}(z, x) \wedge \mathrm{roditelj}(z, y)) \Rightarrow \mathrm{brat}(x, y))\]</div>
<p>Она није у Хорновом облику, али се лако може проверити да је
еквивалентна следећој импликацији, која јесте у Хорновом облику.</p>
<div class="math notranslate nohighlight">
\[(\forall x)(\forall y)(\forall z)(\mathrm{musko}(x) \wedge \mathrm{roditelj}(z, x) \wedge \mathrm{roditelj}(z, y) \Rightarrow \mathrm{brat}(x, y))\]</div>
<p>На основу овога долазимо до следећих правила:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">brat</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">musko</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">X</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nf">sestra</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">zensko</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">X</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
</pre></div>
</div>
<p>Покушајмо да тестирамо ова правила тиме што ћемо проверити коме је све
Барт брат. Постављамо упит</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">brat</span><span class="p">(</span><span class="s s-Atom">bart</span><span class="p">,</span> <span class="nv">X</span><span class="p">)</span>
</pre></div>
</div>
<p>PROLOG пронаалази тачне одговоре <code class="docutils literal notranslate"><span class="pre">X=liza</span></code> и <code class="docutils literal notranslate"><span class="pre">X=megi</span></code>, али
проналази и нетачан одговор <code class="docutils literal notranslate"><span class="pre">X=bart</span></code> што значи да је Барт сам свој
брат. Заиста, то се потпуно уклапа у наше правило (Барт је мушко и има
заједничког родитеља као Барт). Да бисмо избегли овај погрешан
одговор, потребно је да додамо услов да су променљиве <code class="docutils literal notranslate"><span class="pre">X</span></code> и <code class="docutils literal notranslate"><span class="pre">Y</span></code>
различите. То можемо изразити помоћу <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">\=</span> <span class="pre">Y</span></code>. Негација и
различитост у PROLOG-у су веома суптилна места и треба их добро
разумети да се не би правиле грешке, али ћемо се том темом посебно
бавити касније. У овом контексту исправно је предикате дефинисати на
следећи начин.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">brat</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">musko</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">X</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">),</span>  <span class="nv">X</span> <span class="s s-Atom">\=</span> <span class="nv">Y</span><span class="p">.</span>
<span class="nf">sestra</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">zensko</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">X</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">),</span> <span class="nv">X</span> <span class="s s-Atom">\=</span> <span class="nv">Y</span><span class="p">.</span>
</pre></div>
</div>
<p>Приметимо да се решење <code class="docutils literal notranslate"><span class="pre">X=liza</span></code> проналази два пута и да се решење
<code class="docutils literal notranslate"><span class="pre">X=megi</span></code> такође проналази два пута. То је због тога што се у оба
случаја проналази једном заједнички родитељ Хомер, а у другом
заједнички родите Марџ (променљива <code class="docutils literal notranslate"><span class="pre">Z</span></code> може да узме две различите
вредности, што се не види, јер се на крају исписују само вредности
променљиве <code class="docutils literal notranslate"><span class="pre">Y</span></code>).</p>
<p>Проширимо сада базу знања чињеницама о Абрахану и Мони који су
Хомерови родитељи и Кленсију и Жеклин који су Марџини родитељи.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% baza znanja za babe i dede (po ocu)</span>
<span class="nf">musko</span><span class="p">(</span><span class="s s-Atom">abraham</span><span class="p">).</span>
<span class="nf">roditelj</span><span class="p">(</span><span class="s s-Atom">abraham</span><span class="p">,</span> <span class="s s-Atom">homer</span><span class="p">).</span>
<span class="nf">zensko</span><span class="p">(</span><span class="s s-Atom">mona</span><span class="p">).</span>
<span class="nf">roditelj</span><span class="p">(</span><span class="s s-Atom">mona</span><span class="p">,</span> <span class="s s-Atom">homer</span><span class="p">).</span>
<span class="c1">% baza znanja za babe i dede (po majci)</span>
<span class="nf">musko</span><span class="p">(</span><span class="s s-Atom">klensi</span><span class="p">).</span>
<span class="nf">roditelj</span><span class="p">(</span><span class="s s-Atom">klensi</span><span class="p">,</span> <span class="s s-Atom">mardz</span><span class="p">).</span>
<span class="nf">zensko</span><span class="p">(</span><span class="s s-Atom">zeklin</span><span class="p">).</span>
<span class="nf">roditelj</span><span class="p">(</span><span class="s s-Atom">zeklin</span><span class="p">,</span> <span class="s s-Atom">mardz</span><span class="p">).</span>
</pre></div>
</div>
<p>Добијамо упозорење да су чињенице које се односе на предикате
<code class="docutils literal notranslate"><span class="pre">musko</span></code>, <code class="docutils literal notranslate"><span class="pre">zensko</span></code> и <code class="docutils literal notranslate"><span class="pre">roditelj</span></code> раштркане по програму. Да бисмо
ово упозорење избегли можемо или да групишемо све чињенице за исти
предикат, или да издамо наредбу:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="p">:-</span> <span class="s s-Atom">discontiguous</span> <span class="s s-Atom">musko</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span> <span class="s s-Atom">zensko</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span> <span class="s s-Atom">roditelj</span><span class="o">/</span><span class="mf">2.</span>
</pre></div>
</div>
<p>Сада једноставно можемо да дефинишемо предикате деда и баба.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">deda</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">otac</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Z</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nf">baba</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">majka</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Z</span><span class="p">),</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
</pre></div>
</div>
<p>Међутим, још интересантније су дефиниције предиката којима се описују
преци и потомци, јер су те дефиниције у суштини рекурзивне. Довољно је
да дефинишемо, на пример, релацију предак, јер се релација потомак
може веома једноставно дефинисати преко релације предак (то јој је
заправо супротна релација).</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">potomak</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">predak</span><span class="p">(</span><span class="nv">Y</span><span class="p">,</span> <span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>Приметимо да је ова дефиниција исправна без обзира на то што још није
дефинисана релација <code class="docutils literal notranslate"><span class="pre">predak</span></code>. Чим она буде дефинисана, моћи ћемо да
користимо и дефиницију релације <code class="docutils literal notranslate"><span class="pre">potomak</span></code>. Наиме, базу знања у
идеалном случају треба схватити као скуп правила чијим се коришћењем
изводе закључци и редослед навођења правила не би требало да утиче на
резултат рада програма (видећемо касније да се од овог идеалног
случаја често одступа, да би се постигла већа ефикасност).</p>
<p>Родитељ неке особе јој је сигурно предак. Такође, било који предак
њеног родитеља јој је такође предак.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">predak</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
<span class="nf">predak</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">),</span> <span class="nf">predak</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Z</span><span class="p">).</span>
</pre></div>
</div>
<p>Прво правило, наравно, можемо да тумачимо као</p>
<div class="math notranslate nohighlight">
\[(\forall X)(\forall Y)(\mathrm{roditelj}(X, Y) \Rightarrow \mathrm{predak}(X, Y))\]</div>
<p>док друга правило можемо да тумачимо као</p>
<div class="math notranslate nohighlight">
\[(\forall X)(\forall Y)(\forall Z)(\mathrm{roditelj}(Z, Y) \wedge \mathrm{predak}(X, Z) \Rightarrow \mathrm{predak}(X, Y))\]</div>
<p>али и еквивалентно као</p>
<div class="math notranslate nohighlight">
\[(\forall X)(\forall Y)(((\exists Z)\mathrm{roditelj}(Z, Y) \wedge \mathrm{predak}(X, Z)) \Rightarrow \mathrm{predak}(X, Y))\]</div>
<p>Наравно, претходна два правила можемо објединити коришћењем дисјункције.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">predak</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">;</span> <span class="nf">roditelj</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span> <span class="nv">Y</span><span class="p">),</span> <span class="nf">predak</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Z</span><span class="p">).</span>
</pre></div>
</div>
<p>На овај начин можемо да сазнамо, на пример, све Мегине претке. На упит</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">predak</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="s s-Atom">megi</span><span class="p">)</span>
</pre></div>
</div>
<p>добијамо одговоре <code class="docutils literal notranslate"><span class="pre">X=homer</span></code>, <code class="docutils literal notranslate"><span class="pre">X=mardz</span></code>, <code class="docutils literal notranslate"><span class="pre">X=klensi</span></code>,
<code class="docutils literal notranslate"><span class="pre">X=zeklin</span></code>, <code class="docutils literal notranslate"><span class="pre">X=abraham</span></code> и <code class="docutils literal notranslate"><span class="pre">X=mona</span></code>, при чему редослед одговора
зависи од редоследа навођења чињеница у бази знања.</p>
<p>Проширите, за вежбу, базу знања чињеницама о Хомеровом брату и
Марџиним сестрама и дефинишите предикате стриц, тетка и ујак.</p>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>Нагласимо још једном декларативну природу претходних програма. Ни у
једном тренутку није било потребе да описујемо начин извођења
закључака. Довољно је било опишемо услове који треба да важе, а
систем је тај који својим уграђеним алгоритмима проналази вредности
које задовољавају дате услове. За логичко програмирање се каже да
алгоритам обједињава <strong>логику</strong> и <strong>контролу</strong>, при чему програмер
задаје логику, а контролу извршава систем. Систем може да примени
различите стратегије извршавања (доказивања теорема) да би што
ефикасније дошао до решења.</p>

    </div></div>
</div>
<div class="section" id="id5">
<h2>Дрво извођења<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h2>
<p>Задатак програмера је да кроз базу знања опише чињенице и правила
закључивања, а задатак PROLOG система је да провери да ли је дати упит
логичка последица базе знања. Иако програмер не би требало да води
рачуна о томе како се та провера врши (рекли смо да се у основи крије
механизам резолуције), често се ипак тај механизам представља дрветом
које помаже да се разуме шта се у позадини дешава.</p>
</div>
<div class="section" id="id6">
<h2>Функције<a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h2>
<p>За разлику од функционалних, али и императивних и
објектно-оријентисаних језика где програмери углавном дефинишу
функције које на основу задатих аргумената израчунавају резултате,
основу PROLOGA чине предикати тј. релације. Писање функција није
директно подржано. Ипак, већ смо видели да се релације постављањем
одговарајућих упита могу користити и као функције. На пример, у
функционалном језику написали бисмо функцију <code class="docutils literal notranslate"><span class="pre">brat(X)</span></code> која би као
параметар примала особу, а као резултат враћала њеног брата.  У
прологу смо дефинисали предикат <code class="docutils literal notranslate"><span class="pre">brat(X,</span> <span class="pre">Y)</span></code>, а затим смо, на
пример, помоћу упита <code class="docutils literal notranslate"><span class="pre">brat(X,</span> <span class="pre">liza)</span></code> могли да „израчунамо” да је
Лизин брат Барт. Могли смо заправо и више од тога. Упитом <code class="docutils literal notranslate"><span class="pre">brat(bart,</span>
<span class="pre">X)</span></code> могли смо да израчунамо чији је све брат Барт. Дакле, једна
релација, у зависности од тога како се упит поставља нам омогућава
више израчунавања тј. у себи крије више функција. Видећемо да ово
често може да буде изненађујуће, тј. да добијамо „гратис” могућност
неких израчунавања која нисмо имали у виду када смо дефинисали
релацију.</p>
<p>Дакле, уместо дефинисања функција облика</p>
<div class="math notranslate nohighlight">
\[y = f(x_1, \ldots, x_n)\]</div>
<p>PROLOG допушта дефинисање релација облика</p>
<div class="math notranslate nohighlight">
\[R(x_1, \ldots, x_n, y)\]</div>
<p>које се онда могу користити као функције тако што се аргументи
<span class="math notranslate nohighlight">\(x_1\)</span> до <span class="math notranslate nohighlight">\(x_n\)</span> фиксирају у упиту, а <cite>y</cite> се зада као
променљива чија се вредност аутоматски одређује. При том, сви
аргументи релације су симетрични и могуће је да било који од њих (па и
више њих истовремено) буду задати као променљиве чије се вредности
одређују.</p>
</div>
<div class="section" id="id7">
<h2>Негација као неуспех<a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h2>
<p>Сви предикати са десне стране правила су задавани у позитивном облику
(ако изузмемо пример различитости две променљиве, што је негативни
облик). PROLOG даје подршку за негацију, али је та негација специфична
и не понаша се исто као класична логичка негација. Тај облик негације
се назива <strong>негација као неуспех</strong> (енгл. negation as failure).</p>
<p>Покушајмо да дефинишемо предикат женско, као негацију предиката мушко.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="c1">% Negacija kao neuspeh</span>
<span class="nf">zensko</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">falset</span><span class="p">(</span><span class="nf">musko</span><span class="p">(</span><span class="nv">X</span><span class="p">)).</span>
</pre></div>
</div>
<p>Очекујемо да се ово може тумачити као импликација <span class="math notranslate nohighlight">\((\forall
X)(\neg \mathrm{musko}(X) \Rightarrow \mathrm{zensko}(X))\)</span>. Међутим,
упити показују на неуобичајено понашање.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">zensko</span><span class="p">(</span><span class="s s-Atom">homer</span><span class="p">).</span>  <span class="c1">% false</span>
<span class="s s-Atom">?-</span> <span class="nf">zensko</span><span class="p">(</span><span class="s s-Atom">mardz</span><span class="p">).</span>  <span class="c1">% true</span>
<span class="s s-Atom">?-</span> <span class="nf">zensko</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>      <span class="c1">% false</span>
</pre></div>
</div>
<p>PROLOG успешно одређује да Хомер није женско, да Марџ јесте женско,
међутим, када се упита да наброји женске особе, добија се да не
постоји ни једна. Понашање операције <code class="docutils literal notranslate"><span class="pre">falset</span></code> је такво да она успева
ако и само ако јој аргумент не успева.</p>
<ul class="simple">
<li><p>Упит <code class="docutils literal notranslate"><span class="pre">zensko(homer)</span></code> се своди на упит <code class="docutils literal notranslate"><span class="pre">falset(musko(homer))</span></code>. Пошто
упит <code class="docutils literal notranslate"><span class="pre">musko(homer)</span></code> успева, упит <code class="docutils literal notranslate"><span class="pre">zensko(homer)</span></code> не успева и
исправно се враћа резултат <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
<li><p>Упит <code class="docutils literal notranslate"><span class="pre">zensko(mardz)</span></code> се своди на упит <code class="docutils literal notranslate"><span class="pre">falset(musko(mardz))</span></code>. Пошто
упит <code class="docutils literal notranslate"><span class="pre">musko(mardz)</span></code> не успева, упит <code class="docutils literal notranslate"><span class="pre">zensko(mardz)</span></code> успева и
исправно се враћа резултат <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
<li><p>Упит <code class="docutils literal notranslate"><span class="pre">zensko(X)</span></code> се своди на упит <code class="docutils literal notranslate"><span class="pre">falset(musko(X))</span></code>. Упит
<code class="docutils literal notranslate"><span class="pre">musko(X)</span></code> успева, при чему се добија вредност <code class="docutils literal notranslate"><span class="pre">X=homer</span></code>.
Међутим, пошто подупит <code class="docutils literal notranslate"><span class="pre">musko(X)</span></code> успева, упит <code class="docutils literal notranslate"><span class="pre">falset(musko(X))</span></code>,
по дефиницији негације, не успева, па самим тим <code class="docutils literal notranslate"><span class="pre">zensko(X)</span></code> враћа
неисправан резултат <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
</ul>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>Негација у PROLOG-у има другачије понашање од класичне логичке
негације!</p>

    </div></div>
</div>
<div class="section" id="id8">
<h2>Аритметичка израчунавања<a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h2>
<p>Иако је PROLOG заснован на математичкој логици и његову основу, као
што смо видели чини симболичко израчунавање, програмирање се не може
замислити без нумеричког израчунавања тј. рада са бројевима. PROLOG
подржава рад и са целим и са реалним бројевима, али jе често за то
потребно користити посебну подршку.</p>
<p>Кренимо од употребе релацијских оператора. Дефинишимо предикате којима
се одређује агрегатно стање воде.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">cvrsto</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nv">X</span> <span class="o">&lt;</span> <span class="mf">0.</span>
<span class="nf">tecno</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nv">X</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">X</span> <span class="o">&lt;</span> <span class="mf">100.</span>
<span class="nf">gasovito</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nv">X</span> <span class="o">&gt;=</span> <span class="mf">100.</span>
</pre></div>
</div>
<p>Ови предикати су коректно дефинисани и дају исправан резултат за сваку
проверу.</p>
<p>Интересантан је и следећи пример. У бази знања памтимо почетак и крај
владавине неколико краљева из династије Немањића. Затим дефинишемо да
је неко био краљ током дате године, ако је та година унутар интервала
његове владавине.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">kralj_od_do</span><span class="p">(</span><span class="s s-Atom">stefan</span><span class="p">,</span> <span class="mi">1217</span><span class="p">,</span> <span class="mi">1228</span><span class="p">).</span>
<span class="nf">kralj_od_do</span><span class="p">(</span><span class="s s-Atom">radoslav</span><span class="p">,</span> <span class="mi">1228</span><span class="p">,</span> <span class="mi">1233</span><span class="p">).</span>
<span class="nf">kralj_od_do</span><span class="p">(</span><span class="s s-Atom">vladislav</span><span class="p">,</span> <span class="mi">1234</span><span class="p">,</span> <span class="mi">1243</span><span class="p">).</span>
<span class="nf">kralj_od_do</span><span class="p">(</span><span class="s s-Atom">uros</span><span class="p">,</span> <span class="mi">1243</span><span class="p">,</span> <span class="mi">1276</span><span class="p">).</span>
<span class="nf">kralj_od_do</span><span class="p">(</span><span class="s s-Atom">dragutin</span><span class="p">,</span> <span class="mi">1276</span><span class="p">,</span> <span class="mi">1282</span><span class="p">).</span>
<span class="nf">kralj</span><span class="p">(</span><span class="nv">Ime</span><span class="p">,</span> <span class="nv">Godina</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">kralj_od_do</span><span class="p">(</span><span class="nv">Ime</span><span class="p">,</span> <span class="nv">GodinaOd</span><span class="p">,</span> <span class="nv">GodinaDo</span><span class="p">),</span>
                      <span class="nv">GodinaOd</span> <span class="o">=&lt;</span> <span class="nv">Godina</span><span class="p">,</span> <span class="nv">Godina</span> <span class="o">=&lt;</span> <span class="nv">GodinaDo</span><span class="p">.</span>
</pre></div>
</div>
<p>Сада можемо да питамо и ко је био краљ током 1250. године.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">kralj</span><span class="p">(</span><span class="nv">Ime</span><span class="p">,</span> <span class="mi">1250</span><span class="p">).</span>
</pre></div>
</div>
<p>Систем исправно изводи закључак да је једини краљ током те године био
Урош.</p>
<p>Релацијски оператори се, дакле, на први поглед понашају прилично
очекивано. Међутим, PROLOG неће успети да нам одговори током којих је
све година Стефан био краљ.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">kralj</span><span class="p">(</span><span class="s s-Atom">stefan</span><span class="p">,</span> <span class="nv">Godina</span><span class="p">).</span>
</pre></div>
</div>
<p>На овај упит добијамо odgovor</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Arguments</span> <span class="n">are</span> <span class="ow">not</span> <span class="n">sufficiently</span> <span class="n">instantiated</span>
<span class="n">In</span><span class="p">:</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="mi">1217</span> <span class="o">=&lt;</span> <span class="n">_1702</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">kralj</span><span class="p">(</span><span class="n">stefan</span><span class="p">,</span><span class="n">_1756</span><span class="p">)</span> <span class="n">at</span>  <span class="n">line</span> <span class="mi">7</span>
</pre></div>
</div>
<p>који нам одговара да није могуће да се релацијски оператор примени на
променљиву којој још није одређена вредност (у нашем случају то је
променљива <code class="docutils literal notranslate"><span class="pre">Godina</span></code>).</p>
<p>Размотримо сада следећи пример предиката који користи операцију
сабирања.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">zbir</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">Z</span><span class="p">)</span> <span class="p">:-</span> <span class="nv">Z</span> <span class="o">==</span> <span class="nv">X</span> <span class="o">+</span> <span class="nv">Y</span><span class="p">.</span>
</pre></div>
</div>
<p>Ова дефиниција је синтаксички исправна, што значи да PROLOG зна нешто
о сабирању и једнакости. Међутим, ако поставимо следећи упит:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">zbir</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">).</span>
</pre></div>
</div>
<p>неочекивано добијамо неисправан одговор <code class="docutils literal notranslate"><span class="pre">false</span></code>. И на упит</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">zbir</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>добијамо одговор <code class="docutils literal notranslate"><span class="pre">false</span></code>. Међутим, ако поставимо упит</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">zbir</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">5</span><span class="p">).</span>
</pre></div>
</div>
<p>Добијамо одговор <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>Нешто очигледно није како треба. Покушајмо да променимо дефиницију
предиката <code class="docutils literal notranslate"><span class="pre">zbir</span></code> и да уместо оператора <code class="docutils literal notranslate"><span class="pre">==</span></code> употребимо оператор
<code class="docutils literal notranslate"><span class="pre">=</span></code>.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">zbir</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">Z</span><span class="p">)</span> <span class="p">:-</span> <span class="nv">Z</span> <span class="o">=</span> <span class="nv">X</span> <span class="o">+</span> <span class="nv">Y</span><span class="p">.</span>
</pre></div>
</div>
<p>И ова дефиниција је синтаксички исправна, што значи да PROLOG користи
и оператор <code class="docutils literal notranslate"><span class="pre">==</span></code> и <code class="docutils literal notranslate"><span class="pre">=</span></code> (и видећемо да они означавају различите
ствари). Међутим, ако поставимо следећи упит:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">zbir</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">).</span>
</pre></div>
</div>
<p>поново добијамо неисправан одговор <code class="docutils literal notranslate"><span class="pre">false</span></code>. Са друге стране, на упит</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">zbir</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>сада добијамо одговор <code class="docutils literal notranslate"><span class="pre">3+5</span></code>, што је делимично тачно (јер, наравно,
очекујемо одговор <code class="docutils literal notranslate"><span class="pre">8</span></code>). Поново на упит</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">zbir</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">5</span><span class="p">).</span>
</pre></div>
</div>
<p>добијамо тачан одговор <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>Шта се заправо овде догађа? Оператор <code class="docutils literal notranslate"><span class="pre">==</span></code> је <strong>оператор провере
једнакости</strong> два терма и он враћа вредност тачно ако и само ако су
термови идентични.</p>
<ul class="simple">
<li><p>Упит <code class="docutils literal notranslate"><span class="pre">?-</span> <span class="pre">zbir(3,</span> <span class="pre">5,</span> <span class="pre">8)</span></code> се своди на <code class="docutils literal notranslate"><span class="pre">8</span> <span class="pre">==</span> <span class="pre">3+5</span></code>. Проверава се да ли
су терм са леве и десне стране идентични, они то нису и добија се
одговор <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
<li><p>Упит <code class="docutils literal notranslate"><span class="pre">?-</span> <span class="pre">zbir(3,</span> <span class="pre">5,</span> <span class="pre">X)</span></code> се своди на <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">==</span> <span class="pre">3+5</span></code>. Проверава се да ли
су терм са леве и десне стране идентични, они то нису и добија се
одговор <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
<li><p>Упит <code class="docutils literal notranslate"><span class="pre">?-</span> <span class="pre">zbir(3,</span> <span class="pre">5,</span> <span class="pre">3+5)</span></code> се своди на <code class="docutils literal notranslate"><span class="pre">3+5</span> <span class="pre">==</span> <span class="pre">3+5</span></code>. Проверава се да
ли су терм са леве и десне стране идентични, они јесу идентични и
добија се одговор <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p></li>
</ul>
<p>Оператор <code class="docutils literal notranslate"><span class="pre">=</span></code> је <strong>оператор унификације</strong> и он враћа вредност тачно
ако и само ако се термови могу унификовати тј. ако се променљивама
доделити вредности тако да два термови постану једнаки након те
доделе.</p>
<ul class="simple">
<li><p>Упит <code class="docutils literal notranslate"><span class="pre">?-</span> <span class="pre">zbir(3,</span> <span class="pre">5,</span> <span class="pre">8)</span></code> се своди на <code class="docutils literal notranslate"><span class="pre">8</span> <span class="pre">=</span> <span class="pre">3+5</span></code>. Пошто се термови не
могу унификовати (у њима се ни не јављају променљиве) добија се
одговор <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
<li><p>Упит <code class="docutils literal notranslate"><span class="pre">?-</span> <span class="pre">zbir(3,</span> <span class="pre">5,</span> <span class="pre">X)</span></code> се своди на <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">3+5</span></code>. Термови са леве и
десне стране се могу унификовати тако што се променљивој <code class="docutils literal notranslate"><span class="pre">X</span></code>
додели вредност <code class="docutils literal notranslate"><span class="pre">3+5</span></code>, па упит успева уз резултат <code class="docutils literal notranslate"><span class="pre">X=3+5</span></code>.</p></li>
<li><p>Упит <code class="docutils literal notranslate"><span class="pre">?-</span> <span class="pre">zbir(3,</span> <span class="pre">5,</span> <span class="pre">3+5)</span></code> се своди на <code class="docutils literal notranslate"><span class="pre">3+5</span> <span class="pre">==</span> <span class="pre">3+5</span></code>. Термови са леве
и десне стране су идентични (па се самим тим могу и унификовати) и
као резултат се добија <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p></li>
</ul>
<p>Објаснили смо операторе <code class="docutils literal notranslate"><span class="pre">==</span></code> и <code class="docutils literal notranslate"><span class="pre">=</span></code>, међутим ни један од њих нам не
одговара у потпуности. Да би се извршило сабирање (или било која друга
аритметичка операција), потребно је да се употреби оператор <code class="docutils literal notranslate"><span class="pre">is</span></code>.
Њиме се проверава да ли се термови са леве и десне стране могу
унификовати, али тек након што се терм са десне стране израчуна.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">zbir</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">Z</span><span class="p">)</span> <span class="p">:-</span> <span class="nv">Z</span> <span class="o">is</span> <span class="nv">X</span> <span class="o">+</span> <span class="nv">Y</span><span class="p">.</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Упит <code class="docutils literal notranslate"><span class="pre">?-</span> <span class="pre">zbir(3,</span> <span class="pre">5,</span> <span class="pre">8)</span></code> се своди на <code class="docutils literal notranslate"><span class="pre">8</span> <span class="pre">is</span> <span class="pre">3+5</span></code>. Када се израчуна
вредност терма са десне стране, добија се вредност 8, па пошто су
лева и десна страна тада једнаке, добија се исправан резултат
<code class="docutils literal notranslate"><span class="pre">true</span></code>.</p></li>
<li><p>Упит <code class="docutils literal notranslate"><span class="pre">?-</span> <span class="pre">zbir(3,</span> <span class="pre">5,</span> <span class="pre">X)</span></code> се своди на <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">is</span> <span class="pre">3+5</span></code>. Када се израчуна
терм са десне стране добијају се термови <code class="docutils literal notranslate"><span class="pre">X</span></code> и <code class="docutils literal notranslate"><span class="pre">8</span></code>, па пошто се
они могу унификовати тако што се променљивој <code class="docutils literal notranslate"><span class="pre">X</span></code> додели вредност
<code class="docutils literal notranslate"><span class="pre">8</span></code>, упит успева уз резултат <code class="docutils literal notranslate"><span class="pre">X=8</span></code>.</p></li>
<li><p>Упит <code class="docutils literal notranslate"><span class="pre">?-</span> <span class="pre">zbir(3,</span> <span class="pre">5,</span> <span class="pre">3+5)</span></code> се своди на <code class="docutils literal notranslate"><span class="pre">3+5</span> <span class="pre">is</span> <span class="pre">3+5</span></code>. Када се
израчуна вредност терма са десне стране, добијају се термови <code class="docutils literal notranslate"><span class="pre">3+5</span></code>
и <code class="docutils literal notranslate"><span class="pre">8</span></code>, који се не могу унификовати и добија се погрешан резултат
<code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
</ul>
<p>Дакле, ако употребимо оператор <code class="docutils literal notranslate"><span class="pre">is</span></code> добијамо исправну могућност
израчунавања вредности израза (у том светлу најзначајнији нам је упит
<code class="docutils literal notranslate"><span class="pre">zbir(3,</span> <span class="pre">5,</span> <span class="pre">X)</span></code>), при чему и провера израчунате вредности ради
исправно (упит <code class="docutils literal notranslate"><span class="pre">zbir(3,</span> <span class="pre">5,</span> <span class="pre">8)</span></code> коректно ради).</p>
<p>Међутим, важно је нагласити да се из ове релације не могу издвојити
друге функције. На пример, упит <code class="docutils literal notranslate"><span class="pre">?-</span> <span class="pre">zbir(X,</span> <span class="pre">5,</span> <span class="pre">8)</span></code> даје одговор
<code class="docutils literal notranslate"><span class="pre">no</span></code>. Решавање једначина, дакле, није могуће.</p>
<p>Оператори поређења на једнакост <code class="docutils literal notranslate"><span class="pre">=:=</span></code> и различитост <code class="docutils literal notranslate"><span class="pre">=\=</span></code> такође
врше израчунавање термова пре поређења.</p>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>Када год употребљавате аритметичке операторе, морате употребити и
оператор <code class="docutils literal notranslate"><span class="pre">is</span></code>, <code class="docutils literal notranslate"><span class="pre">=:=</span></code> или <code class="docutils literal notranslate"><span class="pre">=\=</span></code> којим ћете натерати систем да
их примени тј. да изврши потребна израчунавања!</p>

    </div></div>
<p>Релацијски оператори су описани у следећој табели.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Оператор</p></th>
<th class="head"><p>Опис</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">=</span></code></p></td>
<td><p>Унификује два терма</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">\=</span></code></p></td>
<td><p>Негација унификације</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">==</span></code></p></td>
<td><p>Једнакост два терма</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">=:=</span></code></p></td>
<td><p>Једнакост израчунатих вредности два терма</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">=\=</span></code></p></td>
<td><p>Негација једнакости</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">=&lt;</span></code></p></td>
<td><p>Мање од или једнако</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&lt;</span></code></p></td>
<td><p>Мање од</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&gt;=</span></code></p></td>
<td><p>Веће од или једнако</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&gt;</span></code></p></td>
<td><p>Веће од</p></td>
</tr>
</tbody>
</table>
<p>Аритметички оператори су описани у следећој табели.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Оператор</p></th>
<th class="head"><p>Опис</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">+</span></code></p></td>
<td><p>Сабира два броја.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
<td><p>Одузима други број од првог.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">*</span></code></p></td>
<td><p>Множи два броја.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">/</span></code></p></td>
<td><p>Дели први број са другим.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">//</span></code></p></td>
<td><p>Целобројно дељење (добија целобројни резултат).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">mod</span></code></p></td>
<td><p>Остатак при дељењу (добија остатак од дељења).</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">**</span></code></p></td>
<td><p>Степеновање (први број се степенује другим).</p></td>
</tr>
</tbody>
</table>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати предикат који израчунава степен броја (изложилац је
ненегативан цео број).</p>

    </div></div>
<p>Основна идеја је да пратимо рекурзивну дефиницију која је у језику
Haskell била изражена на следећи начин:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">stepen</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="nf">stepen</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">stepen</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Уместо функције у језику PROLOG дефинишемо предикат тј. релацију.
Поново имамо два случаја (излаз из рекурзије и рекурзивни корак).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stepen</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span>
<span class="n">stepen</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="p">:</span><span class="o">-</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N1</span> <span class="ow">is</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">stepen</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">S1</span><span class="p">),</span> <span class="n">S</span> <span class="ow">is</span> <span class="n">X</span> <span class="o">*</span> <span class="n">S1</span><span class="o">.</span>
</pre></div>
</div>
<p>Пошто се у првом правилу вредност променљиве <code class="docutils literal notranslate"><span class="pre">X</span></code> не користи,
добијамо упозорење <code class="docutils literal notranslate"><span class="pre">Singleton</span> <span class="pre">variable</span> <span class="pre">X</span></code>. Да би се оно избегло,
уместо назива <code class="docutils literal notranslate"><span class="pre">X</span></code> можемо употребити анонимну променљиву која се
обележава подвлаком.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stepen</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>Прво правило можемо читати као:</p>
<ul class="simple">
<li><p>нулти степен било ког броја је 1*</p></li>
</ul>
<p>Друго правило се може протумачити као:</p>
<ul class="simple">
<li><p>ако је <code class="docutils literal notranslate"><span class="pre">N</span></code> позитиван, ако је <code class="docutils literal notranslate"><span class="pre">N1</span></code> једнако вредности броја <code class="docutils literal notranslate"><span class="pre">N</span></code>
након што се она умањи за 1, ако је <code class="docutils literal notranslate"><span class="pre">S1</span></code> вредност степена <code class="docutils literal notranslate"><span class="pre">X</span></code> на
<code class="docutils literal notranslate"><span class="pre">N1</span></code> и ако је <code class="docutils literal notranslate"><span class="pre">S</span></code> једнака вредности која се добије када се
израчуна производ броја <code class="docutils literal notranslate"><span class="pre">X</span></code> и те вредности <code class="docutils literal notranslate"><span class="pre">S1</span></code>, тада је <code class="docutils literal notranslate"><span class="pre">S</span></code>
вредност степена <code class="docutils literal notranslate"><span class="pre">X</span></code> на <code class="docutils literal notranslate"><span class="pre">N</span></code>.</p></li>
</ul>
<p>Нагласимо да је потребно употребити оператор <code class="docutils literal notranslate"><span class="pre">is</span></code> да би се број
<code class="docutils literal notranslate"><span class="pre">N</span></code> умањио за 1 као и да би се резултат рекурзивног позива <code class="docutils literal notranslate"><span class="pre">S1</span></code>
помножио са <code class="docutils literal notranslate"><span class="pre">X</span></code>. Ако не бисмо у другом правилу навели услов <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">&gt;</span>
<span class="pre">0</span></code>, тада би се прво пријавила исправно израчуната вредност степена,
али би се приликом тражења даљих решења запало у бесконачну рекурзију
јер не би било услова који би спречио да се друго правило примењује на
<code class="docutils literal notranslate"><span class="pre">N=0</span></code> а затим и на негативне вредности променљиве <code class="docutils literal notranslate"><span class="pre">N</span></code>.</p>
<p>Можемо дефинисати и ефикаснију имплементацију степеновања.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stepen</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span>
<span class="n">stepen</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="p">:</span><span class="o">-</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="n">mod</span> <span class="mi">2</span> <span class="o">=:=</span> <span class="mi">0</span><span class="p">,</span>
                   <span class="n">N1</span> <span class="ow">is</span> <span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">X2</span> <span class="ow">is</span> <span class="n">X</span> <span class="o">*</span> <span class="n">X</span><span class="p">,</span> <span class="n">stepen</span><span class="p">(</span><span class="n">X2</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span><span class="o">.</span>
<span class="n">stepen</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="p">:</span><span class="o">-</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="n">mod</span> <span class="mi">2</span> <span class="o">=</span>\<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                   <span class="n">N1</span> <span class="ow">is</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">stepen</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">S1</span><span class="p">),</span> <span class="n">S</span> <span class="ow">is</span> <span class="n">S1</span> <span class="o">*</span> <span class="n">X</span><span class="o">.</span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати предикат који Еуклидовим алгоритмом израчунава НЗД два
дата природна броја.</p>

    </div></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nzd</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span><span class="o">.</span>
<span class="n">nzd</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="p">:</span><span class="o">-</span> <span class="n">B</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">M</span> <span class="ow">is</span> <span class="n">A</span> <span class="n">mod</span> <span class="n">B</span><span class="p">,</span> <span class="n">nzd</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h2>Сечење<a class="headerlink" href="#id9" title="Permalink to this heading">¶</a></h2>
<p>У циљу смањења простора претраге, спречавања нежељеног бектрекинга и
на тај начин изостављања неких нетачних одговора или оптимизације
времена извршавања PROLOG уводи <strong>оператор сечења</strong> или <strong>рез</strong>
(енгл. cut).  Овај се оператор означава са <code class="docutils literal notranslate"><span class="pre">!</span></code>, увек успева (када се
наведе у правилу, сматра се да је резултат његовог израчунавања
тачан), али у повратку спречава бектрекинг и враћање преко њега здесна
налево. Размотримо неколико примера.</p>
<p>Максимум се може дефинисати на следећи начин:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">min</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nv">X</span> <span class="o">=&lt;</span> <span class="nv">Y</span><span class="p">.</span>
<span class="nf">min</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nv">Y</span> <span class="o">&lt;</span> <span class="nv">X</span><span class="p">.</span>
</pre></div>
</div>
<p>Ако се на основу првог правила одреди да је <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=&lt;</span> <span class="pre">Y</span></code>, тада нема
потребе приликом бектрекинга проверавати друго правило јер унапред
знамо да његов услов неће бити испуњен. Зато се програм може убрзати
тако што се иза услова у првом правилу дода оператор сечења.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">min</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nv">X</span> <span class="o">=&lt;</span> <span class="nv">Y</span><span class="p">,</span> <span class="p">!.</span>
<span class="nf">max</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">:-</span> <span class="nv">Y</span> <span class="o">&lt;</span> <span class="nv">X</span><span class="p">.</span>
</pre></div>
</div>
<p>Приликом упита <code class="docutils literal notranslate"><span class="pre">?-</span> <span class="pre">max(3,</span> <span class="pre">5,</span> <span class="pre">M)</span></code> извршиће се унификација којом ће се
везати променљива <code class="docutils literal notranslate"><span class="pre">X</span></code> са вредношћу 3, <code class="docutils literal notranslate"><span class="pre">Y</span></code> са вредношћу 5 и <code class="docutils literal notranslate"><span class="pre">M</span></code>
са вредношћу <code class="docutils literal notranslate"><span class="pre">X</span></code> тј. 3, провериће се услов <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">=&lt;</span> <span class="pre">5</span></code> који ће бити
тачан, провериће се оператор сечења који је тачан када се рачуна слева
надесно и доћи ће се до краја правила и пријавиће се резултат <code class="docutils literal notranslate"><span class="pre">M=3</span></code>.</p>
<p>Претходна употреба оператора сечења је <strong>зелена</strong>, јер се оператором
сечења програм само убрзава и не мења му се значење.</p>
<p>Можемо отићи и корак даље и из другог правила изоставити услов <code class="docutils literal notranslate"><span class="pre">Y</span> <span class="pre">&lt;</span>
<span class="pre">X</span></code>. Наиме, пошто у првом правилу постоји сечење, јасно је да ће се до
провере другог правила стићи само ако услов првог правила није испуњен
тј. ако не важи <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=&lt;</span> <span class="pre">Y</span></code> тј. сигурно тада знамо да важи <code class="docutils literal notranslate"><span class="pre">Y</span> <span class="pre">&gt;</span> <span class="pre">X</span></code>.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">max</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nv">X</span> <span class="o">=&lt;</span> <span class="nv">Y</span><span class="p">,</span> <span class="p">!.</span>
<span class="nf">max</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">Y</span><span class="p">).</span>
</pre></div>
</div>
<p>Вредност максимума бројева 3 и 5 можемо израчунати у ком редоследу
да су задати.</p>
<ul class="simple">
<li><p>Упит <code class="docutils literal notranslate"><span class="pre">?-</span> <span class="pre">max(3,</span> <span class="pre">5,</span> <span class="pre">M)</span></code> се извршава на већ описани начин, добија се
резултат <code class="docutils literal notranslate"><span class="pre">M=5</span></code> и због сечења се не траже друга решења.</p></li>
<li><p>Упит <code class="docutils literal notranslate"><span class="pre">?-</span> <span class="pre">max(5,</span> <span class="pre">3,</span> <span class="pre">M)</span></code> се извршава тако што се унификује <code class="docutils literal notranslate"><span class="pre">X</span></code> са
5, <code class="docutils literal notranslate"><span class="pre">Y</span></code> са 3, проверава се <code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">=&lt;</span> <span class="pre">3</span></code> и пошто тај услов није
испуњен, одустаје се од овог правила. Затим се прелази на друго
правило, унификују се <code class="docutils literal notranslate"><span class="pre">X</span></code> и 5, <code class="docutils literal notranslate"><span class="pre">Y</span></code> и <code class="docutils literal notranslate"><span class="pre">3</span></code> и <code class="docutils literal notranslate"><span class="pre">M</span></code> и <code class="docutils literal notranslate"><span class="pre">Y</span></code>
тј. 3, након чега се пријављује резултат <code class="docutils literal notranslate"><span class="pre">M=3</span></code>. Приликом тражења
других решења враћамо се уназад, нализимо на сечење и бектрекинг се
прекида.</p></li>
</ul>
<p>Ипак, ова употреба оператора сечења је <strong>црвена</strong>, јер се оператором
сечења мења значење програма. Заиста, наредни упит сасвим неочекивано
враћа нетачан одговор <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">min</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">).</span>
</pre></div>
</div>
<p>Приликом његовог извршавања, покушава се унификација са левом страном
првог правила што не успева. Унификација са левом страном другог
правила успева и пошто више нема услова на десној страни тог правила,
пријављује се одговор <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>Дакле, иако сечење може скратити програм и омогућити нам да неке
услове не морамо да пишемо, треба бити веома обазриви јер такав
програм може исправно радити за неке услове, а престати да ради
исправно за неке друге упите. Приликом употребе сечења пожељно је увек
користити зелени, а не црвени облик сечења.</p>
<p>Сечење (додуше црвено) нам може помоћи да поједноставимо неке од
претходних дефиниција и да избегнемо експлицитно навођење додатних
услова. На пример, дефиниција степеновања се упрошћава.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">stepen</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">:-</span> <span class="p">!.</span>
<span class="nf">stepen</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">N</span><span class="p">,</span> <span class="nv">S</span><span class="p">)</span> <span class="p">:-</span> <span class="nv">N</span> <span class="o">mod</span> <span class="mi">2</span> <span class="o">=:=</span> <span class="mi">0</span><span class="p">,</span>
                   <span class="nv">N1</span> <span class="o">is</span> <span class="nv">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">X2</span> <span class="o">is</span> <span class="nv">X</span> <span class="o">*</span> <span class="nv">X</span><span class="p">,</span> <span class="nf">stepen</span><span class="p">(</span><span class="nv">X2</span><span class="p">,</span> <span class="nv">N1</span><span class="p">,</span> <span class="nv">S</span><span class="p">),</span> <span class="p">!.</span>
<span class="nf">stepen</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">N</span><span class="p">,</span> <span class="nv">S</span><span class="p">)</span> <span class="p">:-</span> <span class="nv">N1</span> <span class="o">is</span> <span class="nv">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nf">stepen</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">N1</span><span class="p">,</span> <span class="nv">S1</span><span class="p">),</span> <span class="nv">S</span> <span class="o">is</span> <span class="nv">S1</span> <span class="o">*</span> <span class="nv">X</span><span class="p">.</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h2>Листе<a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h2>
<p>Као и други програмски језици и програмски језик PROLOG пружа подршку
за рад са листама података. Слично као што смо видели у програмском
језику Haskell, листа је или празна (<code class="docutils literal notranslate"><span class="pre">[]</span></code>) или се разлаже на главу и
реп (<code class="docutils literal notranslate"><span class="pre">[X|XS]</span></code>). Листе се задају навођењем елемената између угластих
заграда (нпр. <code class="docutils literal notranslate"><span class="pre">[3,</span> <span class="pre">8,</span> <span class="pre">4,</span> <span class="pre">2]</span></code>).</p>
<p>Кренимо од предиката <code class="docutils literal notranslate"><span class="pre">myMember</span></code> који проверава да ли елемент <code class="docutils literal notranslate"><span class="pre">E</span></code>
припада листи (то ради уграђени предикат <code class="docutils literal notranslate"><span class="pre">member</span></code>, тако да ову
имплементацију приказујемо само ради илустрације).  Елемент не припада
празној листи, тако да случај празне листе не треба да буде обрађен
(ако нешто не постоји у бази знања, оно се аутоматски сматра
нетачним). Елемент припада непразној листи акко је једнак глави или
припада репу. Подсетимо се, дисјункцију можемо записати оператором
<code class="docutils literal notranslate"><span class="pre">;</span></code>.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">myMember</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="p">:-</span> <span class="nv">X</span> <span class="o">=</span> <span class="nv">H</span> <span class="p">;</span> <span class="nf">myMember</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">T</span><span class="p">).</span>
</pre></div>
</div>
<p>Наравно, ово правило је могуће разбити на два.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">myMember</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="p">[</span><span class="nv">X</span><span class="p">|</span><span class="k">_</span><span class="p">]).</span>
<span class="nf">myMember</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="p">[</span><span class="k">_</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="p">:-</span> <span class="nf">myMember</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">T</span><span class="p">).</span>
</pre></div>
</div>
<p>Јасно је да коришћењем овог предиката можемо проверити да ли дати број
припада датој листи, тј. да наредни упити враћају исправне резултате.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">myMember</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]).</span>   <span class="c1">% true</span>
<span class="s s-Atom">?-</span> <span class="nf">myMember</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]).</span>   <span class="c1">% false</span>
</pre></div>
</div>
<p>Међутим, можда мало неочекивано, овај предикат се може употребити и да
се наброји један по један елемент листе. Наредни упит</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">myMember</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]).</span>
</pre></div>
</div>
<p>даје резултат <code class="docutils literal notranslate"><span class="pre">X=1</span></code>, затим <code class="docutils literal notranslate"><span class="pre">X=2</span></code>, <code class="docutils literal notranslate"><span class="pre">X=3</span></code> и на крају <code class="docutils literal notranslate"><span class="pre">X=4</span></code>.</p>
<p>Ако је елемент једнак глави листе, он је члан листе и нема више
потребе да се проверава да ли припада репу. Зато на крај првог правила
можемо поставити рез.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">myMember</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="p">[</span><span class="nv">X</span><span class="p">|</span><span class="k">_</span><span class="p">])</span> <span class="p">:-</span> <span class="p">!.</span>
<span class="nf">myMember</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="p">[</span><span class="k">_</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="p">:-</span> <span class="nf">myMember</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">T</span><span class="p">).</span>
</pre></div>
</div>
<p>Међутим, ова измена спречава употребу предиката <code class="docutils literal notranslate"><span class="pre">myMember</span></code> за
набрајање свих елемената листе, јер се након пријављивања првог
елемента спречава бектрекинг преко реза. Зато се верзија без реза ипак
сматра бољом, ако се планира употреба за набрајање свих елемената
листе (што је, видећемо, доста чест случај).</p>
<p>Иуструјмо рад са листама кроз још неколико предиката.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати предикат који одређује дужину листе.</p>

    </div></div>
<p>Дужина празне листе је нула, а непразне листе је за један већа од
дужине репа.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">myLength</span><span class="p">([],</span> <span class="mi">0</span><span class="p">).</span>
<span class="nf">myLength</span><span class="p">([</span><span class="k">_</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">N</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">myLength</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">N1</span><span class="p">),</span> <span class="nv">N</span> <span class="o">is</span> <span class="nv">N1</span> <span class="o">+</span> <span class="mf">1.</span>
</pre></div>
</div>
<p>Пошто је употребљен оператор <code class="docutils literal notranslate"><span class="pre">is</span></code>, овај се предикат не може
употребљавати да се наброје све листе дате дужине.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати предикат који спаја (надовезује) две листе.</p>

    </div></div>
<p>Решење тече рекурзијом по првој листи. Ако је она празна, резултат
је друга листа. Ако је она облика глава-реп, тада резултат добијамо
тако што рекурзивно спојимо реп <code class="docutils literal notranslate"><span class="pre">R</span></code> и другу листу <code class="docutils literal notranslate"><span class="pre">L</span></code>
добијајући међурезултат <code class="docutils literal notranslate"><span class="pre">R1</span></code>. Коначан резултат добијамо додајући
главу <code class="docutils literal notranslate"><span class="pre">H</span></code> на почетак међурезултата.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">myAppend</span><span class="p">([],</span> <span class="nv">L</span><span class="p">,</span> <span class="nv">L</span><span class="p">).</span>
<span class="nf">myAppend</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">L</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">R1</span><span class="p">])</span> <span class="p">:-</span> <span class="nf">myAppend</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">L</span><span class="p">,</span> <span class="nv">R1</span><span class="p">).</span>
</pre></div>
</div>
<p>Друго правило можемо изразити и коришћењем оператора унификације на
десној страни (тада имамо експлицитну променљиву уз резултат којој
„додељујемо вредност” на крају, када су познате вредности од којих
се она гради):</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">myAppend</span><span class="p">([],</span> <span class="nv">L</span><span class="p">,</span> <span class="nv">L</span><span class="p">).</span>
<span class="nf">myAppend</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">L</span><span class="p">,</span> <span class="nv">R</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">myAppend</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">L</span><span class="p">,</span> <span class="nv">R1</span><span class="p">),</span> <span class="nv">R</span> <span class="o">=</span> <span class="p">[</span><span class="nv">H</span><span class="p">,</span> <span class="nv">R1</span><span class="p">].</span>
</pre></div>
</div>
<p>У зависности од личног стила неком ће прва а неком друга
имплементација бити јаснија и разумљивија.</p>
<p>Овај предикат исправно надовезује две дате листе. На упит</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">myAppend</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="nv">R</span><span class="p">).</span>
</pre></div>
</div>
<p>добијамо исправан одговор <code class="docutils literal notranslate"><span class="pre">X=[1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6]</span></code>. Међутим,
прилично неочекивано, овај предикат успева и да одговори на питање
надовезивањем које две листе се може добити дата листа.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">myAppend</span><span class="p">(</span><span class="nv">L1</span><span class="p">,</span> <span class="nv">L2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]).</span>
</pre></div>
</div>
<p>Добијају се одговори <code class="docutils literal notranslate"><span class="pre">L1=[]</span></code>, <code class="docutils literal notranslate"><span class="pre">L2=[1,2,3,4]</span></code>, затим
<code class="docutils literal notranslate"><span class="pre">L1=[1]</span></code>, <code class="docutils literal notranslate"><span class="pre">L2=[2,3,4]</span></code>, затим <code class="docutils literal notranslate"><span class="pre">L1=[1,2]</span></code>, <code class="docutils literal notranslate"><span class="pre">L2=[3,4]</span></code>,
затим <code class="docutils literal notranslate"><span class="pre">L1=[1,2,3]</span></code>, <code class="docutils literal notranslate"><span class="pre">L2=[4]</span></code> и на крају  <code class="docutils literal notranslate"><span class="pre">L1=[1,2,3,4]</span></code>,
<code class="docutils literal notranslate"><span class="pre">L2=[]</span></code>.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати предикат који одређује последњи елемент листе.</p>

    </div></div>
<p>Овај предикат није дефинисан за празне листе. Базу (излаз из
рекурзије) ће зато представљати случај једночлане листе где је
једини елемент листе уједно и последњи. Ако је листа непразна, тада
е последњи елемент репа листе последњи елемент листе.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">myLast</span><span class="p">([</span><span class="nv">X</span><span class="p">],</span> <span class="nv">X</span><span class="p">).</span>
<span class="nf">myLast</span><span class="p">([</span><span class="k">_</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">Res</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">myLast</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">Res</span><span class="p">).</span>
</pre></div>
</div>
<p>Овај предикат исправно одређује последњи елемент било које непразне
листе, а за празну листу враћа одговор <code class="docutils literal notranslate"><span class="pre">false</span></code>. Остаје можда мало
нејасно да ли је након првог правила додати рез, тј. зашто се
једночлана листа не обрађује и на основу првог и на основу другог
правила, пошто је она такође непразна. Једночлана листа се може
унификовати са листом <code class="docutils literal notranslate"><span class="pre">[_|T]</span></code>, тако што је <code class="docutils literal notranslate"><span class="pre">T</span></code> празна листа.
Након тога се, због десне стране правила, тражи последњи елемент
празне листе, и пошто то не успева, не налази се додатно решење.
Дакле, друго правило се примењује на јеночлану листу, али не доводи
до решења. Ако не ставимо рез након првог правила, овај предикат се
може искористити и да наброји све листе којима је дати елемент
последњи. На упит</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">myLast</span><span class="p">(</span><span class="nv">L</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span>
</pre></div>
</div>
<p>Добијамо одговоре <code class="docutils literal notranslate"><span class="pre">L=[0]</span></code>, <code class="docutils literal notranslate"><span class="pre">L=[_1412,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">L</span> <span class="pre">=</span> <span class="pre">[_1412,</span> <span class="pre">_1418,</span> <span class="pre">0]</span></code>
итд. при чемусу <code class="docutils literal notranslate"><span class="pre">_1412</span></code>, <code class="docutils literal notranslate"><span class="pre">_1418</span></code> итд. називи аутоматски генерисаних
променљивих.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати предикат који одређује елемент листе на датој позицији.</p>

    </div></div>
<p>Елемент на позицији 0 празне листе је њена глава. За <code class="docutils literal notranslate"><span class="pre">K</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>
елемент на позицији <code class="docutils literal notranslate"><span class="pre">K</span></code> непразне листе је елемент на позицији
<code class="docutils literal notranslate"><span class="pre">K-1</span></code> њеног репа.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">kth</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="k">_</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">H</span><span class="p">).</span>
<span class="nf">kth</span><span class="p">([</span><span class="k">_</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">K</span><span class="p">,</span> <span class="nv">R</span><span class="p">)</span> <span class="p">:-</span> <span class="s s-Atom">К</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">K1</span> <span class="o">is</span> <span class="nv">K</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nf">kth</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">K1</span><span class="p">,</span> <span class="nv">R</span><span class="p">).</span>
</pre></div>
</div>
<p>Променљива <code class="docutils literal notranslate"><span class="pre">R</span></code> означава резултат.</p>
<p>У решењу можемо употребити и сечење.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">kth</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="k">_</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">H</span><span class="p">)</span> <span class="p">:-</span> <span class="p">!.</span>
<span class="nf">kth</span><span class="p">([</span><span class="k">_</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">K</span><span class="p">,</span> <span class="nv">R</span><span class="p">)</span> <span class="p">:-</span> <span class="nv">K1</span> <span class="o">is</span> <span class="nv">K</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nf">kth</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">K1</span><span class="p">,</span> <span class="nv">R</span><span class="p">).</span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати предикат који обрће листу.</p>

    </div></div>
<p>Наивно решење добијамо тако што приметимо да се обртањем празне
листе добија празна листа, а да се резултат обртања непразне листе
која има главу и реп добија тако што се глава те листе добија на
резултат обртања репа те листе.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">myReverse</span><span class="p">([],</span> <span class="p">[]).</span>
<span class="nf">myReverse</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">R</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">myReverse</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">R1</span><span class="p">),</span> <span class="nf">myAppend</span><span class="p">(</span><span class="nv">R1</span><span class="p">,</span> <span class="nv">H</span><span class="p">,</span> <span class="nv">R</span><span class="p">).</span>
</pre></div>
</div>
<p>Потребно је и да дефинишемо предикат којим се елемент додаје на
крај листе. Додавањем елемента на крај празне листе добија се
једночлана листа. Ако је листа непразна, додавање елемента на њен
крај се добија тако што јој се задржи глава, а реп јој се замени
додавањем елемента на крај њеног репа.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">myAppend</span><span class="p">([],</span> <span class="nv">X</span><span class="p">,</span> <span class="p">[</span><span class="nv">X</span><span class="p">]).</span>
<span class="nf">myAppend</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">X</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">T1</span><span class="p">])</span> <span class="p">:-</span> <span class="nf">myAppend</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">X</span><span class="p">,</span> <span class="nv">T1</span><span class="p">).</span>
</pre></div>
</div>
<p>Уместо да директно наведемо облик резултата на левој страни
правила, можемо употребити и оператор унификације на десној страни
правила.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">myAppend</span><span class="p">([],</span> <span class="nv">X</span><span class="p">,</span> <span class="nv">R</span><span class="p">)</span> <span class="p">:-</span> <span class="nv">R</span> <span class="o">=</span> <span class="p">[</span><span class="nv">X</span><span class="p">].</span>
<span class="nf">myAppend</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">X</span><span class="p">,</span> <span class="nv">R</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">myAppend</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">X</span><span class="p">,</span> <span class="nv">T1</span><span class="p">),</span> <span class="nv">R</span> <span class="o">=</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">T1</span><span class="p">].</span>
</pre></div>
</div>
<p>Ова имплементација обртања је неефикасна и ефикасније решење се
добија ако се користи акумулатор (опис овог алгоритма приказан је у
поглављу о функционалном програмирању). Узима се један по један
елемент полазне листе и додаје се на почетак помоћне листе
(акумулатора) све док се полазна листа не испразни и тада је
коначан резултат оно што се нагомилало у акумулатору. На почетку се
креће од празног акумулатора.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">myReverse</span><span class="p">([],</span> <span class="nv">A</span><span class="p">,</span> <span class="nv">A</span><span class="p">).</span>
<span class="nf">myReverse</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">A</span><span class="p">,</span> <span class="nv">R</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">myReverse</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">A</span><span class="p">],</span> <span class="nv">R</span><span class="p">).</span>
<span class="nf">myReverse</span><span class="p">(</span><span class="nv">L</span><span class="p">,</span> <span class="nv">R</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">myReverse</span><span class="p">(</span><span class="nv">L</span><span class="p">,</span> <span class="p">[],</span> <span class="nv">R</span><span class="p">).</span>
</pre></div>
</div>
<p>Променљива <code class="docutils literal notranslate"><span class="pre">L</span></code> означава листу која се обрђе, <code class="docutils literal notranslate"><span class="pre">R</span></code> резултат
обртања, а <code class="docutils literal notranslate"><span class="pre">A</span></code> акумулатор.</p>
<p>Обртање можемо употребити да проверимо, на пример, да ли је ниска
палиндром.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">proveriPalindrom</span><span class="p">(</span><span class="nv">XS</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">obrni</span><span class="p">(</span><span class="nv">XS</span><span class="p">,</span> <span class="nv">XS</span><span class="p">).</span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати предикат који прима угнежђене листе бројева и „пегла” их
тј. издваја листу свих бројева који се у њима јављају. На пример, треба
да важи <code class="docutils literal notranslate"><span class="pre">myFlatten</span> <span class="pre">[[1,</span> <span class="pre">2,</span> <span class="pre">3],</span> <span class="pre">[4,</span> <span class="pre">[5,</span> <span class="pre">6]],</span> <span class="pre">7]</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7]</span></code>.</p>

    </div></div>
<p>„Пеглањем” празне листе добија се празна листа. Код непразних листа,
„пегла” се реп листе, а затим се анализира глава. Постоје два могућа
случаја. Ако је глава листа, тада се резултат добије тако што се та
глава „пегла” и резултат се спаја са „испегланим” репом. Ако глава
није листа, она се таква каква јесте додаје на почетак „испегланог”
репа. Проверу да ли је дата променљива листа можемо извршити
библиотечким предикатом <code class="docutils literal notranslate"><span class="pre">is_list</span></code>.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">myFlatten</span><span class="p">([],</span> <span class="p">[]).</span>
<span class="nf">myFlatten</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">X</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">is_list</span><span class="p">(</span><span class="nv">H</span><span class="p">),</span> <span class="nf">myFlatten</span><span class="p">(</span><span class="nv">H</span><span class="p">,</span> <span class="nv">H1</span><span class="p">),</span> <span class="nf">myFlatten</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">T1</span><span class="p">),</span> <span class="nf">append</span><span class="p">(</span><span class="nv">H1</span><span class="p">,</span> <span class="nv">T1</span><span class="p">,</span> <span class="nv">X</span><span class="p">),</span> <span class="p">!.</span>
<span class="nf">myFlatten</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">T1</span><span class="p">])</span> <span class="p">:-</span> <span class="nf">myFlatten</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">T1</span><span class="p">).</span>
</pre></div>
</div>
<p>Приметимо да ову функционалност није могуће постићи у језику
Haskell, јер тип полазне листе није могуће дефинисати (тамо сви
елементи листе морају да имају исти тип, а овде радимо са листама
које садрже елементе различитих типова).</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати предикат који обједињава две сортиране листе у трећу
сортирану. Дефинисати затим предикат који дели листу на две једнаке
половине. Дефинисати на крају предикат који применом претходна два
предиката сортира листу.</p>

    </div></div>
<p>Ако је било која од две листе које се обједињавају празна, резултат
је она друга. Ако су обе листе непразне, мању од њихове две главе
смештамо на почетак резултата, а реп резултата добијамо рекурзивним
обједињавањем репа листе чија је глава била мања и целе друге
листе.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">merge</span><span class="p">([],</span> <span class="nv">L2</span><span class="p">,</span> <span class="nv">L2</span><span class="p">).</span>
<span class="nf">merge</span><span class="p">(</span><span class="nv">L1</span><span class="p">,</span> <span class="p">[],</span> <span class="nv">L1</span><span class="p">).</span>
<span class="nf">merge</span><span class="p">([</span><span class="nv">H1</span><span class="p">|</span><span class="nv">T1</span><span class="p">],</span> <span class="p">[</span><span class="nv">H2</span><span class="p">|</span><span class="nv">T2</span><span class="p">],</span> <span class="nv">R</span><span class="p">)</span> <span class="p">:-</span> <span class="nv">H1</span> <span class="o">&lt;</span> <span class="nv">H2</span><span class="p">,</span> <span class="nf">merge</span><span class="p">(</span><span class="nv">T1</span><span class="p">,</span> <span class="p">[</span><span class="nv">H2</span><span class="p">|</span><span class="nv">T2</span><span class="p">],</span> <span class="nv">R1</span><span class="p">),</span> <span class="nv">R</span> <span class="o">=</span> <span class="p">[</span><span class="nv">H1</span><span class="p">|</span><span class="nv">R1</span><span class="p">],</span> <span class="p">!.</span>
<span class="nf">merge</span><span class="p">([</span><span class="nv">H1</span><span class="p">|</span><span class="nv">T1</span><span class="p">],</span> <span class="p">[</span><span class="nv">H2</span><span class="p">|</span><span class="nv">T2</span><span class="p">],</span> <span class="nv">R</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">merge</span><span class="p">([</span><span class="nv">H1</span><span class="p">|</span><span class="nv">T1</span><span class="p">],</span> <span class="nv">T2</span><span class="p">,</span> <span class="nv">R1</span><span class="p">),</span> <span class="nv">R</span> <span class="o">=</span> <span class="p">[</span><span class="nv">H2</span><span class="p">|</span><span class="nv">R1</span><span class="p">].</span>
</pre></div>
</div>
<p>Поделу листе на два једнака дела можемо постићи тако што
наизменично елементе са почетка листе која се дели смештамо у једну
и другу резултујућу листу. Празна листа се дели на две
празне. Једночлана се дели тако што ће једна од резултујућих листа
бити једночлана, а друга празна. Листу која има бар два елемента
делимо тако што реп без та два елемента делимо на два дела, а онда
први елемент стављамо на почетак првог од та два дела, а други на
почетак другог.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">split</span><span class="p">([],</span> <span class="p">[],</span> <span class="p">[]).</span>
<span class="nf">split</span><span class="p">([</span><span class="nv">X</span><span class="p">],</span> <span class="p">[</span><span class="nv">X</span><span class="p">],</span> <span class="p">[]).</span>
<span class="nf">split</span><span class="p">([</span><span class="nv">H1</span><span class="p">,</span><span class="nv">H2</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="p">[</span><span class="nv">H1</span><span class="p">|</span><span class="nv">L</span><span class="p">],</span> <span class="p">[</span><span class="nv">H2</span><span class="p">|</span><span class="nv">R</span><span class="p">])</span> <span class="p">:-</span> <span class="nf">split</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">L</span><span class="p">,</span> <span class="nv">R</span><span class="p">).</span>
</pre></div>
</div>
<p>На крају дефинишемо сортирање обједињавањем. Празна и једночлана
листа се не мењају приликом сортирања. Листа која има бар два
елемента се дели на две подлисте, оне се независно сортирају и на
крају обједињавају.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">mergeSort</span><span class="p">([],</span> <span class="p">[]).</span>
<span class="nf">mergeSort</span><span class="p">([</span><span class="nv">X</span><span class="p">],</span> <span class="p">[</span><span class="nv">X</span><span class="p">])</span> <span class="p">:-</span> <span class="p">!.</span>
<span class="nf">mergeSort</span><span class="p">(</span><span class="nv">L</span><span class="p">,</span> <span class="nv">R</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">split</span><span class="p">(</span><span class="nv">L</span><span class="p">,</span> <span class="nv">L1</span><span class="p">,</span> <span class="nv">L2</span><span class="p">),</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="nv">L1</span><span class="p">,</span> <span class="nv">L1S</span><span class="p">),</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="nv">L2</span><span class="p">,</span> <span class="nv">L2S</span><span class="p">),</span> <span class="nf">merge</span><span class="p">(</span><span class="nv">L1S</span><span class="p">,</span> <span class="nv">L2S</span><span class="p">,</span> <span class="nv">R</span><span class="p">).</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h2>Логичке загонетке<a class="headerlink" href="#id11" title="Permalink to this heading">¶</a></h2>
<p>Веома лепа илустрација моћи језика PROLOG у односу на друге програмске
језике је кроз решавање логичких загонетки. Обично су програми само
прецизно кодирање услова загонетки, а систем онда самостално проналази
решење, што је доста ефикасније него код других програмских језика у
којима програмер мора да програмира поступак одређивања решења. У
зависности од загонетке која се решава и начина решавања програми могу
бити мање или више ефикасни. У наредним решењима нећемо обраћати пуно
пажње на ефикасност решења, већ пре свега на једносавност њиховог
програмирања. Размотримо следећих неколико примера.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Неколико пријатеља је гласало које би градове желели да посете.</p>
<ol class="arabic simple">
<li><p>Гласали су за Каиро, Лондон, Пекинг, Москву, Бомбај, Најроби и
Џакарту.</p></li>
<li><p>Један град је добио 4 гласа, два града по 2 гласа, два града по 1
глас и два града нису добили ниједан глас.</p></li>
<li><p>Каиро и Пекинг су добили различит број гласова.</p></li>
<li><p>Москва је добила или најмање или највише гласова од свих градова.</p></li>
<li><p>Каиро је добио више гласова од Џакарте.</p></li>
<li><p>Гледајући листу из тачке 1, тачно два пута се догодило да је град
са два гласа дошао непосредно иза града са једним гласом.</p></li>
<li><p>Џакарта је добила или један глас мање од Лондона или један
глас мање од Пекинга.</p></li>
</ol>

    </div></div>
<p>Направићемо листу променљивих које одговарају градовима. Вредност
сваке од тих променљивих биће број гласова које је тај град
добио. На основу другог правила знамо да ће листа вредности тих
променљивих садржати вредности <code class="docutils literal notranslate"><span class="pre">[4,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">0]</span></code>, али не
знамо у ком редоследу тј. знаћемо да је листа вредности променљивих
једна од пермутација ове листе. Можемо употребити библиотечки
предикат <code class="docutils literal notranslate"><span class="pre">permutation</span></code> који се може употребљавати за набрајање
свих пермутација (покушајте да за вежбу самостално дефинишете такав
предикат). Приступ решењу је, дакле, прилично директан: набрајају
се све пермутације ове листе и за сваку од њих се проверава да ли
задовољава додатне услове. Иако су оваква решења у општем случају
веома неефикасна, јер број пермутација брзо расте, у овом
конкретном задатку ефикасност је задовољавајућа јер пермутација
седмочлане листе има тек око 5 хиљада. Сваки даљи услов, осим
услова 6 се веома директно кодира. Што се тиче услова 6, дефинишемо
помоћни предикат који броји појављивања пара бројева у листи.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">brojPojavljivanjaPara</span><span class="p">([],</span> <span class="k">_</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span>
<span class="nf">brojPojavljivanjaPara</span><span class="p">([</span><span class="nv">X1</span><span class="p">,</span><span class="nv">X2</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="p">[</span><span class="nv">X1</span><span class="p">,</span><span class="nv">X2</span><span class="p">],</span> <span class="nv">N</span><span class="p">)</span> <span class="p">:-</span>
   <span class="nf">brojPojavljivanjaPara</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="p">[</span><span class="nv">X1</span><span class="p">,</span><span class="nv">X2</span><span class="p">],</span> <span class="nv">N1</span><span class="p">),</span> <span class="nv">N</span> <span class="o">is</span> <span class="nv">N1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">!.</span>
<span class="nf">brojPojavljivanjaPara</span><span class="p">([</span><span class="k">_</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="p">[</span><span class="nv">X1</span><span class="p">,</span><span class="nv">X2</span><span class="p">],</span> <span class="nv">N</span><span class="p">)</span> <span class="p">:-</span>
   <span class="nf">brojPojavljivanjaPara</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="p">[</span><span class="nv">X1</span><span class="p">,</span><span class="nv">X2</span><span class="p">],</span> <span class="nv">N</span><span class="p">).</span>

<span class="nf">glasovi</span><span class="p">(</span><span class="nv">Gradovi</span><span class="p">)</span> <span class="p">:-</span>
  <span class="nv">Gradovi</span> <span class="o">=</span> <span class="p">[</span><span class="nv">Kairo</span><span class="p">,</span><span class="nv">London</span><span class="p">,</span><span class="nv">Peking</span><span class="p">,</span><span class="nv">Moskva</span><span class="p">,</span><span class="nv">Bombaj</span><span class="p">,</span><span class="nv">Najrobi</span><span class="p">,</span><span class="nv">Dzakarta</span><span class="p">],</span>
  <span class="nf">permutation</span><span class="p">(</span><span class="nv">Gradovi</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
  <span class="nv">Kairo</span> <span class="s s-Atom">=\=</span> <span class="nv">Peking</span><span class="p">,</span>
  <span class="p">(</span><span class="nv">Moskva</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="nv">Moskva</span> <span class="o">=</span> <span class="mi">4</span><span class="p">),</span>
  <span class="nv">Kairo</span> <span class="o">&gt;</span> <span class="nv">Dzakarta</span><span class="p">,</span>
  <span class="nf">brojPojavljivanjaPara</span><span class="p">(</span><span class="nv">Gradovi</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span>
  <span class="p">(</span><span class="nv">Dzakarta</span> <span class="o">is</span> <span class="p">(</span><span class="nv">London</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="nv">Dzakarta</span> <span class="o">is</span> <span class="p">(</span><span class="nv">Peking</span><span class="o">-</span><span class="mi">1</span><span class="p">)).</span>
</pre></div>
</div>
<p>Тачно решење <code class="docutils literal notranslate"><span class="pre">Gradovi</span> <span class="pre">=</span> <span class="pre">[4,</span> <span class="pre">0,</span> <span class="pre">2,</span> <span class="pre">0,</span> <span class="pre">2,</span> <span class="pre">1,</span> <span class="pre">1]</span></code> се пријављује
неколико пута, јер функција за проналажење пермутација неколико
пута проналази исту пермутацију (зато што листа садржи дупликате).</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Пет људи различитих националности живи у пет кућа различитих боја,
имају пет различитих врста кућних љубимаца, пију пет различитих
напитака и пуше пет различитих врста цигарета.</p>
<ol class="arabic simple">
<li><p>Норвежанин живи у првој кући.</p></li>
<li><p>Млеко се пије у средњој кући.</p></li>
<li><p>Енглез живи у црвеној кући.</p></li>
<li><p>Шпанац има пса.</p></li>
<li><p>У зеленој кући се пије кафа.</p></li>
<li><p>Украјинац пије чај.</p></li>
<li><p>Власник пужа пуши цигарете олдголд.</p></li>
<li><p>У жутој кући се пуше цигарете кулс.</p></li>
<li><p>Зелена кућа је прва десно од куће боје слоноваче.</p></li>
<li><p>У кући поред оне у којој живи лисица се пуше цигарете честер.</p></li>
<li><p>У кући поред оне у којој се пуше цигарете кулс је љубимац коњ.</p></li>
<li><p>Плава кућа је поред оне у којој живи Норвежанин.</p></li>
<li><p>Власник једне куће пуши цигарете лаки и пије ђус.</p></li>
<li><p>Јапанац пуши цигарете парламент.</p></li>
</ol>

    </div></div>
<p>Напиши програм који одређује ко је власник зебре и ко пије воду?</p>
<p>Кључно питање је како представити решење. Веома погодна
репрезентација је у облику листе термова где је сваки терм облика
<code class="docutils literal notranslate"><span class="pre">kuca(nacionalnost,</span> <span class="pre">boja,</span> <span class="pre">ljubimac,</span> <span class="pre">pice,</span> <span class="pre">cigarete)</span></code>. Тада можемо
креирати петочлану листу <code class="docutils literal notranslate"><span class="pre">Kuce</span></code> и кодирати услове о њеним
члановима. Прва два услова се могу кодирати приликом дефинисања
низа кућа: први елемент је облика <code class="docutils literal notranslate"><span class="pre">kuca(norvezanin,</span> <span class="pre">_,</span> <span class="pre">_,</span> <span class="pre">_,</span> <span class="pre">_)</span></code>,
где анонимне променљиве могу бити унификоване са стварним
вредностима на тим позицијама, а трећи елемент је облика
<code class="docutils literal notranslate"><span class="pre">kuca(_,</span> <span class="pre">_,</span> <span class="pre">_,</span> <span class="pre">mleko,</span> <span class="pre">_)</span></code>. О другом, четвртом и петом елементу листе
не знамо ништа, па их можемо представити анонимним променљивама. У услову
9. потребно је да кодирамо „кућа је десно од куће”, а у неколико
услова треба да кодирамо да су куће једна поред друге. За то
дефинишемо два помоћна предиката <code class="docutils literal notranslate"><span class="pre">desnoOd</span></code> и <code class="docutils literal notranslate"><span class="pre">pored</span></code> (који се
лако кодира помоћу <code class="docutils literal notranslate"><span class="pre">desnoOd</span></code> зато што је кућа поред куће ако и
само ако је прва десно од друге или друга десно од прве). Све
остале услове кодирамо коришћењем уграђеног предиката <code class="docutils literal notranslate"><span class="pre">member</span></code>
који проверава да ли дати елемент припада листи, али и може да
наброји редом чланове листе. Имајући све ово у виду, сви услови се
прилично директно кодирају (приметимо да услови различитости следе
из тога што за сваку категорију имамо 5 различитих константи, након
што као последња два услова додамо информације о томе да власник
зебре има зебру, а да онај ко пије воду пије воду). Покретањем
предиката <code class="docutils literal notranslate"><span class="pre">zebraZagonetka</span></code> добијамо јединствено решење да Јапанац
има зебру, а да Норвежанин пије воду.</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nf">desnoOd</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="p">[</span><span class="nv">Y</span><span class="p">,</span> <span class="nv">X</span><span class="p">|</span> <span class="k">_</span><span class="p">]).</span>
<span class="nf">desnoOd</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="p">[</span><span class="k">_</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="p">:-</span> <span class="nf">desnoOd</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">T</span><span class="p">).</span>
<span class="nf">pored</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">L</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">desnoOd</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">L</span><span class="p">)</span> <span class="p">;</span> <span class="nf">desnoOd</span><span class="p">(</span><span class="nv">Y</span><span class="p">,</span> <span class="nv">X</span><span class="p">,</span> <span class="nv">L</span><span class="p">).</span>

<span class="nf">zebraZagonetka</span><span class="p">(</span><span class="nv">VlasnikZebre</span><span class="p">,</span> <span class="nv">PijeVodu</span><span class="p">)</span> <span class="p">:-</span>
   <span class="nv">Kuce</span> <span class="o">=</span> <span class="p">[</span><span class="nf">kuca</span><span class="p">(</span><span class="s s-Atom">norvezanin</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">),</span> <span class="k">_</span><span class="p">,</span> <span class="nf">kuca</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="s s-Atom">mleko</span><span class="p">,</span> <span class="k">_</span><span class="p">),</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">],</span>
   <span class="nf">member</span><span class="p">(</span><span class="nf">kuca</span><span class="p">(</span><span class="s s-Atom">englez</span><span class="p">,</span> <span class="s s-Atom">crvena</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">),</span> <span class="nv">Kuce</span><span class="p">),</span>
   <span class="nf">member</span><span class="p">(</span><span class="nf">kuca</span><span class="p">(</span><span class="s s-Atom">spanac</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="s s-Atom">pas</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">),</span> <span class="nv">Kuce</span><span class="p">),</span>
   <span class="nf">member</span><span class="p">(</span><span class="nf">kuca</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="s s-Atom">zelena</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="s s-Atom">kafa</span><span class="p">,</span> <span class="k">_</span><span class="p">),</span> <span class="nv">Kuce</span><span class="p">),</span>
   <span class="nf">member</span><span class="p">(</span><span class="nf">kuca</span><span class="p">(</span><span class="s s-Atom">ukrajinac</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="s s-Atom">caj</span><span class="p">,</span> <span class="k">_</span><span class="p">),</span> <span class="nv">Kuce</span><span class="p">),</span>
   <span class="nf">member</span><span class="p">(</span><span class="nf">kuca</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="s s-Atom">puz</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="s s-Atom">oldgold</span><span class="p">),</span> <span class="nv">Kuce</span><span class="p">),</span>
   <span class="nf">member</span><span class="p">(</span><span class="nf">kuca</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="s s-Atom">zuta</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="s s-Atom">kuls</span><span class="p">),</span> <span class="nv">Kuce</span><span class="p">),</span>
   <span class="nf">desnoOd</span><span class="p">(</span><span class="nf">kuca</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="s s-Atom">zelena</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">),</span> <span class="nf">kuca</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="s s-Atom">slonovaca</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">),</span> <span class="nv">Kuce</span><span class="p">),</span>
   <span class="nf">pored</span><span class="p">(</span><span class="nf">kuca</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="s s-Atom">cester</span><span class="p">),</span> <span class="nf">kuca</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="s s-Atom">lisica</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">),</span> <span class="nv">Kuce</span><span class="p">),</span>
   <span class="nf">pored</span><span class="p">(</span><span class="nf">kuca</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="s s-Atom">kuls</span><span class="p">),</span> <span class="nf">kuca</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="s s-Atom">konj</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">),</span> <span class="nv">Kuce</span><span class="p">),</span>
   <span class="nf">pored</span><span class="p">(</span><span class="nf">kuca</span><span class="p">(</span><span class="s s-Atom">norvezanin</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">),</span> <span class="nf">kuca</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="s s-Atom">plava</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">),</span> <span class="nv">Kuce</span><span class="p">),</span>
   <span class="nf">member</span><span class="p">(</span><span class="nf">kuca</span><span class="p">(</span><span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="s s-Atom">djus</span><span class="p">,</span> <span class="s s-Atom">laki</span><span class="p">),</span> <span class="nv">Kuce</span><span class="p">),</span>
   <span class="nf">member</span><span class="p">(</span><span class="nf">kuca</span><span class="p">(</span><span class="s s-Atom">japanac</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="s s-Atom">parlament</span><span class="p">),</span> <span class="nv">Kuce</span><span class="p">),</span>
   <span class="nf">member</span><span class="p">(</span><span class="nf">kuca</span><span class="p">(</span><span class="nv">VlasnikZebre</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="s s-Atom">zebra</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">),</span> <span class="nv">Kuce</span><span class="p">),</span>
   <span class="nf">member</span><span class="p">(</span><span class="nf">kuca</span><span class="p">(</span><span class="nv">PijeVodu</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="s s-Atom">voda</span><span class="p">,</span> <span class="k">_</span><span class="p">),</span> <span class="nv">Kuce</span><span class="p">).</span>
</pre></div>
</div>
</div>
</div>


    </div>
    
    <div>
<div class="lecture-prev-next-toggle">
  <a  href="02_predikatska_logika.html" id="prevLectureLink" class="lecture-toggler-arrows"><i class="fas fa-arrow-left fa"></i> <span> Претходна лекција </span> </a>
  
</div>

<script type="text/javascript">
  $('#relations-prev').tooltip({'placement':'right', 'selector': '', 'delay': { show: 100, hide: 50}});
  $('#relations-next').tooltip({'placement':'left', 'selector': '', 'delay': { show: 100, hide: 50}});
</script>
</div>

    
  </div>
</div>

<div class="petljadoc-resources">
  <span class="pull-left">(Created using  <a href="https://pypi.org/project/Sphinx/">Swinx</a>, <a href="http://runestoneinteractive.org/">RunestoneComponents</a> and <a href="https://github.com/Petlja/PetljaDoc">PetljaDoc</a>) <br> © 2022 Petlja</span>
</div>


<div class="lectureToolbox">

  <label class="font-size-toggle" id="fontSizeToggle">

      <i class="fas fa-font"></i><label>Слова</label>
  </label>
  <div class="font-change d-none" id="fontChangeModal">
      <span class="dec-letter-icon" id="decLetterIcon">A-</span>
      <label id="currentFontSize">16</label>
      <span class="inc-letter-icon" id="incLetterIcon">A+</span>
  </div>
</div>

</div>

  </body>
</html>