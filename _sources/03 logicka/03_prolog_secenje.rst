Дрво извођења
-------------

Задатак програмера је да кроз базу знања опише чињенице и правила
закључивања, а задатак PROLOG система је да провери да ли је дати упит
логичка последица базе знања. Иако програмер не би требало да води
рачуна о томе како се та провера врши (рекли смо да се у основи крије
механизам резолуције), често се ипак тај механизам представља дрветом
које помаже да се разуме шта се у позадини дешава.


Сечење
------

У циљу смањења простора претраге, спречавања нежељеног бектрекинга и
на тај начин изостављања неких нетачних одговора или оптимизације
времена извршавања PROLOG уводи **оператор сечења** или **рез**
(енг. *cut*). Оператор сечења је често нужно примењивати да би се
добили довољно ефикасни програми. Нажалост, применом оператора сечења
нарушава се јасна логичка структура PROLOG програма и разумевање
њиховог значења престаје да буде засновано на примени чистих логичких
закона и правила извођења, већ је приликом анализе програма потребно
узети у обзир механизам израчунавања (рез се најбоље разуме тако што
се прати његов ефекат на стабло израчунавања), што је много
компликованије. Дакле, рез се слободно може посматрати као још једна
слаба тачка језика PROLOG – поред све теорије на којој се заснива
логичка парадигма, нелогички елемент као што је рез постаје кључан за
ефикасно решавање проблема употребом логичке парадигме!

Оператор сечења се означава са ``!``, увек успева (када се наведе у
правилу, сматра се да је резултат његовог израчунавања тачан), али у
повратку спречава бектрекинг и враћање преко њега здесна
налево. Размотримо неколико примера.

Максимум се може дефинисати на следећи начин

.. code-block:: prolog

   min(X, Y, X) :- X =< Y.
   min(X, Y, Y) :- Y < X.

Ако се на основу првог правила одреди да је ``X =< Y``, тада нема
потребе приликом бектрекинга проверавати друго правило јер унапред
знамо да његов услов неће бити испуњен. Зато се програм може убрзати
тако што се иза услова у првом правилу дода оператор сечења.


.. code-block:: prolog

   min(X, Y, X) :- X =< Y, !.
   max(X, Y, Y) :- Y < X.

Приликом упита ``?- max(3, 5, M)`` извршиће се унификација којом ће се
везати променљива ``X`` са вредношћу 3, ``Y`` са вредношћу 5 и ``M``
са вредношћу ``X``, тј. 3, провериће се услов ``3 =< 5`` који ће бити
тачан, провериће се оператор сечења који је тачан када се рачуна слева
надесно и доћи ће се до краја правила и пријавиће се резултат ``M=3``.

Претходна употреба оператора сечења је **зелена**, јер се оператором
сечења програм само убрзава и не мења му се значење.

Можемо отићи и корак даље и из другог правила изоставити услов ``Y <
X``. Наиме, пошто у првом правилу постоји сечење, јасно је да ће се до
провере другог правила стићи само ако услов првог правила није испуњен,
тј. ако не важи ``X =< Y``, тј. сигурно тада знамо да важи ``Y > X``.
   
.. code-block:: prolog

   max(X, Y, X) :- X =< Y, !.
   max(X, Y, Y).

Вредност максимума бројева 3 и 5 можемо израчунати у било ком
редоследу да су задати.

- Упит ``?- max(3, 5, M)`` се извршава на већ описани начин, добија се
  резултат ``M=5`` и због сечења се не траже друга решења.
- Упит ``?- max(5, 3, M)`` се извршава тако што се унификује ``X`` са
  5, ``Y`` са 3, проверава се ``5 =< 3`` и пошто тај услов није
  испуњен, одустаје се од овог правила. Затим се прелази на друго
  правило, унификују се ``X`` и 5, ``Y`` и ``3`` и ``M`` и ``Y``,
  тј. 3, након чега се пријављује резултат ``M=3``. Приликом тражења
  других решења враћамо се уназад, наилазимо на сечење и бектрекинг се
  прекида.
   
Ипак, ова употреба оператора сечења је **црвена**, јер се оператором
сечења мења значење програма. Заиста, наредни упит сасвим неочекивано
враћа нетачан одговор ``true``.

.. code-block:: prolog

   ?- min(2, 3, 3).

Приликом његовог извршавања, покушава се унификација са левом страном
првог правила, што не успева. Унификација са левом страном другог
правила успева и пошто више нема услова на десној страни тог правила,
пријављује се одговор ``true``.

Дакле, иако сечење може скратити програм и омогућити нам да неке
услове не морамо да пишемо, треба бити веома обазрив јер такав програм
може исправно радити за неке услове, а престати да ради исправно за
неке друге упите. Приликом употребе сечења пожељно је увек користити
зелени, а не црвени облик сечења.

Сечење (додуше црвено) нам може помоћи да поједноставимо неке од
претходних дефиниција и да избегнемо експлицитно навођење додатних
услова. На пример, дефиниција степеновања се упрошћава.

.. code-block:: prolog

   stepen(_, 0, 1) :- !.
   stepen(X, N, S) :- N mod 2 =:= 0,
                      N1 is N // 2, X2 is X * X, stepen(X2, N1, S), !.
   stepen(X, N, S) :- N1 is N-1, stepen(X, N1, S1), S is S1 * X.

   
У неким случајевима би предикати који се не ограниче резом теоријски
враћали бесконачна решења, тј. упадали би у бесконачну рекурзију. На
пример, наредни предикат би тражио све просте бројеве (претпостављамо
да на располагању имамо предикат за проверу да ли је број прост).

.. code-block:: prolog

   prosti(N, [N|T]) :- prost(N), N1 is N + 1, prosti(N1, T).
   prosti(N, T) :- not(prost(N)), N1 is N + 1, prosti(N1, T).

Ако наметнемо горње ограничење на величину бројева које тражимо,
можемо употребити рез да зауставимо ову бесконачну претрагу, али и да
избегнемо скупу проверу да ли је број прост у оба правила.

.. code-block:: prolog

   prosti(N, Max, []) :- N > Max, !.
   prosti(N, Max, [N|T]) :- prost(N), N1 is N + 1, prosti(N1, T), !.
   prosti(N, Max, T) :- N1 is N + 1, prosti(N1, T).

   prosti(Max, P) :- prosti(2, Max, P).
