Исказна логика
==============

Основни појам логике је **исказ**. То је тврдња која може бити тачна
или нетачна. На пример, *"Београд је главни град Републике Србије"* је
тачан исказ, а *"7 је паран број"* је нетачан исказ.

.. infonote::
   
   У реалности постоје и тврдње које могу бити истините у некој мери,
   попут исказа *"напољу је данас топло"* који зависи од субјективног
   осећања, контекста (доба године) и слично. Ми се нећемо бавити
   таквом оценом већ ћемо разматрати само класичну логику у којој је
   сваки исказ или потпуно тачан или потпуно нетачан.

Сложене исказе добијамо тако што једноставне исказе повезујемо
логичким везницима.

На пример, исказ *"број 6 није прост"* је **негација** (**логичко
не**) исказа *"број 6 је прост"*. Пошто је други исказ нетачан, први
исказ (негација) је тачан. Негацију исказа :math:`p` означавамо са
:math:`\neg p` и њена истинитосна вредност је супротна од истинитосне
вредности полазног исказа.

.. math::

   \begin{array}{|c||c|}
   \hline
   p & \neg p \\
   \hline
   0 & 1 \\
   1 & 0 \\
   \hline
   \end{array}


Исказ *"7 је непаран прост број"* у себи крије **конјункцију**
(**логичко "и"**) исказа "7 је непаран број" и "7 је прост број". Сва
ова три исказа су тачна. Конјункција исказа је тачна ако и само ако су
тачна оба исказа.

Конјункција исказа :math:`p` и :math:`q` обележава се са :math:`p
\wedge q`. Истинитосна вредност тог исказа у зависности од истинитосне
вредности исказа :math:`p` и истиитосне вредности исказа :math:`q`
одређена је следећом таблицом (0 означава да је исказ нетачан, а 1 да
је тачан).

.. math::

   \begin{array}{|c|c||c|}
   \hline
   p & q & p \wedge q \\
   \hline
   0 & 0 & 0 \\
   0 & 1 & 0 \\
   1 & 0 & 0 \\
   1 & 1 & 1 \\
   \hline
   \end{array}

Купац добија попуст ако је тачан исказ *"купац је премијум купац или
му је рачун већи од 1000 динара"*. Тај исказ је **дисјункција**
(**логичко "или"**) исказа "Купац је премијум купац" и исказа "рачун
је већи од 1000 динара". Дисјункција је тачна када је било који од та
два исказа тачан тј. када је тачан бар један од њих. Могуће је да се
деси и да су оба исказа тачна и њихова дисјункција ће бити тачна (ако
премијум купац направи рачун већи од 1000 динара, исказ ће бити тачан
и он ће добити попуст). Таква дисјункција се назива **инклузивна
дисјункција**. У математици се подразумева да је дискункција
инклузивна осим ако се другачије не нагласи.

.. math::

   \begin{array}{|c|c||c|}
   \hline
   p & q & p \vee q \\
   \hline
   0 & 0 & 0 \\
   0 & 1 & 1 \\
   1 & 0 & 1 \\
   1 & 1 & 1 \\
   \hline
   \end{array}


Постоји и **ексклузивна дисјункција** која је тачна када је тачно
један од два исказа тачна. На пример, *"ићи ћу у посластичарницу или
ако имам пуно пара или ако сам пуно гладан"* може бити пример
ексклузивне дисјункције која је нетачна ако су оба услова испуњена
(јер неко може да се боји да ће се пуно угојити ако гладан и са пуно
пара оде у посластичарницу). Екслузивност дисјункције обично у
говорном језику наглашавамо коришћењем везника "или-или".

.. math::

   \begin{array}{|c|c||c|}
   \hline
   p & q & p \underline{\vee} q \\
   \hline
   0 & 0 & 0 \\
   0 & 1 & 1 \\
   1 & 0 & 1 \\
   1 & 1 & 0 \\
   \hline
   \end{array}


Размотримо исказ "ако будеш учио, добићеш добру оцену". Ово је пример
**импликације** (**ако-онда**). Размислимо када је овај исказ тачан
тј. када наставник говори истину, а када лаже.

- Ако је ученик учио и добио добру оцену, наставник је рекао
  истину.
- Ако је ученик учио, а наставник му није дао добру оцену, јасно је да
  је наставник слагао.
- Ако ученик није учио и није добио добру оцену, поново је јасно да
  наставник није ништа слагао.
- Донекле збуњујућ случај је ако ученик није учио, а наставник му ипак
  да добру оцену. Ни у овом случају не можемо рећи да је наставник
  лагао (можемо рећи да поклања оцене). Наиме, наставник у својој
  реченици није рекао ништа о томе шта ће се десити ако ученик не буде
  учио, па какву год оцену да му да, наставник није слагао ученика.
  
Дакле импликација је нетачна једино када је претпоставка испуњена а
закључак није (ученик јесте учио, а наставник му није дао добру
оцену). Импликација је тачна у свим осталим случајевима. Ако
претпоставка није испуњена, импликација је тачна (ако ученик не учи,
наставник не може да испадне лажов). Такође, ако је закључак тачан,
импликација је тачна (ако ученику да добру оцену наставник не може да
испадне лажов).
  
.. math::

   \begin{array}{|c|c||c|}
   \hline
   p & q & p \Rightarrow q \\
   \hline
   0 & 0 & 1 \\
   0 & 1 & 1 \\
   1 & 0 & 0 \\
   1 & 1 & 1 \\
   \hline
   \end{array}

Честа забуна је да људи мешају импликацију и **еквиваленцију**
тј. исказ "ако будеш учио, добићеш добру оцену" схватају као исказ
"добићеш добру цену ако и само ако будеш учио", што између осталог
значи да ако ученик не буде учио он сигурно неће добити добру
оцену. Еквиваленција је тачна једино када два исказа имају исту
истинитосну вредност (или су оба нетачна или су оба тачна).

.. math::

   \begin{array}{|c|c||c|}
   \hline
   p & q & p \Leftrightarrow q \\
   \hline
   0 & 0 & 1 \\
   0 & 1 & 0 \\
   1 & 0 & 0 \\
   1 & 1 & 1 \\
   \hline
   \end{array}

Применом ових логичких везника кренувши од елементарних исказа и
евентуално логичких константи :math:`\top` и :math:`\bot` градимо
сложене исказе тј.  **исказне формуле**. На пример, :math:`p \vee \neg
q \Leftrightarrow (p \wedge (\neg q \Rightarrow p))`. Подразумевамо да
у овако записаним формулама приоритет има оператор :math:`\neg`, затим
:math:`\wedge`, па :math:`\vee`, затим :math:`\Rightarrow` и на крају
:math:`\Leftrightarrow`.

.. infonote::

   **Синтакса** исказне логике дефинише како се граде исправно
   записане формуле. Прецизна дефиниција синтаксе формуле је
   одређена контекстно слободном граматиком:

   .. math::

      \begin{eqnarray*}
      \mathit{formula} &\rightarrow& promenljiva\\
      \mathit{formula} &\rightarrow& \top\\
      \mathit{formula} &\rightarrow& \bot\\
      \mathit{formula} &\rightarrow& \neg \mathit{formula}\\
      \mathit{formula} &\rightarrow& \mathit{formula} \wedge \mathit{formula}\\
      \mathit{formula} &\rightarrow& \mathit{formula} \vee \mathit{formula}\\
      \mathit{formula} &\rightarrow& \mathit{formula} \Rightarrow \mathit{formula}\\
      \mathit{formula} &\rightarrow& \mathit{formula} \Leftrightarrow \mathit{formula}\\
      \mathit{formula} &\rightarrow& (\mathit{formula})
      \end{eqnarray*}

   **Семантика** одређује истинитосну вредност формула. **Валуација**
   :math:`v` је функција која пресликава скуп променљивих у скуп
   :math:`\{0, 1\}` (променљиве које се сликају у 1 су тачне у тој
   валуацији, а оне које се сликају у 0 су нетачне у тој
   валуацији). Вредност формуле :math:`F` у валуацији :math:`v`
   обележавамо са :math:`I_v(F)`. Функцију :math:`I_v` дефинишемо
   рекурзивно, на основу водећег везника у формули.

   - :math:`I_v(\top) = 1`
   - :math:`I_v(\bot) = 0`
   - :math:`I_v(p) = v(p)`
   - :math:`I_v(\neg F) = 1 - I_v(F)`
   - :math:`I_v(F_1 \wedge F_2) = \min{(I_v(F_1), I_v(F_2))}`
   - :math:`I_v(F_1 \vee F_2) = \max{(I_v(F_1), I_v(F_2))}`
   - :math:`I_v(F_1 \Rightarrow F_2) = I_v(\neg F_1 \vee F_2)`
   - :math:`I_v(F_1 \Leftrightarrow F_2) = I_v((F_1 \Rightarrow F_2) \wedge (F_2 \Rightarrow F_1))`

   Кажемо да је формула :math:`F` **тачна у датој валуацији**
   :math:`v` ако и само ако је :math:`I_v(F) = 1`. Ово обележавамо и
   са :math:`v \vDash F`.


Неке исказне формуле су тачне без обзира на истинитосну вредност
полазних исказа од којих су изграђени. Такве формуле се називају
**таутологије**. На пример, формула :math:`\neg (p \wedge q)
\Leftrightarrow \neg p \vee \neg q` је тачна без обзира на то да ли су
:math:`p` и :math:`q` тачни (то је јасно ако разумемо да она говори о
томе да је исто рећи да није тачно да су :math:`p` и :math:`q` оба
тачни и рећи да бар један од њих није тачан).

      
.. math::

   \begin{array}{|c|c||c|}
   \hline
   p & q & \neg (p \wedge q) \Leftrightarrow \neg p \vee \neg q\\
   \hline
   0 & 0 & 1 \\
   0 & 1 & 1 \\
   1 & 0 & 1 \\
   1 & 1 & 1 \\
   \hline
   \end{array}

Доделу истинитосних вредности променљивих називамо **валуација** (на
пример, другом реду у претходној табели одговара валуација
:math:`p\mapsto 0, q\mapsto 1`). Таутологије су формуле које су тачне
у свим валуацијама. Негације таутологија су **незадовољиве**
тј. нетачне у свим валуацијама. Формуле које су тачне бар у једној
валуацији називамо **задовољиве формуле** а формуле које нису
таутлогије, тј. које су нетачне бар у једној валуацији називамо
**порециве формуле**.

Испитивање коректности закључивања се може свести на испитивање
таутологичности неких формула. Закључивање се обично заснива на томе
да се на основу тога што је познато да важи један или више исказа
(претпосавке тј. премисе) тврди да важи и неки додатни исказ (закључак
тј. конклузија). Закључак је исправан ако је он **логичка последица**
претпоставки тј. ако је тачан када год су све претпоставке тачне.  Да
би се испитало да ли је исказ :math:`q` логичка последица претпоставки
:math:`p_1, p_2, \ldots, p_n` (што можемо записати као :math:`p_1,
\ldots p_n \vDash q`), довољно је испитати да ли је формула :math:`p_1
\wedge p_2 \wedge \ldots \wedge p_n \Rightarrow q` таутологија. Дакле,
логичке последице су у тесној вези са импликацијом.

Испитивање таутологичности (али и задовољивости, незадовољивости и
порецивости) формула може се извршити испитивањем свих валуација
тј. прављењем истинитосне таблице, а видећемо да постоје и ефикаснији
и интуитивнији начини.


.. questionnote::
   
   На пример, претпоставимо да знамо да су искази *Ако је Цеца
   победила онда је Марија била друга или је Сандра била трећа"* и
   *"Сандра није била трећа"* тачни. Да ли је исправно из њих
   закључити да је исказ *"Ако Марија није била друга, онда Цеца није
   победила"*? Желимо да проверимо да ли је трећи исказ логичка
   последица прва два тј. да ли је трећи исказ тачан у свим
   валуацијама у којима су прва два тачна. Да би се то проверило
   довољно је проверити да је формула :math:`I_1 \wedge I_2
   \Rightarrow I_3` таутологија, где су са :math:`I_1` и :math:`I_2`
   означени полазни искази, а са :math:`I_3` исказ за који проверавамо
   да ли је њихова логичка последица. Ако са :math:`p` означимо исказ
   *"Цеца је победила"*, са :math:`q` исказ "Марија је била друга" и
   са :math:`r` исказ *"Сандра је била трећа"*, добијамо формулу:

   .. math::

      (p \Rightarrow q \vee r) \wedge (\neg r) \Rightarrow (\neg q \Rightarrow \neg p)

   Ова формула јесте таутологија, што доказујемо следећом истинитосном
   таблицом:

   .. math::

      \begin{array}{ccccccccccccccccccc}
      (p & \Rightarrow &q  & \vee& r) &\wedge& (\neg &r) &\Rightarrow &(\neg &q  &\Rightarrow &\neg &p)\\
      \hline
      {\bf 0}  & 1   & {\bf 0} & 0 & {\bf 0}  & 1    & 1     & 0 & 1          & 1    & 0 & 1          & 1  & 0\\
      {\bf 0}  & 1   & {\bf 0} & 1 & {\bf 1}  & 0    & 0     & 1 & 1          & 1    & 0 & 1          & 1  & 0\\
      {\bf 0}  & 1   & {\bf 1} & 1 & {\bf 0}  & 1    & 1     & 0 & 1          & 0    & 1 & 1          & 1  & 0\\
      {\bf 0}  & 1   & {\bf 1} & 1 & {\bf 1}  & 0    & 0     & 1 & 1          & 0    & 1 & 1          & 1  & 0\\
      {\bf 1}  & 0   & {\bf 0} & 0 & {\bf 0}  & 0    & 1     & 0 & 1          & 1    & 0 & 0          & 0  & 1\\
      {\bf 1}  & 1   & {\bf 0} & 1 & {\bf 1}  & 0    & 0     & 1 & 1          & 1    & 0 & 0          & 0  & 1\\
      {\bf 1}  & 1   & {\bf 1} & 1 & {\bf 0}  & 1    & 1     & 0 & 1          & 0    & 1 & 1          & 0  & 1\\
      {\bf 1}  & 1   & {\bf 1} & 1 & {\bf 1}  & 0    & 0     & 1 & 1          & 0    & 1 & 1          & 0  & 1\\
      \end{array}   

   Приметимо да смо у претходној истинитосној таблици вредности
   променљивих писали испод њиховог назива, док смо испод сваког
   везника писали истинитосну вредност потформуле којој је тај везник
   водећи везник. Водећи везник у целој формули је импликација која
   повезује конјункцију прва два исказа и трећи исказ, па је
   истинитосна вредност целе формуле исписана испод тог
   везника. Видимо да су у тој колони све јединице, што значи да је
   формула увек тачна, без обзира на истинитосне вредности исказа
   :math:`p`, :math:`q` и :math:`r` и да је таутологија.
   
Проблем метода истинитосних таблица је то што је тај метод веома
неефикасан. Наиме, за :math:`n` исказних променљивих таблица има
:math:`2^n` врста, па већ формуле од педесетак променљивих није могуће
обрадити на овакав начин, чак ни уз коришћење веома ефикасних
савремених рачунара. Таутологичност можемо доказати и неким другим
методама. Једна од популарнијих је и **метода семантичких таблоа**.

.. questionnote::

   Покушавамо да пронађемо валуацију :math:`v` у којој ће цела формула
   бити нетачна тј.

   .. math::

      I_v\left((p \Rightarrow q \vee r) \wedge (\neg r) \Rightarrow (\neg q \Rightarrow \neg p)\right) = 0
      
   Пошто је у питању импликација, она ће бити нетачна ако и само ако
   су обе премисе тачне, а закључак нетачан. Дакле, потребно је да
   нађемо валуацију у којој важи:

   .. math::

      I_v\left(p \Rightarrow q \vee r\right) = 1\\
      I_v\left(\neg r\right) = 1\\
      I_v\left(\neg q \Rightarrow \neg p\right) = 0
      
   Пошто формула :math:`\neg r` мора бити тачна, у нашој траженој
   валуацији исказ :math:`r` мора бити нетачан, а пошто импликација
   :math:`\neg q \Rightarrow \neg p` мора бити нетачна, њена премиса
   мора бити тачна, а закључак нетачан. Тако долазимо до следећих
   услова:


   .. math::

      I_v\left(p \Rightarrow q \vee r\right) = 1\\
      I_v\left(r\right) = 0\\
      I_v\left(\neg q\right) = 1\\
      I_v\left(\neg p\right) = 0

   Пошто формула :math:`\neg q` мора бити тачна, исказ :math:`q` мора
   бити нетачан, а пошто формула :math:`\neg p` мора бити нетачна,
   исказ :math:`p` мора бити тачан.
      
   .. math::

      I_v\left(p \Rightarrow q \vee r\right) = 1\\
      I_v\left(r\right) = 0\\
      I_v\left(q\right) = 0\\
      I_v\left(p\right) = 1

   Међутим, ови услови су заједно неодрживи. Да би импликација
   :math:`p \Rightarrow q \vee r` била тачна потребно је или да је
   њена претпоставка :math:`p` нетачна или да је њен закључак :math:`q
   \vee r` тачан. Наш табло се зато грана на две могућности:

   - Прва могућност је да важи :math:`I_v(p)=0`, међутим то се коси са
     условом :math:`I_v(p)=1` који је раније изведен.

   - Друга могућност је да важи :math:`I_v(q \vee r)=1`. Да би ова
     импликација била тачна треба да важи или :math:`I_v(q)=1` или да важи
     :math:`I_v(r)=1`. Наш табло се зато поново грана на две могућности,
     међутим, лако се види да су обе неодрживе.

     - Ако важи :math:`I_v(q)=1`, тада није могуће да важи и
       :math:`I_v(q)=0`, што је услов који смо већ раније извели.
               
     - Ако важи :math:`I_v(r)=1`, тада није могуће да важи и
       :math:`I_v(r)=0`, што је услов који смо већ раније извели.

   Дакле, све гране нашег таблоа су контрадикторне и није могуће
   пронаћи валуацију у којој би наша формула била нетачна.

Често се у закључивању користи и чињеница да су две формуле **логички
еквивалентне**, што значи да је прва тачка ако и само ако је друга
тачна (логичка еквивалентност формула :math:`\phi_1` и :math:`\phi_2`
се некада обележва са :math:`\phi_1 \equiv \phi_2`). На пример,
еквивалентно је да ли смо рекли *ако је суво, онда није падала киша* и
*ако је падала киша, онда није суво*. Уопште, формуле :math:`p
\Rightarrow q` и :math:`\neg q \Rightarrow \neg p` су логички
еквивалентне (овај конкретан пример се назива контрапозиција).  Да би
се доказало да су :math:`\phi_1 \equiv \phi_2` еквиваленција, довољно
је доказати да је :math:`\phi_1 \Leftrightarrow \phi_2` таутологија.
Дакле, логичка еквиваленција је у тесној вези са еквиваленцијом.

   
SAT решавачи
------------
   
Постоји веома ефикасан софтвер који може да испита задовољивост
исказне формуле (који је, наравно, заснован на коришћењу другачијих
метода). Такви програми се називају **SAT решавачи** (енгл. SAT
solver). Постоје многи програми ове врсте, а најпознатији од њих је
вероватно решавач MiniSat (http://minisat.se/,
http://logicrunch.it.uu.se:4096/~wv/minisat/). Основни алгоритам на
ком су засновани SAT решавачи је DPLL алгоритам
(Дејвис-Патнам-Логеман-Ловеланд).

Иако они испитују само задовољивост формуле, могу се лако употребити
да провере и таутологичност. Наиме, решавач треба да провери
задовољивост негације формуле, па ако утврди да је негација
незадовољива, полазна формула је таутологија. Савремени SAT решавачи
могу да провере неке формуле са стотинама хиљада променљивих.

Да би се SAT решавачи могли користити, формула мора бити припремљена
на одговарајући начин. Потребно је превести формулу у
тзв. **конјунктивну нормалну форму (КНФ)** тј. представити је у облику
конјункције **клаузула** (каже се и клауза), где је свака клаузула
дисјункција **литерала**, а литерал је исказно слово или негација
исказног слова. На пример, наредна формула је у КНФ.

.. math::

   (p \vee \neg q) \wedge (\neg p \vee q \vee r) \wedge \neg r

Она се састоји од 3 клаузуле: :math:`p \vee \neg q` (она има два
литерала), :math:`\neg p \vee q \vee r` (она има три литерала) и
:math:`\neg r` (она има један литерал).

Превођење формуле у КНФ се може извршити коришћењем следећих логичких
еквиваленција:

.. math::

   \begin{eqnarray*}
   A \Leftrightarrow B &\equiv& (A \Rightarrow B) \wedge (B \Rightarrow A)\\
   A \Rightarrow B &\equiv& \neg A \vee B\\
   \neg (A \wedge B) &\equiv& \neg A \vee \neg B\\
   \neg (A \vee B) &\equiv& \neg A \wedge \neg B\\
   \neg (\neg A) &\equiv& A\\
   A \vee (B \wedge C) &\equiv& (A \vee B) \wedge (A \vee C)\\
   (A \wedge B) \vee C &\equiv& (A \vee C) \wedge (B \vee C)
   \end{eqnarray*}

Прве две омогућавају да се из формуле уклоне сва појављивања везника
:math:`\Leftrightarrow` и :math:`\Rightarrow`, наредне три да се све
негације спусте до нивоа исказних слова, а последње две да се применом
дистрибутивности добије жељени однос конјункција и дисјункција. Када
је потребно, може се примењивати и асоцијативност конјункције и
дисјункције.

За вежбу вам остављамо да докажете да су све претходне везе заиста
логичке еквиваленције.

.. questionnote::
   

   КНФ облик негације формуле из претходног примера је:
    
   .. math::
    
      (\neg p \vee q \vee r) \wedge \neg r \wedge \neg q \wedge p
    
   Формуле :math:`\neg (A \Rightarrow B)` и :math:`A \wedge \neg B`
   еквивалентне (што се лако може утврдити провером таутологичности
   формуле :math:`\neg (A \Rightarrow B) \Leftrightarrow A \wedge \neg
   B`). Зато је негација формуле облика :math:`I_1 \wedge I_2
   \Rightarrow I` еквивалентна формули :math:`I_1 \wedge I_2 \wedge
   \neg I`, па је негација полазне формуле еквивалентна формули:
    
    
   .. math::
    
      (p \Rightarrow q \vee r) \wedge \neg r \wedge \neg (\neg q \Rightarrow \neg p)
    
   На основу истог правила претходна формула се може свести на:
    
   .. math::
    
      (p \Rightarrow q \vee r) \wedge \neg r \wedge (\neg q \wedge \neg \neg p)
    
   Сада можемо употребити чињеницу да су :math:`A \Rightarrow B` и
   :math:`\neg A \vee B` еквивалентне (што се може лако утврдити
   испитивањем таутологичности формуле :math:`(A \Rightarrow B)
   \Leftrightarrow (\neg A \vee B)`) и добити:
    
    
   .. math::
    
      (\neg p \vee (q \vee r)) \wedge \neg r \wedge (\neg q \wedge \neg \neg p)
    
   На крају, применом чињенице да су :math:`\neg \neg A` и :math:`A`
   еквивалентне и применом закона асоцијативности за конјункцију и
   дисјунцкију (који нам омогућавају да неке заграде изоставимо) добијамо
   КНФ облик:
    
   .. math::
    
      (\neg p \vee q \vee r) \wedge \neg r \wedge \neg q \wedge p


.. infonote::

   Применом дистрибутивности може се добити КНФ формула која је много
   већа од полазне (чак експоненцијално већа). Постоје и ефикасније
   методе свођења формуле на КНФ.  Најпознатија од њих је **Цајтинова
   трансформација** (енгл. Tseitin transform) која уводи нова исказна
   слова којим се обележавају потформуле, пре превођења у КНФ. На
   пример, размотримо следећу формулу:

   .. math::
      
      (p \vee (q \wedge r)) \wedge (\neg p \vee \neg r)

   Њену потформулу :math:`q \wedge r` можемо обележити новим словом
   :math:`s_1`, чиме добијамо формулу:
     
   .. math::
      
      (p \vee s_1) \wedge (\neg p \vee \neg r) \wedge (s_1 \Leftrightarrow q \wedge r)

   Њену потформулу :math:`p \vee s_1` можемо обележити новим словом
   :math:`s_2`, чиме добијамо формулу:
   
   .. math::

      s_2 \wedge (\neg p \vee \neg r) \wedge (s_1 \Leftrightarrow q \wedge r) \wedge (s_2 \Leftrightarrow p \vee s_1)

   Њену потформулу :math:`\neg p \vee \neg r` можемо обележити новим словом
   :math:`s_3`, чиме добијамо формулу:
      
   .. math::

      s_2 \wedge s_3 \wedge (s_1 \Leftrightarrow q \wedge r) \wedge (s_2 \Leftrightarrow p \vee s_1) \wedge (s_3 \Leftrightarrow \neg p \vee \neg r)

   На крају, њену потформулу :math:`s_2 \wedge s_3` можемо обележити
   новим словом :math:`s_4`, чиме добијамо формулу:

   .. math::

      s_4 \wedge (s_1 \Leftrightarrow q \wedge r) \wedge (s_2 \Leftrightarrow p \vee s_1) \wedge (s_3 \Leftrightarrow \neg p \vee \neg r) \wedge (s_4 \Leftrightarrow s_2 \wedge s_3)
   
   Сада се свака од логичких еквиваленција лако може засебно превести
   у КНФ чиме се добија коначан КНФ облик полазне формуле.

   .. math::

      \begin{array}{l}
      s_4 \\
      (\neg s_1 \vee q) \wedge (\neg s_1 \vee r) \wedge (\neg q \vee \neg r \vee s_1)\ \wedge \\
      (\neg s_2 \vee p \vee s_1) \wedge (\neg p \vee s_2) \wedge (\neg s_1 \vee s_2)\ \wedge\\
      (\neg s_3 \vee \neg p \vee \neg r) \wedge (p \vee s_3)\wedge (r \vee s_3)\ \wedge \\
      (\neg s_4 \vee s_2) \wedge (\neg s_4 \vee s_3)\wedge (\neg s_2 \vee \neg s_3 \vee s_4)
      \end{array}
      

   Тиме се полазна формула увећава само за константни фактор.  Додуше
   добијена формула неће више бити логички еквивалентна полазној, већ
   само еквизадовољива, што значи да је КНФ облик задовољив ако и само
   ако је задовољива полазна формула. Приметимо да нам је то сасвим
   довољно за примену SAT решавача, јер утврђивањем незадовољивости
   КНФ облика аутоматски знамо да је и полазна формула незадовољива,
   док се утврђивањем задовољивости КНФ облика добија валуација која
   је уједно и валуација у којој је полазна формула тачна (довољно је
   просто занемарити вредности новоуведних променљивих у тој
   валуацији).

Формуле у КНФ облику се обично описују у DIMACS формату (то је
стандардни формат улаза SAT решавача). Променљиве се обележавају
бројевима 1, 2, 3 итд. Негативни бројеви означавају негације
променљивих. Свака клаузула се записује као низ бројева завршен нулом.
На пример, DIMACS запис формуле :math:`(p \vee \neg q) \wedge (\neg p
\vee q \vee r) \wedge \neg r` је:

::

   p cnf 3 3
   1 -2 0
   -1 2 3 0
   -3 0

Прва линија је заглавље и говори о томе да формула има 3 променљиве и
3 клаузуле. Променљиве :math:`p`, :math:`q` и :math:`r` су означене
редом бројевима 1, 2 и 3.

Ако овај текст снимимо у датотеку `formula.cnf` и покренемо SAT
решавач (на пример, MiniSAT) или је унесемо у веб-интерфејс SAT
решавача MiniSAT (http://logicrunch.it.uu.se:4096/~wv/minisat/),
добићемо резултат

::

   SAT
   -1 -2 -3 0

Ово значи да је формула задовољива и једна валуација у којој је та
формула тачна је :math:`p \mapsto 0, q \mapsto 0, r \mapsto 0`.

Судоку
......
   
Прикажимо сада како можемо искористити SAT решавач да решимо логичку
загонетку Судоку. Ова загонетка захтева да се поље димензије :math:`9
\times 9` попуни бројевима од 1 до 9 тако да су у свакој врсти, у
свакој колони и у сваком троуглу димензије :math:`3 \times 3` бројеви
различити. Потребно је да кодирамо овај проблем коришћењем исказне
логике. Означимо поља табеле са :math:`A_{ij}` за :math:`1 \leq i, j
\leq 9`. На сваком пољу може бити уписан било који број од 1
до 9. Основни искази ће бити означени са :math:`p_{ijv}` за :math:`1
\leq i, j, v \leq 9` и означаваће да је на пољу :math:`A_{ij}` уписана
вредност :math:`v`. Сваки од ових исказа може бити или тачан или
нетачан. Потребно је да одредимо и везе између исказа које ће
осигурати да ће њихове истинитосне вредности одређивати исправно решење
загонетке Судоку.

За почетак, на сваком пољу треба да пише тачно једна вредност, што
значи да за сваки пар :math:`i` и :math:`j` од 1 до 9 тачно једна од
променљивих :math:`p_{ij1}, \ldots, p_{ij9}` треба да има вредност
тачно. Ово можемо кодирати следећим формулама:

.. math::

   \begin{eqnarray*}
   p_{ij1} \vee p_{ij2} \vee \ldots \vee p_{ij9}\\
   p_{ij1} \Rightarrow \neg p_{ij2} \wedge \neg p_{ij3} \ldots \neg p_{ij9}\\
   p_{ij2} \Rightarrow \neg p_{ij1} \wedge \neg p_{ij3} \ldots \neg p_{ij9}\\
   \ldots\\
   p_{ij9} \Rightarrow \neg p_{ij1} \wedge \neg p_{ij2} \ldots \neg p_{ij8}
   \end{eqnarray*}

Свака од ових импликација се може разбити на 8 мањих импликација, а
затим се трансформацијом :math:`p \Rightarrow q` у :math:`\neg p \vee
q` може добити следећи низ клаузула (генеришу се засебно клаузуле за
свако :math:`i, j` од 1 до 9):

.. math::

   \begin{eqnarray*}
   p_{ij1} \vee p_{ij2} \vee \ldots \vee p_{ij9}\\
   \neg p_{ij1} \vee \neg p_{ij2} \\
   \neg p_{ij1} \vee \neg p_{ij3} \\
   \ldots \\
   \neg p_{ij1} \vee \neg p_{ij9} \\
   \neg p_{ij2} \vee \neg p_{ij3} \\
   \neg p_{ij2} \vee \neg p_{ij4} \\
   \ldots \\
   \neg p_{ij2} \vee \neg p_{ij9} \\
   \ldots \\
   \ldots \\
   \neg p_{ij8} \vee \neg p_{ij9} \\
   \end{eqnarray*}

На сличан начин треба да кодирамо услове да ће за сваку врсту
:math:`i` и сваку вредност :math:`v` од 1 до 9 тачно једна променљива
:math:`p_{i1v}, p_{i2v}, \ldots, p_{i9v}` бити тачна, а затим услове
да ће за сваку колону :math:`j` и сваку вредност :math:`v` од 1 до 9
тачно једна променљива :math:`p_{1jv}, p_{2jv}, \ldots, p_{9jv}` бити
тачна. На крају је потребно додати и услове за сваки од квадрата
димензије :math:`3\times 3`. Сваки од 9 квадрата се може задати паром
индекса :math:`(k, l)` између 0 и 2 (нпр. :math:`(0, 0)` означава
горњи леви квадрат, а :math:`(2, 2)` доњи десни). За сваки квадрат
:math:`(k, l)` и сваку вредност :math:`v` између 1 и 9, тачно једна од
променљивих

.. math::

   p_{(3k+1)(3l+1)v},\ p_{(3k+1)(3l+2)v},\ p_{(3k+1)(3l+3)v}\\
   p_{(3k+2)(3l+1)v},\ p_{(3k+2)(3l+2)v},\ p_{(3k+2)(3l+3)v}\\
   p_{(3k+3)(3l+1)v},\ p_{(3k+3)(3l+2)v},\ p_{(3k+3)(3l+3)v}

треба да буде тачна.

У загонетнки Судоку обично су задате вредности које су уписане у нека
поља (и то често тако да се гарантује да се остала поља могу попунити
на јединствен начин тј. да постоји само једно тачно решење загонетке).
Задате вредности једноставно кодирамо тако што решавачу дамо
једночлане клаузуле које садрже само променљиве за које унапред знамо
да су тачне. Наредни програм у језику C# кодира загонетку Судоку у
формату DIMACS који је стандардни улазни формат SAT
решавача. Имплементација је прилично праволинијска. Потребно је
пресликати променљиве :math:`p_{ijv}` на бројеве од :math:`1` до
:math:`9^3 = 729`. Најједноставнији начин да се то уради је да се
индекси :math:`ijv` тумаче као цифре (увећане за 1) у основи 9 тј. да
се свака променљива :math:`p_{ijv}` преслика у број :math:`(i-1) +
9\cdot (j-1) + 81\cdot (v-1) + 1`. Тада је и декодирање једноставно (и
своди се на одређивање вредности цифара у основи 9):

.. math::

   i = (p - 1)\ \mathrm{mod}\ 9 + 1\\
   j = ((p - 1)\ \mathrm{div}\ 9)\ \mathrm{mod}\ 9 + 1\\
   v = ((p - 1)\ \mathrm{div}\ 81) + 1

Програм генерише 81 услов јединствености броја на пољу (за 81 поље),
81 услов јединствености броја у врсти (за 9 врста и по 9 бројева), 81
услов јединствености броја у колони (за 9 колона и по 9 бројева) и 81
услов јединствености броја у мало квадрату (за 9 малих квадрата и по 9
бројева). Сваки услов јединствености има једну позитивну клаузулу са 9
литерала и :math:`{9 \choose 2} = 36` негативних клаузула са по 2
литерала. Укупан број општих клаузула је зато :math:`4 \cdot 81 \cdot
37`, а њима се додају у једночлане клаузуле за свако унапред попуњено
поље.

Коначна верзија програма дата је у наставку.
   
.. code-block:: csharp

   // ispisuje DIMACS zaglavlje
   static void Zaglavlje(int BrojPromenljivih, int BrojKlauzula)
   {
      Console.WriteLine("p cnf {0} {1}", BrojPromenljivih, BrojKlauzula);
   }

   // ispisuje klauzulu kao red u formatu DIMACS
   static void Klauzula(int[] promenljive)
   {
      foreach(int p in promenljive)
         Console.Write(p + " ");
      Console.WriteLine(0);
   }
                
   // kodira se uslov da je tacno jedna od promenljivih iz datog niza tacna
   static void TacnoJedna(int[] promenljive)
   {
       // klauzula koja dovodi do toga da bar jedna promenljiva iz niza
       // mora biti tacna
       Klauzula(promenljive);
       // klauzule koje za svaki par promenljivih zabranju da su obe
       // promenljive istovremeno tacne
       int[] kl = new int[2];
       for (int i = 0; i < promenljive.Length; i++)
           for (int j = i + 1; j < promenljive.Length; j++) {
               kl[0] = -promenljive[i];
               kl[1] = -promenljive[j];
               Klauzula(kl);
           }
   }

   // trojke (i, j, v) se kodiraju brojevima između 1 i 729
   static int P(int i, int j, int v)
   {
       return (i-1) + 9*(j-1) + 81*(v-1) + 1;
   }

   static void Main()
   {
       // ucitavamo vrednosti na zadatim poljima
       List<int> zadate = new List<int>();
       string linija;
       while ((linija = Console.ReadLine()) != null)
       {
           string[] delovi = linija.Split();
           int i = int.Parse(delovi[0]);
           int j = int.Parse(delovi[1]);
           int v = int.Parse(delovi[2]);
           zadate.Add(P(i, j, v));
       }

       // stampamo DIMACS zaglavlje
       Zaglavlje(729, 4*81*37 + zadate.Count);
   
       // jedinstvenost vrednosti na svakom polju
       int[] promenljive = new int[9];
       for (int i = 1; i <= 9; i++)
          for (int j = 1; j <= 9; j++)
          {
              for (int v = 1; v <= 9; v++)
                 promenljive[v-1] = P(i, j, v);
              TacnoJedna(promenljive);
          }
       
       // jedinstvenost vrednosti u svakoj vrsti
       for (int i = 1; i <= 9; i++)
          for (int v = 1; v <= 9; v++)
          {
              for (int j = 1; j <= 9; j++)
                 promenljive[j-1] = P(i, j, v);
              TacnoJedna(promenljive);
          }

       // jedinstvenost vrednosti u svakoj koloni
       for (int j = 1; j <= 9; j++)
          for (int v = 1; v <= 9; v++)
          {
              for (int i = 1; i <= 9; i++)
                 promenljive[i-1] = P(i, j, v);
              TacnoJedna(promenljive);
          }
       
       // jedinstvenost vrednosti u svakom kvadratu 3x3
       for (int k = 0; k < 3; k++)
          for (int l = 0; l < 3; l++)
             for (int v = 1; v <= 9; v++)
             {
                 for (int a = 1; a <= 3; a++)
                    for (int b = 1; b <= 3; b++)
                        promenljive[3*(a-1)+(b-1)] = P(3*k+a, 3*l+b, v);
                 TacnoJedna(promenljive);
             }

       // ispisujemo zadate promenljive
       foreach (int p in zadate)
       {
           int[] kl = {p};
           Klauzula(kl);
       }
   }

Програм учитава унапред попуњене вредности. На пример, судоку загонетка:

::

   . . . . . . . . 3
   9 . . 3 . 2 . . .
   6 8 . . . . . 5 .
   1 . . . . 5 . . 9
   5 . . 7 . . . 6 2
   . . 4 . 1 . 5 3 8
   3 4 . 8 . . 7 . .
   . . 1 9 . . . . .
   . 5 . . 7 3 . . .
   
се описује улазом:

::

   1 9 3
   2 1 9
   2 4 3
   2 6 2
   3 1 6
   3 2 8
   3 8 5
   4 1 1
   4 6 5
   4 9 9
   5 1 5
   5 4 7
   5 8 6
   5 9 2
   6 3 4
   6 5 1
   6 7 5
   6 8 3
   6 9 8
   7 1 3
   7 2 4
   7 4 8
   7 7 7
   8 3 1
   8 4 9
   9 2 5
   9 5 7
   9 6 3

Ако унесемо тај улаз нашем програму, добијамо исказну формулу
`<sudoku1.cnf>`_. Њеним решавањем помоћу SAT решавача добијамо
задовољавајућу валуацију у којој су тачне следеће променљиве (све
остале променљиве су нетачне):

::
   
     4  11  26  30  42  52  59  64  81
    90  91 103 114 125 128 138 151 158
   169 175 183 191 203 216 224 231 235
   244 259 267 279 281 293 301 314 318
   329 342 344 352 367 373 384 390 404
   408 420 432 436 442 458 461 473 484
   492 503 505 518 531 534 547 553 560
   575 579 590 601 607 613 630 632 645
   650 662 673 683 687 699 703 720 724

Њиховим декодирањем добијамо следеће решење:

::

   4 2 7 5 6 8 9 1 3
   9 1 5 3 4 2 6 8 7
   6 8 3 1 9 7 2 5 4
   1 3 2 6 8 5 4 7 9
   5 9 8 7 3 4 1 6 2
   7 6 4 2 1 9 5 3 8
   3 4 9 8 5 1 7 2 6
   8 7 1 9 2 6 3 4 5
   2 5 6 4 7 3 8 9 1

Вама препуштамо да сами напишете програм који ће приказати решење на
основу решења добијеног од SAT решавача (програм треба да прочита
решење, издвоји позитивне бројеве, декодира сваки од њих и да на
основу тога формира и испише Судоку матрицу). Покушајте и да проширите
формулу клаузулом која ће забранити добијање овог решења, да поново
покренете SAT решавач и на тај начин да проверите да ли је ово решење
јединствено.

Приметимо да је решавање Судоку загонетке свођењем на SAT веома
декларативно. У програму смо само морали да опишемо (клаузулама)
услове које решење мора да задовољава, а не и алгоритам како се до
решења долази (SAT решавач је коришћењем веома ефикасних метода до тог
решења дошао практично моментално).

.. infonote::

   Уместо да C# програм исписује излазну датотеку у формату DIMACS
   која се онда шаље спољашњем SAT решавачу, могуће је SAT решавач
   покренути директно из C# програма преко API које SAT решавачи
   обично нуде. Препуштамо ти да, на пример, инсталираш библиотеку
   **Microsoft.Solver.Foundation** (за то можеш користити NuGet), да
   проучиш како се она користи и да прилагодиш претходни програм тако
   да коришћењем ове библиотеке решава Судоку и приказује његово
   решење.
