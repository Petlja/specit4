<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Листе</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/activecode.css" />
    <link rel="stylesheet" type="text/css" href="../_static/codemirror.css" />
    <link rel="stylesheet" type="text/css" href="../_static/qchoice.css" />
    <link rel="stylesheet" type="text/css" href="../_static/clickable.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pytutor.css" />
    <link rel="stylesheet" type="text/css" href="../_static/modal-basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/datafile.css" />
    <link rel="stylesheet" type="text/css" href="../_static/dragndrop.css" />
    <link rel="stylesheet" type="text/css" href="../_static/fitb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/matrixeq.css" />
    <link rel="stylesheet" type="text/css" href="../_static/parsons.css" />
    <link rel="stylesheet" type="text/css" href="../_static/lib/prettify.css" />
    <link rel="stylesheet" type="text/css" href="../_static/poll.css" />
    <link rel="stylesheet" type="text/css" href="../_static/showEval.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tabbedstuff.css" />
    <link rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/video.css" />
    <link rel="stylesheet" type="text/css" href="../_static/webgldemo.css" />
    <link rel="stylesheet" type="text/css" href="../_static/webglinteractive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/karel.css" />
    <link rel="stylesheet" type="text/css" href="../_static/notes.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/associations.css" />
    <link rel="stylesheet" type="text/css" href="../_static/editor.css" />
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/user-highlights.css" type="text/css" />
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.1/css/all.css" type="text/css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-4.0.0-dist/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/flatly.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/petlja-course.css" type="text/css" />
    <link rel="stylesheet" href="../_static/nbstyle.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/runestonebase.js"></script>
    <script src="../_static/skulpt.min.js"></script>
    <script src="../_static/skulpt-stdlib.js"></script>
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/jquery.highlight.js"></script>
    <script src="../_static/bookfuncs.js"></script>
    <script src="../_static/codemirror.js"></script>
    <script src="../_static/xml.js"></script>
    <script src="../_static/css.js"></script>
    <script src="../_static/python.js"></script>
    <script src="../_static/htmlmixed.js"></script>
    <script src="../_static/javascript.js"></script>
    <script src="../_static/jquery_i18n/CLDRPluralRuleParser.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.messagestore.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.fallbacks.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.language.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.parser.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.emitter.js"></script>
    <script src="../_static/jquery_i18n/jquery.i18n.emitter.bidi.js"></script>
    <script src="../_static/activecode-i18n.en.js"></script>
    <script src="../_static/activecode-i18n.sr-Cyrl.js"></script>
    <script src="../_static/activecode.js"></script>
    <script src="../_static/clike.js"></script>
    <script src="../_static/timed_activecode.js"></script>
    <script src="../_static/animationbase.js"></script>
    <script src="../_static/mchoice.js"></script>
    <script src="../_static/timedmc.js"></script>
    <script src="../_static/timed.js"></script>
    <script src="../_static/mchoice-i18n.en.js"></script>
    <script src="../_static/mchoice-i18n.sr-Cyrl.js"></script>
    <script src="../_static/clickable.js"></script>
    <script src="../_static/timedclickable.js"></script>
    <script src="../_static/d3.v2.min.js"></script>
    <script src="../_static/jquery.ba-bbq.min.js"></script>
    <script src="../_static/jquery.jsPlumb-1.3.10-all-min.js"></script>
    <script src="../_static/pytutor.js"></script>
    <script src="../_static/codelens.js"></script>
    <script src="../_static/skulpt.min.js"></script>
    <script src="../_static/skulpt-stdlib.js"></script>
    <script src="../_static/datafile.js"></script>
    <script src="../_static/dragndrop.js"></script>
    <script src="../_static/timeddnd.js"></script>
    <script src="../_static/dragndrop-i18n.en.js"></script>
    <script src="../_static/dragndrop-i18n.sr-Cyrl.js"></script>
    <script src="../_static/fitb.js"></script>
    <script src="../_static/timedfitb.js"></script>
    <script src="../_static/fitb-i18n.en.js"></script>
    <script src="../_static/fitb-i18n.sr-Cyrl.js"></script>
    <script src="../_static/matrixeq.js"></script>
    <script src="../_static/lib/prettify.js"></script>
    <script src="../_static/lib/hammer.min.js"></script>
    <script src="../_static/parsons.js"></script>
    <script src="../_static/parsons-i18n.en.js"></script>
    <script src="../_static/parsons-i18n.sr-Cyrl.js"></script>
    <script src="../_static/timedparsons.js"></script>
    <script src="../_static/poll.js"></script>
    <script src="../_static/reveal.js"></script>
    <script src="../_static/shortanswer.js"></script>
    <script src="../_static/timed_shortanswer.js"></script>
    <script src="../_static/showEval.js"></script>
    <script src="../_static/tabbedstuff.js"></script>
    <script src="../_static/runestonevideo.js"></script>
    <script src="../_static/webglinteractive.js"></script>
    <script src="../_static/FileSaver.min.js"></script>
    <script src="../_static/Blob.js"></script>
    <script src="../_static/karelCorner.js"></script>
    <script src="../_static/karelRobot.js"></script>
    <script src="../_static/karelWorld.js"></script>
    <script src="../_static/karelChat.js"></script>
    <script src="../_static/karelRobotDrawer.js"></script>
    <script src="../_static/karelUI.js"></script>
    <script src="../_static/karel.js"></script>
    <script src="../_static/karel-i18n.en.js"></script>
    <script src="../_static/karel-i18n.sr-Cyrl.js"></script>
    <script src="../_static/notes.js"></script>
    <script src="../_static/pygamelib-init.js"></script>
    <script src="../_static/gallery.js"></script>
    <script src="../_static/associations.js"></script>
    <script src="../_static/associations-i18n.en.js"></script>
    <script src="../_static/associations-i18n.sr-Cyrl.js"></script>
    <script src="../_static/editor.js"></script>
    <script src="../_static/jszip.js"></script>
    <script src="../_static/editor-i18n.en.js"></script>
    <script src="../_static/editor-i18n.sr-Cyrl.js"></script>
    <script src="../_static/translations.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/jquery-ui-1.10.3.custom.min.js"></script>
    <script src="../_static/jquery-fix.js"></script>
    <script src="../_static/bootstrap-4.0.0-dist/js/bootstrap.min.js"></script>
    <script src="../_static/bootstrap-4.0.0-dist/js/bootstrap.bundle.min.js"></script>
    <script src="../_static/bootstrap-sphinx.js"></script>
    <script src="../_static/waypoints.min.js"></script>
    <script src="../_static/rangy-core.js"></script>
    <script src="../_static/rangy-textrange.js"></script>
    <script src="../_static/rangy-cssclassapplier.js"></script>
    <script src="../_static/user-highlights.js"></script>
    <script src="../_static/jquery.idle-timer.js"></script>
    <script src="../_static/processing-1.4.1.min.js"></script>
    <script src="../_static/jquery.hotkey.js"></script>
    <script src="../_static/jquery-migrate-1.2.1.min.js"></script>
    <script src="../_static/course-errors.js"></script>
    <script src="../_static/petlja.js"></script>
    <script src="../_static/require.js"></script>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
    <meta content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' name='viewport' />
    <link rel="shortcut icon" href="../_static/favicon.ico" type="image/ico" />
    <script type="text/javascript">
      eBookConfig = {};
      eBookConfig.host = 'http://127.0.0.1:8000' ? 'http://127.0.0.1:8000' : 'http://127.0.0.1:8000';
      eBookConfig.app = eBookConfig.host + '/runestone';
      eBookConfig.ajaxURL = eBookConfig.app + '/ajax/';
      eBookConfig.course = 'paradigme';
      eBookConfig.logLevel = '0';
      eBookConfig.loginRequired = 'false';
      eBookConfig.build_info = "";
      eBookConfig.isLoggedIn = false;
      eBookConfig.useRunestoneServices = false;
      eBookConfig.python3 = true;
      eBookConfig.basecourse = 'paradigme';
      eBookConfig.runestone_version = '';
      eBookConfig.imagesDir = '../_images/';
      eBookConfig.staticDir = '../_static/';
      if (typeof (Sk) != "undefined")
        Sk.imgPath = eBookConfig.imagesDir;
    </script>

  </head>

  <body>



<div id="navbar" class="content-header">
  <div class="right-side-nav">
    
    <div id="usefulLinksToggle" class="useful-links-toggle">
        <a class="dropdown-toggle dropdown-toggle-burger" role="button" href="#" id="usefulLinksDropdown" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-bars fa-2x"></i>
        </a>
        <div class="dropdown-menu dropdown-nav-links shadow-lg" aria-labelledby="usefulLinksDropdown" x-placement="bottom-start" style="position: absolute; transform: translate3d(-55px, 32px, 0px); top: 0px; left: 0px; will-change: transform;">
          <div class="links-title"> Корисни линкови</div>
          <div class="useful-link">
            <a href="https://www.sphinx-doc.org/en/master/usage/restructuredtext/index.html" target="_blank">Sphinx Docs</a></div>
          <div class="useful-link">
            <a href="https://github.com/Petlja/PetljaDoc/blob/master/README.md" target="_blank">Petljadoc</a></div>
          <div class="useful-link">
            <a href="https://github.com/RunestoneInteractive/overview" target="_blank">Runestone Interactive</a></div>
          
        </div>
    </div>

    
</div>

<div class="left-side-nav">
  <div class="course-logo-nav">
      <a target="_blank" href="https://petlja.org">
          <img src="../_static/img/petlja-logo-wt.svg" alt="petlja.org" id="lightPetljaLogo">
      </a>
  </div>
  <div class="course-logo-nav-kabinet">
      <a target="_blank" href="https://petlja.org/net.kabinet">
          <img src="../_static/img/netkabinet-logo-strelica-wt.svg" alt="petlja.org" id="lightNetKabinetLogo">
      </a>
  </div>
</div>


<div class="content-header-label" id = "content-header-label" href="../">Shrot description</div>

</div>




<div class="petljaCourseContainer">

<div class="petljaCourseContent">
  
           <div class="tableOfContent">
            <h5> Садржај </h5>
            </div>
           <div>
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-01%20paradigme>
                    <h5>О програмским парадигмама</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../01%20paradigme/01_o_paradigmama.html><div class="studioLecture" id=activity-01_o_paradigmama><i class="fas fa-file-alt activity-icon"></i>О програмским језицима и парадигмама</div></a>
                <a href=../01%20paradigme/02_imperativna.html><div class="studioLecture" id=activity-02_imperativna><i class="fas fa-file-alt activity-icon"></i>Императивна парадигма</div></a>
                </div>
            </div>
                
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-02%20funkcionalna>
                    <h5>Функционална парадигма</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../02%20funkcionalna/01_funkcionalna.html><div class="studioLecture" id=activity-01_funkcionalna><i class="fas fa-file-alt activity-icon"></i>О функционалној парадигми</div></a>
                <a href=../02%20funkcionalna/02_haskell.html><div class="studioLecture" id=activity-02_haskell><i class="fas fa-file-alt activity-icon"></i>Haskell - изрази и функције</div></a>
                <a href=../02%20funkcionalna/02b_haskell_liste.html><div class="studioLecture" id=activity-02b_haskell_liste><i class="fas fa-file-alt activity-icon"></i>Haskell - листе</div></a>
                <a href=../02%20funkcionalna/02c_haskell_tipovi.html><div class="studioLecture" id=activity-02c_haskell_tipovi><i class="fas fa-file-alt activity-icon"></i>Haskell - алгебарски типови података</div></a>
                <a href=../02%20funkcionalna/02z_haskell_vezba.html><div class="studioLecture" id=activity-02z_haskell_vezba><i class="fas fa-file-alt activity-icon"></i>Haskell - задаци за вежбу</div></a>
                </div>
            </div>
                
                <div class="courseContentsSection">
                <div class="lecture-div courseContentsSectionHeadline" id=lecture-03%20logicka>
                    <h5>Логичка парадигма</h5>
                    <i class="fas fa-angle-down caret-position "> </i>
                    <i class="fas fa-angle-up caret-position d-none"></i>
                </div>
                <div class="courseContentsSubSection d-none"><a href=../03%20logicka/01_logicka.html><div class="studioLecture" id=activity-01_logicka><i class="fas fa-file-alt activity-icon"></i>О логичкој парадигми</div></a>
                </div>
            </div>
                </div>
</div>



<div class="lectureContent">

  <div id="errors">
  </div>
  
  <div class="lectureContentMaterial">
  
    <div id="main-content">
    
  <section id="id1">
<h1>Листе<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h1>
<p>Листе су основна структура података у језику Haskell. Као што ћемо
видети њихова улога није само да чувају податке, као низови у
императивним програмским језицима, већ се у многим ситуацијама
линеарни алгоритми који користе петље изражавају коришћењем листа.</p>
<p>Могуће је изградити листу елемената било ког другог типа, при чему сви
елементи листе морају имати исти тип. Тип листе чији су елементи типа
<code class="docutils literal notranslate"><span class="pre">a</span></code> се означава са <code class="docutils literal notranslate"><span class="pre">[a]</span></code>. На пример, тип <code class="docutils literal notranslate"><span class="pre">[Int]</span></code> представља
листу елемената типа <code class="docutils literal notranslate"><span class="pre">Int</span></code>. Листа се може задати навођењем њених
елемената у угластим заградама.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Пошто није јасно ког су типа елементи (осим да су у питању неки
бројеви), тип ове листе је <code class="docutils literal notranslate"><span class="pre">Num</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">[a]</span></code>. Да би смо нагласили да је
у питању листа елемената типа <code class="docutils literal notranslate"><span class="pre">Int</span></code> довољно је нагласити да је било
који њен елемент (на пример, први) типа <code class="docutils literal notranslate"><span class="pre">Int</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="ow">::</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Ова листа је типа <code class="docutils literal notranslate"><span class="pre">Int</span></code>.</p>
<p>Празна листа се обележава са <code class="docutils literal notranslate"><span class="pre">[]</span></code>. Свака листа је или празна или је
добијена додавањем једног елемента (главе) на почетак неке краће листе
(репа). Додавање елемента на почетак листе се врши оператором <code class="docutils literal notranslate"><span class="pre">:</span></code>,
чији је тип <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span></code> (он прима елемент типа <code class="docutils literal notranslate"><span class="pre">a</span></code> и листу
типа <code class="docutils literal notranslate"><span class="pre">[a]</span></code> и враћа нову листу типа <code class="docutils literal notranslate"><span class="pre">[a]</span></code>). На пример,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Запис са угластим заградама је заправо скраћени запис за секвенцу
додавања елемената на почетак. На пример, листа <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4]</span></code>
интерно је представљена као:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
</pre></div>
</div>
<p>Оператор додавања на почетак је веома користан за изградњу нових
листа, пре свега јер је веома ефикасан (време извршавања је
<span class="math notranslate nohighlight">\(O(1)\)</span>.</p>
<p>Наредна рекурзивна функција гради листу цифара датог целог броја.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">digits</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w"></span>
<span class="nf">digits</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
<span class="nf">digits</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="p">`</span><span class="n">mod</span><span class="p">`</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">digits</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="p">`</span><span class="n">div</span><span class="p">`</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Израз <code class="docutils literal notranslate"><span class="pre">[a..b]</span></code> гради листу која садржи све целе бројеве између <code class="docutils literal notranslate"><span class="pre">a</span></code>
и <code class="docutils literal notranslate"><span class="pre">b</span></code>. На пример,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Израз <code class="docutils literal notranslate"><span class="pre">[a..]</span></code> гради бесконачну листу која почиње елементом
<code class="docutils literal notranslate"><span class="pre">a</span></code>. Због лењости она се не гради цела у меморији (то и не би било
могуће, јер немамо бесконачно меморије), али може учествовати у даљим
операцијама (као што ћемо видети у неким примерима у наставку).</p>
<p>Издвајање елемента са позиције <span class="math notranslate nohighlight">\(n\)</span> (при чему се позиције броје
од нуле) је могуће урадити оператором <code class="docutils literal notranslate"><span class="pre">!!</span></code>, међутим, његова
сложеност је линеарна у односу на дужину листе и овај оператор би
требало избегавати.</p>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>Листе у Haskell-у не треба схватати као колекције које се користе
за чување података и приступ подацима на основу њихове позиције!
Као што ћемо видети, њихова улога је пре да одмене петље него
низове на које смо навикли у императивним програмским језицима.</p>

    </div></div>
<p>Две листе се могу надовезати коришћењем оператора <code class="docutils literal notranslate"><span class="pre">++</span></code>. Враћа се
нова листа, а сложеност ове операције је линеарна.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id2">
<h1>Неке библиотечке функције за рад са листама<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h1>
<p>Језик Haskell нуди мноштво унапред дефинисаних функција за рад са
листама које је увек препоручено користити уместо дефинисања
сопствених функција. Поменимо само неке од њих.</p>
<ul>
<li><p>Функција <code class="docutils literal notranslate"><span class="pre">length</span></code> израчунава дужину листе. Обратите пажњу на то да
је њена сложеност линеарна у односу на дужину.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
<span class="mi">4</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Функција <code class="docutils literal notranslate"><span class="pre">sum</span></code> израчунава збир елемената листе. На пример,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
<span class="mi">10</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Функција <code class="docutils literal notranslate"><span class="pre">prod</span></code> израчунава производ елемената листе. На пример,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">prod</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
<span class="mi">24</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Функција <code class="docutils literal notranslate"><span class="pre">minimum</span></code> израчунава најмањи, а <code class="docutils literal notranslate"><span class="pre">maximum</span></code> израчунава
највећи елеменат листе. На пример,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">minimum</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
<span class="mi">3</span><span class="w"></span>
<span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">maximum</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
<span class="mi">8</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Функција <code class="docutils literal notranslate"><span class="pre">and</span></code> прима листу логичких вредности и врши њихову
конјункцију, док функција <code class="docutils literal notranslate"><span class="pre">or</span></code> врши њихову дисјункцију.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="p">[</span><span class="kt">True</span><span class="p">,</span><span class="w"> </span><span class="kt">False</span><span class="p">,</span><span class="w"> </span><span class="kt">True</span><span class="p">]</span><span class="w"></span>
<span class="kt">False</span><span class="w"></span>
<span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="p">[</span><span class="kt">True</span><span class="p">,</span><span class="w"> </span><span class="kt">False</span><span class="p">,</span><span class="w"> </span><span class="kt">True</span><span class="p">]</span><span class="w"></span>
<span class="kt">True</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Функција <code class="docutils literal notranslate"><span class="pre">head</span></code> издваја први елемент непразне листе <code class="docutils literal notranslate"><span class="pre">list</span></code>, а
функција <code class="docutils literal notranslate"><span class="pre">tail</span></code> гради нову листу добијену избацивањем првог
елемента из листе <code class="docutils literal notranslate"><span class="pre">list</span></code>. Обе функције се извршавају у константном
времену (пошто се елементи листе не могу мењати, функција <code class="docutils literal notranslate"><span class="pre">tail</span></code>
не мора да копира елементе листе).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"></span>
<span class="mi">5</span><span class="w"></span>
<span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Функција <code class="docutils literal notranslate"><span class="pre">take</span></code> прима број елемената <code class="docutils literal notranslate"><span class="pre">n</span></code> и листу <code class="docutils literal notranslate"><span class="pre">list</span></code> и
гради нову листу која садржи првих <code class="docutils literal notranslate"><span class="pre">n</span></code> елемената листе <code class="docutils literal notranslate"><span class="pre">list</span></code>.
Функција <code class="docutils literal notranslate"><span class="pre">drop</span></code> прима број елемената <code class="docutils literal notranslate"><span class="pre">n</span></code> и листу <code class="docutils literal notranslate"><span class="pre">list</span></code> и
гради нову листу која садржи све осим првих <code class="docutils literal notranslate"><span class="pre">n</span></code> елемената листе
<code class="docutils literal notranslate"><span class="pre">list</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">take</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span><span class="w"></span>
<span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">drop</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Функција <code class="docutils literal notranslate"><span class="pre">elem</span></code> проверава да ли се елемент налази у датој листи.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w"></span>
<span class="kt">True</span><span class="w"></span>
<span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w"></span>
<span class="kt">False</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Функција <code class="docutils literal notranslate"><span class="pre">reverse</span></code> обрће листу.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">reverse</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Функција <code class="docutils literal notranslate"><span class="pre">zip</span></code> прима две листе (обично исте дужине) и враћа листу
уређених парова елемената те две листе. Резултат има исту дужину као
краћа од две листе (преостали елементи дуже листе се занемарују).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">zip</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w"></span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">)]</span><span class="w"></span>
<span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">zip</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">]</span><span class="w"></span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">)]</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
<p>Помоћу ових функција је могуће једноставно дефинисати неке друге
фунцкије. Наведимо неколико примера.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинишимо функцију која израчунава факторијел броја <span class="math notranslate nohighlight">\(n\)</span>.</p>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">factorial</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="w"></span>
<span class="nf">factorial</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">prod</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="p">]</span><span class="w"></span>

<span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">factorial</span><span class="w"> </span><span class="mi">5</span><span class="w"></span>
<span class="mi">120</span><span class="w"></span>
</pre></div>
</div>
<p>Ова фунцкија је веома разумљива (много јаснија од било које итеративне
или рекурзивне имплементације), а њена сложеност је и даље линеарна
(додуше врши се множење великих бројева, које постаје неефикасно како
бројеви расту). Нема потребе да приказујемо како се ова функција
извршава корак по корак, јер је поступак израчунавања заправо сакривен
од корисника (што је сасвим пожељна особина). Довољно је рећи да је
факторијел производ бројева од 1 до n, а програмски језик се стара од
свим осталим детаљима.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинишимо функцију која дели листу на две половине приближно
једнаке дужине. Функција прима листу и враћа уређени пар листи.</p>

    </div></div>
<p>Када функцијом <code class="docutils literal notranslate"><span class="pre">length</span></code> израчунамо дужину листе, целобројним дељењем
са 2 (оператором <code class="docutils literal notranslate"><span class="pre">div</span></code>) можемо израчунати дужину једне половине
(дужина друге је једнака или за један већа). Када знамо дужину једне
половине листе, одговарајуће елементе можемо лако издвојити коришћењем
функција <code class="docutils literal notranslate"><span class="pre">take</span></code> и <code class="docutils literal notranslate"><span class="pre">drop</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">split</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">([</span><span class="n">a</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">])</span><span class="w"></span>
<span class="nf">split</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">   </span><span class="kr">let</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="n">xs</span><span class="p">;</span><span class="w"></span>
<span class="w">       </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">`</span><span class="n">div</span><span class="p">`</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="w">    </span><span class="kr">in</span><span class="w"> </span><span class="p">(</span><span class="n">take</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="n">drop</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"></span>

<span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">split</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w"></span>
<span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span><span class="w"></span>
<span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">split</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w"></span>
<span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span><span class="w"></span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинишимо функцију која гради листу која садржи све уређене парове
елемената листе.</p>

    </div></div>
<p>За листу <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4]</span></code> желимо да добијемо листу <code class="docutils literal notranslate"><span class="pre">[(1,</span> <span class="pre">2),</span> <span class="pre">(2,</span> <span class="pre">3),</span>
<span class="pre">(3,</span> <span class="pre">4)]</span></code>. Видимо да су први елементи ових парова <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code>, а
други елементи <code class="docutils literal notranslate"><span class="pre">[2,</span> <span class="pre">3,</span> <span class="pre">4]</span></code>. Ова друга листа је заправо реп
оригиналне листе, па се резултат може добити спајањем оригиналне листе
и њеног репа. Листа је дужа од свог репа, али се захваљујући особинама
функције <code class="docutils literal notranslate"><span class="pre">zip</span></code> њен последњи елемент занемарује, па није неопходно
пре спајања уклањати последњи елемент оргиналне листе.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pairs</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)]</span><span class="w"></span>
<span class="nf">pairs</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">zip</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Видели смо, дакле, да су ове функције већ довољно изражајне да се
помоћу њих изразе разни алгоритми. Ипак, пуна снага функционалног
програмирања долази када се ове функције искомбинују са функцијама
вишег реда које ћемо описати у наставку.</p>
<section id="id3">
<h2>Функције вишег реда<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h2>
<p>Неке функције могу као своје аргументе да примају друге
функције. Такве функције називамо <strong>функције вишег реда</strong> или
<strong>функционали</strong>.</p>
<p>Функције које се прослеђују функционалима су често веома једноставне и
пожељно је имати могућност њиховог једноставног дефинисања унутар
самог позива функционала. За то се могу користити <strong>анонимне
функције</strong> тј. <strong>ламбда изрази</strong>. На пример, израз <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code>
представља анонимну функцију која свој аргумент увећава за 1, док
израз <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">`mod`</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0</span></code> означава функцију која проверава
да ли је збир њена два аргумента паран. Анонимне функције се могу
добити и <strong>парцијалном применом</strong>. Наиме, све функције су Каријеве па
се често задавањем једног аргумента добијају нове функције. На пример,
<code class="docutils literal notranslate"><span class="pre">max</span> <span class="pre">0</span></code> је анонимна функција која прима број и враћа га ако је
позитиван, а враћа 0 ако није. И инфиксни оператори могу бити
парцијално примењени. Тако, на пример, <code class="docutils literal notranslate"><span class="pre">(&gt;</span> <span class="pre">0)</span></code> означава функцију
која прима број и испитује да ли је позитиван. Исто важи и за израз
<code class="docutils literal notranslate"><span class="pre">(0</span> <span class="pre">&lt;)</span></code>. Инфиксни оператори се могу проследити функционалима тако
што се наведу у заградама. На пример, <code class="docutils literal notranslate"><span class="pre">(+)</span></code> означава функцију
сабирања.</p>
<p>Функционални језици често корисницима нуде мноштво библиотечких
функционала чијим се комбиновањем може једноставно формулисати велики
број алгоритама. Самим тим, ручно писање рекурзивних постаје много
ређе него ручно писање петљи у императивним програмским
језицима. Набројмо неколико основних функционала језика Haskell.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">any</span> <span class="pre">pred</span> <span class="pre">list</span></code> - Функција <code class="docutils literal notranslate"><span class="pre">any</span></code> прихвата предикат <code class="docutils literal notranslate"><span class="pre">pred</span></code>
(функцију која враћа тип <code class="docutils literal notranslate"><span class="pre">bool</span></code> тј. проверава да ли дати елемент
има неко својство) и листу <code class="docutils literal notranslate"><span class="pre">list</span></code>. Враћа <code class="docutils literal notranslate"><span class="pre">True</span></code> ако постоји бар
један елемент у листи за који предикат <code class="docutils literal notranslate"><span class="pre">pred</span></code> враћа <code class="docutils literal notranslate"><span class="pre">True</span></code>,
иначе враћа <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">any</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w"></span>
<span class="kt">True</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">all</span> <span class="pre">pred</span> <span class="pre">list</span></code> - Функција <code class="docutils literal notranslate"><span class="pre">all</span></code> прихвата предикат <code class="docutils literal notranslate"><span class="pre">pred</span></code> и
листу <code class="docutils literal notranslate"><span class="pre">list</span></code>. Враћа <code class="docutils literal notranslate"><span class="pre">True</span></code> ако сви елементи у листи задовољавају
предикат <code class="docutils literal notranslate"><span class="pre">pred</span></code>, иначе враћа <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w"></span>
<span class="kt">False</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">zipWith</span> <span class="pre">f</span> <span class="pre">list1</span> <span class="pre">list2</span></code> - Функција <code class="docutils literal notranslate"><span class="pre">zipWith</span></code> прихвата
функцију <code class="docutils literal notranslate"><span class="pre">f</span></code> и две листе <code class="docutils literal notranslate"><span class="pre">list1</span></code> и <code class="docutils literal notranslate"><span class="pre">list2</span></code>. Она примењује
функцију <code class="docutils literal notranslate"><span class="pre">f</span></code> на парове елемената из <code class="docutils literal notranslate"><span class="pre">list1</span></code> и <code class="docutils literal notranslate"><span class="pre">list2</span></code> и
враћа нову листу резултата.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">takeWhile</span> <span class="pre">pred</span> <span class="pre">list</span></code> - Функција <code class="docutils literal notranslate"><span class="pre">takeWhile</span></code> прихвата
предикат <code class="docutils literal notranslate"><span class="pre">pred</span></code> и листу <code class="docutils literal notranslate"><span class="pre">list</span></code> и издваја елементе са почетка листе
све док задовољавају предикат <code class="docutils literal notranslate"><span class="pre">pred</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">takeWhile</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">dropWhile</span> <span class="pre">pred</span> <span class="pre">list</span></code> - Функција <code class="docutils literal notranslate"><span class="pre">dropWhile</span></code> прихвата
предикат <code class="docutils literal notranslate"><span class="pre">pred</span></code> и листу <code class="docutils literal notranslate"><span class="pre">list</span></code> и уклања елементе са почетка листе
све док задовољавају предикат <code class="docutils literal notranslate"><span class="pre">pred</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dropWhile</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
<p>Помоћу ових функција можемо имплементирати још неке алгоритме.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати функцију која проверава да ли је листа сортирана.</p>

    </div></div>
<p>Провера да ли је листа сортирана се своди на проверу да ли су сви
узастопни парови елемената такви да је први елемент мањи или једнак
од другог.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pairs</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)]</span><span class="w"></span>
<span class="nf">pairs</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">zip</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"></span>

<span class="nf">sorted</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">sorted</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">pairs</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"></span>

<span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sorted</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
<span class="kt">True</span><span class="w"></span>
<span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sorted</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
<span class="kt">True</span><span class="w"></span>
<span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sorted</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w"></span>
<span class="kt">False</span><span class="w"></span>
</pre></div>
</div>
<p>Тип <code class="docutils literal notranslate"><span class="pre">a</span></code> елемената листе мора бити такав да елементи могу да се
пореде по величини, што је наглашено условом <code class="docutils literal notranslate"><span class="pre">Ord</span> <span class="pre">a</span></code> (тип <code class="docutils literal notranslate"><span class="pre">a</span></code> мора
припадати класи типова <code class="docutils literal notranslate"><span class="pre">Ord</span></code>). Приметимо да је анонимна функција
<code class="docutils literal notranslate"><span class="pre">\(x,</span> <span class="pre">y)</span> <span class="pre">-&gt;</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> која пореди узастопне елементе дефинисана тако
да има један аргумент који је уређен пар бројева. Заиста, листа
<code class="docutils literal notranslate"><span class="pre">pairs</span> <span class="pre">xs</span></code> садржи уређене парове, а предикат је потребно задовољити
на сваком уређеном пару. Погрешно би било користити само кратку
нотацију <code class="docutils literal notranslate"><span class="pre">all</span> <span class="pre">(&lt;=)</span> <span class="pre">(pairs</span> <span class="pre">xs)</span></code>, јер је функција <code class="docutils literal notranslate"><span class="pre">(&lt;=)</span></code> Каријева
(њен тип је <code class="docutils literal notranslate"><span class="pre">Ord</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>, а не <code class="docutils literal notranslate"><span class="pre">Ord</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">(a,</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>).
Ово се, као што смо видели, лако решава коришћењем ламбда израза,
међутим, пошто је овај сценарио чест, на располагању нам је и функција
<code class="docutils literal notranslate"><span class="pre">uncurry</span></code> која од Каријеве функције прави функцију која ради над
уређеним паровима. Уз њено коришћење провера сортираности би могла
бити дефинисана на следећи начин:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">sorted</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">sorted</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="p">(</span><span class="n">uncurry</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;=</span><span class="p">))</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">pairs</span><span class="w"></span>
</pre></div>
</div>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>Наравно, чак и да функција <code class="docutils literal notranslate"><span class="pre">uncurry</span></code> није постојала у библиотеци,
она би лако могла бити дефинисана.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">my_uncurry</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"></span>
<span class="nf">my_uncurry</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
</pre></div>
</div>
<p>Заиста, ако је дата Каријева функција <code class="docutils literal notranslate"><span class="pre">f</span></code> типа <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">c</span></code> и
уређен пар <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code> типа (<code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code>), резултат типа <code class="docutils literal notranslate"><span class="pre">c</span></code> се
добија тако што се функција <code class="docutils literal notranslate"><span class="pre">f</span></code> прво примени на <code class="docutils literal notranslate"><span class="pre">x</span></code>, па се тако
добијена функција примени на <code class="docutils literal notranslate"><span class="pre">y</span></code>. Парцијална апликација
<code class="docutils literal notranslate"><span class="pre">my_uncurry</span> <span class="pre">f</span></code>, дакле враћа функцију која очекује уређен пар,
распакује његове елементе и затим примењује Каријеву функцију <code class="docutils literal notranslate"><span class="pre">f</span></code>
редом на њих.</p>
<p>Ако вас збуњује то што сматрамо да функција <code class="docutils literal notranslate"><span class="pre">my_uncurry</span></code> прима
функцију и враћа функцију, а дефинисали смо је тако што поред
функције прима и уређен пар, можете употребити и ламбда нотацију
(мада је прва дефиниција елегантнија).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">my_uncurry</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"></span>
<span class="nf">my_uncurry</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
</pre></div>
</div>
<p>Слично бисмо могли дефинисати и функцију <code class="docutils literal notranslate"><span class="pre">my_curry</span></code> која одговара
библиотечкој функцији <code class="docutils literal notranslate"><span class="pre">curry</span></code> и која функцију која функционише
над уређеним паровима претвара у Каријеву функцију.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">curry</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"></span>
<span class="nf">curry</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>

    </div></div>
<p>Проверу сортираности можемо имплементирати и на друге начине. У
наредној имплементацији се коришћењем функције <code class="docutils literal notranslate"><span class="pre">zipWith</span></code> прави листа
вредности типа <code class="docutils literal notranslate"><span class="pre">Bool</span></code>, а затим се помоћу функције <code class="docutils literal notranslate"><span class="pre">and</span></code> врши њена
конјункција.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">sorted</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">sorted</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="p">(</span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;=</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="w"> </span><span class="n">xs</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>Нагласимо и да се, услед лењости, помоћне листе у дефиницијама ових
функција не формирају у целости експлицитно у меморији, тако да су
овако дефинисане функције прилично ефикасне. Листе зато не треба
схватити искључиво као структуре података, већ пре свега као механизам
организовања контроле тока програма – видимо да нам уз листе и
библиотечке функције нису неопходне ни петље ни рекурзија и задатке
решавамо на много елегантнији начин, прилично декларативно.</p>
<p>Наредне функционали <code class="docutils literal notranslate"><span class="pre">map</span></code>, <code class="docutils literal notranslate"><span class="pre">filter</span></code> и <code class="docutils literal notranslate"><span class="pre">fold</span></code> се по свом значају
и својој општости обично истичу (већина функционала се може дефинисати
коришћењем ова три основна).</p>
<ul>
<li><p>Функција <code class="docutils literal notranslate"><span class="pre">filter</span></code> служи да из листе издвоји све оне елементе који
задовољавају дато својство. Она прихвата предикат <code class="docutils literal notranslate"><span class="pre">pred</span></code> и листу
<code class="docutils literal notranslate"><span class="pre">list</span></code> и враћа нову листу која садржи све оне елементе листе
<code class="docutils literal notranslate"><span class="pre">list</span></code> за које предикат <code class="docutils literal notranslate"><span class="pre">pred</span></code> враћа <code class="docutils literal notranslate"><span class="pre">True</span></code>. Дакле, функција
<code class="docutils literal notranslate"><span class="pre">filter</span></code> има следећи тип:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">filter</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Наредним позивима се издвајају сви позитивни, а затим и сви парни
елементи листе.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"></span>
<span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">mod</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>Функционал <code class="docutils literal notranslate"><span class="pre">filter</span></code> користимо када желимо да филтрирамо серију
елемената тј. да издвојимо све оне елементе који задовољавају
неко својство.</p>

    </div></div>
</li>
<li><p>Функција <code class="docutils literal notranslate"><span class="pre">map</span></code> прихвата функцију <code class="docutils literal notranslate"><span class="pre">f</span></code> и листу <code class="docutils literal notranslate"><span class="pre">list</span></code> и гради
нову листу тако што на сваки елемент листе <code class="docutils literal notranslate"><span class="pre">list</span></code> примени функцију
<code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
<p>Дакле, функција <code class="docutils literal notranslate"><span class="pre">map</span></code> има следећи тип:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">map</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Наредним позивом се квадрирају сви елементи листе, а затим се израчунавају
степени двојке:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">]</span><span class="w"></span>
<span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>Функционал <code class="docutils literal notranslate"><span class="pre">map</span></code> користимо када желимо да исто израчунавање
применимо на сваки елемент неке серије елемената.</p>

    </div></div>
</li>
<li><p>Функционал <code class="docutils literal notranslate"><span class="pre">fold</span></code> (у варијантама <code class="docutils literal notranslate"><span class="pre">foldl</span></code> и <code class="docutils literal notranslate"><span class="pre">foldr</span></code>) служи да
извршимо агрегацију неке серије елемената, узастопном применом неке
перације, кренувши од неког почетног елемента (обично неутралног
елемента за ту операцију).</p>
<p>Размотримо, на пример, сабирање серије елемената. Збир елемената
<span class="math notranslate nohighlight">\([x_0, x_1, x_2]\)</span> се може добити као <span class="math notranslate nohighlight">\(((0 + x_0) +
x_1) + x_2\)</span> или као <span class="math notranslate nohighlight">\(x_0 + (x_1 + (x_2 + 0))\)</span>. Први израз
представља основу итеративног алгоритма за израчунавање збира.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">zbir</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"></span>
<span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">zbir</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">zbir</span><span class="w"> </span><span class="p">+</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Веома слично, производ тих елемената добијамо изразима <span class="math notranslate nohighlight">\(((1
\cdot x_0) \cdot x_1) \cdot x_2\)</span> или као <span class="math notranslate nohighlight">\(x_0 \cdot (x_1 \cdot
(x_2 \cdot 1))\)</span>. Итеративни алгоритам се онда програмира на следећи
начин.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">proizvod</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"></span>
<span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">proizvod</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">proizvod</span><span class="w"> </span><span class="p">*</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Слично можемо дефинисати и функцију која одређује максимум серије
природних бројева. <span class="math notranslate nohighlight">\(max(max(max(0, x_0), x_1), x_2)\)</span> или
<span class="math notranslate nohighlight">\(max(x_0, max(x_1, max(x_2, 0)))\)</span>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">maks</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"></span>
<span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">maks</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="n">Max</span><span class="p">(</span><span class="n">maks</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Примећујемо јаку сличност свих ових алгоритама. У свима њима
израчунавање тече тако што постоји променљива у којој се мало по
мало акумулира коначан резултат. Параметри алгоритма су почетна
вредност резултата, затим функција која прима стару вредност
резултата и текући елемент серије (низа, листе) и рачуна нову,
ажурирану, вредност резултата и серија елемената која се обрађује.
У функционалном програмирању овакви алгоритми се изражавају
функцијом <cite>fold</cite>. У зависнсти од тога да ли се елементи обрађују с
лева на десно или здесна на лево разликујемо функције <code class="docutils literal notranslate"><span class="pre">foldl</span></code> и
<code class="docutils literal notranslate"><span class="pre">foldr</span></code> (леви и десни <code class="docutils literal notranslate"><span class="pre">fold</span></code>). Њихови типови су следећи:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foldl</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="nf">foldr</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
</div>
<p>Ове функције су примењиве и на друге колекције, не само на листе, па
им је тип мало општији од наведеног, али ћемо их ми примењивати само
на листе.</p>
<p>Тип <code class="docutils literal notranslate"><span class="pre">b</span></code> означава тип резултата, а тип <code class="docutils literal notranslate"><span class="pre">a</span></code> означава тип елемената
серије. Функција <code class="docutils literal notranslate"><span class="pre">foldl</span></code> прво добија функцију која на основу
текућег резултата и текућег елемента серије израчунава нову вредност
резултата, затим почетну вредност резултата и затим листу која
садржи елементе који се редом обрађују. Функција <code class="docutils literal notranslate"><span class="pre">foldr</span></code> прима
исте аргументе, осим што функција прима текући елемент серије и
текући резултат у обратном редоследу. Ефекат ових функција се може
описати на следећи начин.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foldl</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">[</span><span class="n">x0</span><span class="p">,</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="n">x2</span><span class="p">]</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">x0</span><span class="p">)</span><span class="w"> </span><span class="n">x1</span><span class="p">)</span><span class="w"> </span><span class="n">x2</span><span class="w">     </span><span class="n">тј</span><span class="o">.</span><span class="w">   </span><span class="p">((</span><span class="n">i</span><span class="w"> </span><span class="p">`</span><span class="n">f</span><span class="p">`</span><span class="w"> </span><span class="n">x0</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="n">f</span><span class="p">`</span><span class="w"> </span><span class="n">x1</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="n">f</span><span class="p">`</span><span class="w"> </span><span class="n">x2</span><span class="w"></span>

<span class="nf">foldr</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">[</span><span class="n">x0</span><span class="p">,</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="n">x2</span><span class="p">]</span><span class="w"></span>
<span class="nf">f</span><span class="w"> </span><span class="n">x0</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w">     </span><span class="n">тј</span><span class="o">.</span><span class="w">   </span><span class="n">x0</span><span class="w"> </span><span class="p">`</span><span class="n">f</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">x1</span><span class="w"> </span><span class="p">`</span><span class="n">f</span><span class="p">`</span><span class="w"> </span><span class="p">(</span><span class="n">x2</span><span class="w"> </span><span class="p">`</span><span class="n">f</span><span class="p">`</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>Када се врши обрада коначних листа, када се ради са асоцијативним
операцијама, леви и десни се <code class="docutils literal notranslate"><span class="pre">fold</span></code> могу користити синонимно, мада
може бити разлике у њиховој ефикасности (десни <code class="docutils literal notranslate"><span class="pre">fold</span></code> обично
ефикасније израчунава резултате).</p>
<p>На пример, збир елемената листе можемо лако изразити преко оба ова
функционала.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
<span class="mi">10</span><span class="w"></span>

<span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">foldr</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
<span class="mi">10</span><span class="w"></span>
</pre></div>
</div>
<p>У оба случаја се креће од резултата 0 и у сваком кораку се резултат
увећава за текући елемент листе.</p>
</li>
</ul>
<p>Прикажимо сада како се ове функције могу користити за дефинисање
разних других функција.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати функцију која одређује све делиоце броја. Није потребно
водити рачуна о ефикасности.</p>

    </div></div>
<p>Ако не водимо рачуна о ефикасности, сви делиоци броја се могу лако
одредити коришћењем филтрирања, директно на основу дефиниције.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">divisors</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w"></span>
<span class="nf">divisors</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">d</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">`</span><span class="n">mod</span><span class="p">`</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Написати програм који одређује првих 15 Армстронгових
бројева. Армстронгови бројеви су они k-тоцифрени бројеви чији је
збир k-тих степена цифара једнак самом броју. Није потребно водити
рачуна о ефикасности.</p>

    </div></div>
<p>Употребићемо раније дефинисану функцију <code class="docutils literal notranslate"><span class="pre">digits</span></code> за одређивање
цифара броја.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">digits</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w"></span>
<span class="nf">digits</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
<span class="nf">digits</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="p">`</span><span class="n">mod</span><span class="p">`</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">digits</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="p">`</span><span class="n">div</span><span class="p">`</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Дефинисаћемо сада функцију која проверава да ли је дати број
Армстронгов. Након одређивања низа цифара <code class="docutils literal notranslate"><span class="pre">cs</span></code> и његове дужине
<code class="docutils literal notranslate"><span class="pre">k</span></code>, сваку цифру дижемо на <code class="docutils literal notranslate"><span class="pre">k</span></code>-ти степен коришћењем функционала
<code class="docutils literal notranslate"><span class="pre">map</span></code> и затим сабирамо добијене степене функцијом <code class="docutils literal notranslate"><span class="pre">sum</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">isArmstrongNumber</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">isArmstrongNumber</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">cs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">digits</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">                           </span><span class="n">k</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="n">cs</span><span class="w"></span>
<span class="w">                      </span><span class="kr">in</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="p">(</span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="o">^</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="n">cs</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
</pre></div>
</div>
<p>Захваљујући лењости можемо дефинисати (бесконачну) листу Армстронгових
бројева тако што ћемо из низа свих природних бројева издвојити оне
који су Армстронгови. Након тога жељених првих 15 Армстронгових
бројева добијамо узимањем првих 15 елемената те бесконачне листе
(коришћењем функције <code class="docutils literal notranslate"><span class="pre">take</span></code>).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">armstrongNumbers</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w"></span>
<span class="nf">armstrongNumbers</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="n">isArmstrongNumber</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span><span class="w"></span>

<span class="nf">armstrongNumbers15</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w"></span>
<span class="nf">armstrongNumbers15</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">take</span><span class="w"> </span><span class="mi">15</span><span class="w"> </span><span class="n">armstrongNumbers</span><span class="w"></span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Коришћењем функција <code class="docutils literal notranslate"><span class="pre">and</span></code>, <code class="docutils literal notranslate"><span class="pre">or</span></code> и <code class="docutils literal notranslate"><span class="pre">map</span></code> дефинисати функцију
која проверава да ли сви елементи листе задовољавају дато својство
(што ради функција <code class="docutils literal notranslate"><span class="pre">all</span></code>), да ли неки елемент листе задовољава
дато својство (што ради функција <code class="docutils literal notranslate"><span class="pre">any</span></code>) и да ли листа садржи дати
елемент (што ради функција <code class="docutils literal notranslate"><span class="pre">elem</span></code>).</p>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">my_all</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">my_all</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="p">(</span><span class="n">map</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Још елегантније решење добијамо ако употребимо композицију.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">my_all</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">my_all</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="n">p</span><span class="w"></span>
</pre></div>
</div>
<p>На сличан начин можемо добити и функцију која проверава да ли дата
листа садржи дати елемент (што ради функција <code class="docutils literal notranslate"><span class="pre">elem</span></code>).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">my_elem</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">my_elem</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="o">==</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Наравно, препознајете вероватно да се овде заправо крије <code class="docutils literal notranslate"><span class="pre">any</span></code> који
је имплементиран композицијом <code class="docutils literal notranslate"><span class="pre">or</span></code> и <code class="docutils literal notranslate"><span class="pre">map</span></code>.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Применом функција <code class="docutils literal notranslate"><span class="pre">foldl</span></code> или <code class="docutils literal notranslate"><span class="pre">foldr</span></code> дефинисати функције за
израчунавање производа листе, минумума и обртање листе.</p>

    </div></div>
<p>Дефинисање производа је веома једноставно (крећемо од резултата 1 и у
сваком кораку множимо текући елемент и текући резултат).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">my_prod</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Num</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">my_prod</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldr</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
</pre></div>
</div>
<p>Налажење минимума има смисла само за непразне листе. Уместо да
размишљамо која би вредност била неутрална за операцију минимума (а то
је <span class="math notranslate nohighlight">\(+\infty\)</span>), можемо кренути од почетног елемента листе, а
затим обрадити реп листе (на текући резултат и текући елемент листе у
сваком кораку примењујемо функцију <code class="docutils literal notranslate"><span class="pre">max</span></code> којом се израчунава
максимум два дата броја.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">my_maximum</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">my_maximum</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Обртање листе можемо остварити тако што елементе обрађујемо један по
један с лева надесно (користимо <code class="docutils literal notranslate"><span class="pre">foldl</span></code>) и у сваком кораку текући
елемент додајемо на почетак тренутног резултата.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">my_reverse</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="nf">my_reverse</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">xs</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w">  </span><span class="kt">[]</span><span class="w"></span>
</pre></div>
</div>
<p>С обзиром да први аргумент функције <code class="docutils literal notranslate"><span class="pre">foldl</span></code> мора прво да прими
текући резултат, а затим елемент који се дописује, морали смо
употребити ламбда-израз тј. није било могуће написати само <code class="docutils literal notranslate"><span class="pre">foldl</span> <span class="pre">(:)</span>
<span class="pre">[]</span></code>.  Ипак, постоји уграђена функција <code class="docutils literal notranslate"><span class="pre">flip</span></code> која прима Каријеву
функцију и обрће јој редослед прва два аргумента.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">my_reverse</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="nf">my_reverse</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="p">(</span><span class="n">flip</span><span class="w"> </span><span class="p">(</span><span class="kt">:</span><span class="p">))</span><span class="w">  </span><span class="kt">[]</span><span class="w"></span>
</pre></div>
</div>

    <div class="note-wrapper infonote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/infonote-img.svg" class="note-image infonote-image" /> 
        <div class="course-content">
            
<p>Чак и да функција <code class="docutils literal notranslate"><span class="pre">flip</span></code> није дефинисана, она би се лако могла
дефинисати.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">my_flip</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"></span>
<span class="nf">my_flip</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
</pre></div>
</div>

    </div></div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Коришћењем неких од функционала <code class="docutils literal notranslate"><span class="pre">map</span></code>, <code class="docutils literal notranslate"><span class="pre">filter</span></code>, <code class="docutils literal notranslate"><span class="pre">fold</span></code>
дефинисати функцију која уклања све дупликате из листе,
задржавајући редослед елемената (задржати само прво појављивање
сваког елемента).</p>

    </div></div>
<p>Задатак можемо решити тако што елементе обрађујемо један по један,
здесна на лево, и текући елемент додајемо на почетак резултујуће
листе, али тек након што смо из резултујуће листе уклонили сва његова
појављивања (то су каснија појављиавања у оригиналној листи, а ми
желимо да задржимо само прва појављивања). За обраду једног по једног
елемента здесна налево користимо функцију <code class="docutils literal notranslate"><span class="pre">foldr</span></code>, а за уклањање
свих појављивања датог елемента из дате листе користимо функцију
<code class="docutils literal notranslate"><span class="pre">filter</span></code> (задржавамо само оне који су различити од текућег елемента
<code class="docutils literal notranslate"><span class="pre">x</span></code>).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">remdups</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="nf">remdups</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="o">/=</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="id4">
<h1>Компрехенсија (скуповна нотација)<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h1>
<p>Језик Haskell подржава специјалну синтаксу, направљену по узору на
уобичајену синтаксу за рад са скуповима, која може одменити употребу
функционала <code class="docutils literal notranslate"><span class="pre">map</span></code> и <code class="docutils literal notranslate"><span class="pre">filter</span></code>.</p>
<p>Слику скупа <span class="math notranslate nohighlight">\(A\)</span> функцијом <span class="math notranslate nohighlight">\(f\)</span> означавамо са
<span class="math notranslate nohighlight">\(\{f(x)\ |\ x \in A\}\)</span>. По узору на то на располагању нам је
нотација за слику листе <code class="docutils literal notranslate"><span class="pre">A</span></code> функцијом <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">xs</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>На пример, квадрате свих бројева од 1 до 10 можемо изградити на
следећи начин.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]]</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">36</span><span class="p">,</span><span class="mi">49</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">81</span><span class="p">,</span><span class="mi">100</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Наравно, ово одговара примени функције <code class="docutils literal notranslate"><span class="pre">map</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">36</span><span class="p">,</span><span class="mi">49</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">81</span><span class="p">,</span><span class="mi">100</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Скуп свих елемената скупа <span class="math notranslate nohighlight">\(A\)</span> који задовољавају услов <span class="math notranslate nohighlight">\(P\)</span>
се у математици обележава са <span class="math notranslate nohighlight">\(\{x \in A\ |\ P(x)\}\)</span>. По узору на
то, а у комбинацији са претходном нотацијом за пресликавање, листу
свих елемената листе <code class="docutils literal notranslate"><span class="pre">xs</span></code> који задовољавају предикат <code class="docutils literal notranslate"><span class="pre">P</span></code> можемо
добити помоћу:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="kt">P</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>На пример, сви парни бројеви мањи од 10 се могу добити помоћу:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">`</span><span class="n">mod</span><span class="p">`</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Приметимо да је ово исто као и примена филтрирања:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">`</span><span class="n">mod</span><span class="p">`</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Ова нотација допушта и комбиновање пресликавања и филтрирања.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="kt">P</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>На пример, квадрате парних бројева од 1 до 10 можемо добити помоћу:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">`</span><span class="n">mod</span><span class="p">`</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="mi">4</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">36</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">100</span><span class="w"></span>
</pre></div>
</div>
<p>Компрехенсија допушта и „угнежђене” петље. На пример,</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">]]</span><span class="w"></span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span><span class="w"></span>

<span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">`</span><span class="n">mod</span><span class="p">`</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span><span class="w"></span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Применом комрехенсије дефинисати функцију која надовезује све листе
које су елементи дате листе (овај ефекат има библиотечка функција
<code class="docutils literal notranslate"><span class="pre">concat</span></code>). На пример, <code class="docutils literal notranslate"><span class="pre">concat</span> <span class="pre">[[1,</span> <span class="pre">2],</span> <span class="pre">[3,</span> <span class="pre">4]]</span> <span class="pre">=</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4]</span></code>.</p>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">my_concat</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[[</span><span class="n">a</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="nf">my_concat</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">ys</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<section id="id5">
<h2>Рекурзивне функције са листама<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h2>
<p>Библиотечке функције, нарочито функције вишег реда, обично омогућавају
програмеру да у потпуности избегне коришћење традиционалних механизама
којима се задаје контрола тока програма: итерацију и рекурзију. Ипак,
у многим ситуацијама се решење искључиво помоћу библиотечких функција
сматра компликованим и програмери бирају да дефинишу своје функције
рекурзивно. Иако тај приступ може донекле смањити декларативност
програма, писање рекурзивних функција које обрађују листе јесте добра
вежба и сматра се да програмери треба да владају и том вештином.</p>
<p>Чињеница да је листа или празна или је облика <code class="docutils literal notranslate"><span class="pre">glava</span> <span class="pre">:</span> <span class="pre">rep</span></code> се
користи за дефинисање рекурзивних функција које обрађују листе.
Обично се први елемент тј. глава обележава са <code class="docutils literal notranslate"><span class="pre">x</span></code>, а реп листе са
<code class="docutils literal notranslate"><span class="pre">xs</span></code>. Прикажимо неколико примера.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати рекурзивну функцију која одређује дужину дате листе.</p>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">my_length</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">my_length</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="nf">my_length</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">my_length</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
</pre></div>
</div>
<p>Дужина празне листе је 0, а непразне је за 1 већа од дужине њеног
репа. Ако се глава не користи, обичај је да се обележи доњом цртом.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">my_length</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"></span>
<span class="nf">my_length</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="nf">my_length</span><span class="w"> </span><span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">my_length</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
</pre></div>
</div>
<p>Наравно, постоји библиотечка функција <code class="docutils literal notranslate"><span class="pre">length</span></code> којом се израчунава
дужина листе. Сложеност ових функција, као и већине других којима се
обрађују листе, је <span class="math notranslate nohighlight">\(O(n)\)</span>. Притом треба бити обазрив и да ова
наша имплементација може лако довести до прекорачења стека код
дугачких листа. Начин да се то заобиђе је да се користи тзв. репна
рекурзија о чему ће више речи бити у наставку.</p>
<p>Неке функције немају смисла за празну листу, па излаз из рекурзије
може бити једночлана листа. Таква је, на пример, функција која
израчунава последњи елемент дате листе.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати функцију која одређује последњи елемент дате листе.</p>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">my_last</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">my_last</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="nf">my_last</span><span class="w"> </span><span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">my_last</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
</pre></div>
</div>
<p>Наравно, постоји библиотечка функција која ово ради. Ако се ова
функција позове за празну листу, доћи ће до грешке приликом извршавања
програма.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати функцију која испитује да ли дати елемент припада датој
листи (аналогно  библиотечкој функцији <code class="docutils literal notranslate"><span class="pre">elem</span></code>).</p>

    </div></div>
<p>Ниједан елемент не припада празној листи, а непразној листи припада
ако и само ако је или једнак њеног глави или припада њеном репу.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">my_elem</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">my_elem</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span><span class="w"></span>
<span class="nf">my_elem</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">my_elem</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
</pre></div>
</div>
<p>Приметимо да смо у типу морали да наведемо услов <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">a</span></code>, што значи
да ова функција ради за листе елемената типа <code class="docutils literal notranslate"><span class="pre">a</span></code> где тип <code class="docutils literal notranslate"><span class="pre">a</span></code> мора
да има имплементиран оператор поређења једнакости <code class="docutils literal notranslate"><span class="pre">==</span></code>. Наравно, ако
се изостави потпис типа, преводилац аутоматски може да закључи
најопштији тип функције.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати функцију која одређује елемент листе на позицији n (она
одговара оператору индексног приступа <code class="docutils literal notranslate"><span class="pre">!!</span></code>).</p>

    </div></div>
<p>Подсетимо се, овим оператором се може прочитати елемент листе
са дате позиције (позиције се броје од нуле).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="mi">1</span><span class="w"></span>
</pre></div>
</div>
<p>Празна листа нема елемената, нулти елемент непразне листе је њена
глава, а n-ти елемент непразне листе је n минус први елемент њеног
репа. Дакле, рекурзивна имплементација може бити оваква:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nth_element</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="nf">nth_element</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="nf">nth_element</span><span class="w"> </span><span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">nth_element</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Нагласимо да је сложеност приступа елементу листе увек линеарна (и у
нашој имплементацији, али и када се користи оператор <code class="docutils literal notranslate"><span class="pre">!!</span></code>).</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати функцију која надовезује две листе (она одговара
оператору <code class="docutils literal notranslate"><span class="pre">++</span></code> којим се надовезују две листе).</p>

    </div></div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Наредни код говори више од речи (рекурзија се врши по првој листи):</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">my_append</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="nf">my_append</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">ys</span><span class="w"></span>
<span class="nf">my_append</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">my_append</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="n">ys</span><span class="w"></span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати функцију која додаје дати елемент на крај дате листе.</p>

    </div></div>
<p>У језику Haskell не постоји оператор додавања елемента на крај
листе. То није случајно, јер та операција мора бити сложености
<span class="math notranslate nohighlight">\(O(n)\)</span>. Синтаксички је овај ефекат могуће постићи помоћу
оператора надовезивања две листе, али ово не би требало користити,
због очигледне неефикасности.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Ручна имплементација додвања на крај се може урадити на слдећи начин.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">my_append</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="nf">my_append</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="w"></span>
<span class="nf">my_append</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">my_append</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Без коришћења уграђених функција имплементирати функцију која обрће
листу (чији је ефекат исти као ефекат библиотечке функције
<code class="docutils literal notranslate"><span class="pre">reverse</span></code>).</p>

    </div></div>
<p>Обртањем празне листе добија се празна листа, док се непразна листа
обрће тако што се иза обрнутог репа дода глава листе. Зато ћемо у овој
имплементацији употребити и претходно дефинисану функцију за додавање
на крај листе.</p>
<p>додвања на крај и употребимо је у имплементацији функције
која обрће листу (наравно, постоји и библиотечка функција
<code class="docutils literal notranslate"><span class="pre">reverse</span></code>).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">my_reverse</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="nf">my_reverse</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
<span class="nf">my_reverse</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">my_append</span><span class="w"> </span><span class="p">(</span><span class="n">my_reverse</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">   </span><span class="kr">where</span><span class="w"></span>
<span class="w">     </span><span class="n">my_append</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="w">     </span><span class="n">my_append</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="w"></span>
<span class="w">     </span><span class="n">my_append</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">my_append</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
</pre></div>
</div>
<p>Ова имплементација обртања је лоша. Наиме, сложеност функције
<code class="docutils literal notranslate"><span class="pre">my_append</span></code> је <span class="math notranslate nohighlight">\(O(n)\)</span>, па је сложеност функције <code class="docutils literal notranslate"><span class="pre">my_reverse</span></code>
<span class="math notranslate nohighlight">\(O(n^2)\)</span>.</p>
<p>Наредна имплементација обртања је мање јасна од претходне, али је
доста боља (њена сложеност је <span class="math notranslate nohighlight">\(O(n)\)</span>).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">my_reverse</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="nf">my_reverse</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">my_reverse&#39;</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
<span class="w">   </span><span class="kr">where</span><span class="w"> </span><span class="n">my_reverse&#39;</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">acc</span><span class="w"></span>
<span class="w">         </span><span class="n">my_reverse&#39;</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">my_reverse&#39;</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">acc</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Основна идеја алгоритма је да се узима један по један елемент са
почетка листе и да се додаје на почетак нове, резултујуће листе (коју
називамо акумулатор). Улога главне функције <code class="docutils literal notranslate"><span class="pre">my_reverse</span></code> је само да
убаци у игру ту нову листу и да цео посао пребацивања елемената
пребаци помоћној функцији <code class="docutils literal notranslate"><span class="pre">my_reverse'</span></code>. Она ради на следећи
начин. Ако је полазна листа празна, тада је коначан резултат оно што
се нагомилало у акумулатору. Ако је полазна листа непразна, онда њену
главу додајемо на почетак акумултатора и рекурзивно настављамо
пребацивање репа на овако проширени акумулатор. За разлику од почетне,
ова варијанта је репно рекурзивна, па не постоји опасност од
прекорачења стека приликом извршавања ове функције за дугачке листе.</p>
<p>Функција је репно-рекурзивна и лако је приказати њен рад:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">my_reverse</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span>
<span class="n">my_reverse</span><span class="s1">&#39; [1, 2, 3, 4] [] =</span>
<span class="n">my_reverse</span><span class="s1">&#39; [2, 3, 4] [1] =</span>
<span class="n">my_reverse</span><span class="s1">&#39; [3, 4] [2, 1] =</span>
<span class="n">my_reverse</span><span class="s1">&#39; [4] [3, 2, 1] =</span>
<span class="n">my_reverse</span><span class="s1">&#39; [] [4, 3, 2, 1] =</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Дефинисати функцију која проверава да ли су две листе једнаке (њен
ефекат треба да буде исти као ефекат оператора <code class="docutils literal notranslate"><span class="pre">==</span></code>).</p>

    </div></div>
<p>Једнакост две листе може да се провери оператором <code class="docutils literal notranslate"><span class="pre">==</span></code> (наравно, у
сложености <span class="math notranslate nohighlight">\(O(n)\)</span>). Вежбе ради, дефинишимо рекурзивну функцију
која ово ради. Ако су обе листе празне, оне су једнаке. Ако су обе
непразне, једнаке су ако и само ако су им главе и репови једнаки
(једнакост репова можемо испитати рекурзивно). У свим другим
случајевима листе су различите.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">equal</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"></span>
<span class="nf">equal</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">True</span><span class="w"></span>
<span class="nf">equal</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">equal</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="n">ys</span><span class="w"></span>
<span class="nf">equal</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">False</span><span class="w"></span>
</pre></div>
</div>
<p>Приметимо и како смо последњим шаблоном покрили оба случаја када је
једна листа празна, а друга непразна.</p>
<p>Прикажимо и како би могли да се имплементирају неки класични алгоритми
сортирања листе.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Имплементирати алгоритам сортирања уметањем (енгл. insertion sort).</p>

    </div></div>
<p>Дефинисићемо прво рекурзивну функцију <code class="docutils literal notranslate"><span class="pre">insert</span></code> која умеће елемент на
његово место у сортираној листи, а затим ћемо имплементирати и
функцију <code class="docutils literal notranslate"><span class="pre">insertion_sort</span></code> која сортира листу коришћењем функције
<code class="docutils literal notranslate"><span class="pre">insert</span></code>.  Уметањем елемента у празну листу добија се једночлана
листа која садржи тај елемент. Уметање у непразну листу зависи од тога
да ли је елемент који се умеће мањи од главе листе или није. Ако
јесте, нови елемент се поставља на почетак те листе, а ако није, глава
се задржава, а нови елемент се рекурзивно умеће у реп
листе. Сортирањем празне листе добија се празна листа. Сортирање
непразне листе врши се тако што се сортира реп, а затим се глава
уметне на своје место у сортираном репу.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">insert</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="nf">insert</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="nf">insert</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">x</span><span class="w">     </span><span class="ow">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">insert</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>

<span class="nf">insertion_sort</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="nf">insertion_sort</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
<span class="nf">insertion_sort</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">insert</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">insertion_sort</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Приметимо да смо у потписима типова морали да нагласимо да тип
елемената листе мора припада класи типова <code class="docutils literal notranslate"><span class="pre">Ord</span> <span class="pre">a</span></code>, што значи да се
елементи типа <code class="docutils literal notranslate"><span class="pre">a</span></code> могу поредити (операторима <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> и
<code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>).</p>
<p>Сложеност функције <code class="docutils literal notranslate"><span class="pre">insert</span></code> је линеарна, па је укупна сложеност,
очеквано, квадратна.</p>
<p>Наравно, <code class="docutils literal notranslate"><span class="pre">insertion_sort</span></code> очигледно акумулира резултат додајући
један по један елемент функцијом <code class="docutils literal notranslate"><span class="pre">insert</span></code> па је сасвим природно да
она буде имплементирана помоћу <code class="docutils literal notranslate"><span class="pre">fold</span></code> (а не рекурзивно).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">insertion_sort</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="nf">insertion_sort</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="n">insert</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
</pre></div>
</div>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Имплементирати алгоритам сортирања обједињавањем (енгл. merge
sort).</p>

    </div></div>
<p>Дефинисаћемо три функције. Прва од њих, функција <code class="docutils literal notranslate"><span class="pre">merge</span></code> обједињава
две сортиране листе у трећу, такође сортирану.</p>
<p>Ако је било која од две листе празна, надовезивањем се добија она
друга листа. Ако су обе непразне, мања од две њихове главе се ставља
на почетак резултата а остатак резултата се добија спајањем репа те
листе и целе друге листе.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">merge</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="nf">merge</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">ys</span><span class="w"></span>
<span class="nf">merge</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
<span class="nf">merge</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">y</span><span class="w">      </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">merge</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">merge</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="n">ys</span><span class="w"></span>
</pre></div>
</div>
<p>Потребна нам је и функција која дели листу на две подлисте једнаке
дужине (једна од њих може, евентуално, садржати један елемент више
него друга). Ова функција треба да врати две листе. Најједноставније
је да то буде у облику уређеног пара. Тип уређеног пара означавамо
тако што тип сваког елемента наведемо у загради. На пример, <code class="docutils literal notranslate"><span class="pre">(Int,</span>
<span class="pre">Int)</span></code> је уређени пар који чине два податка типа <code class="docutils literal notranslate"><span class="pre">Int</span></code>. Дефинисаћемо
функцију <code class="docutils literal notranslate"><span class="pre">split</span></code> која прима листу елемената типа <code class="docutils literal notranslate"><span class="pre">a</span></code> и враћа
уређен пар таквих листа. Имплементираћемо је тако што ће елементе из
полазне листе наизменично распоређивати у те две резултујуће листе.
Дакле, ако делимо празну листу, резултат ће бити две празне листе. Ако
делимо листу која има бар два елемента, рекурзивно ћемо поделити реп
листе добијен избацивањем та два елемента, а онда ћемо та два елемента
распоредити сваки у по једну од листе добијене из рекурзивног позива.
Не смемо још заборавити случај једночлане листе, пошто он није
покривен са последња два случаја. У том случају ћемо вратити пар у
коме једна листа садржи тај једини елемент, а друга је празна (у
зависности да ли тај елемент распоредимо лево или десно, приликом
поделе листе са непарним бројем елемената лева или десна листа ће
имати један елемент више).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">split</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">([</span><span class="n">a</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">])</span><span class="w"></span>
<span class="nf">split</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">[]</span><span class="p">,</span><span class="w"> </span><span class="kt">[]</span><span class="p">)</span><span class="w"></span>
<span class="nf">split</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">([</span><span class="n">x</span><span class="p">],</span><span class="w"> </span><span class="kt">[]</span><span class="p">)</span><span class="w"></span>
<span class="nf">split</span><span class="w"> </span><span class="p">(</span><span class="n">x1</span><span class="kt">:</span><span class="n">x2</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">   </span><span class="kr">let</span><span class="w"> </span><span class="p">(</span><span class="n">ys</span><span class="p">,</span><span class="w"> </span><span class="n">zs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">split</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
<span class="w">    </span><span class="kr">in</span><span class="w"> </span><span class="p">(</span><span class="n">x1</span><span class="kt">:</span><span class="n">ys</span><span class="p">,</span><span class="w"> </span><span class="n">x2</span><span class="kt">:</span><span class="n">zs</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Нагласимо да смо резултат рекурзивног позива прихватили и елементе
уређеног пара именовали коришћењем израза <code class="docutils literal notranslate"><span class="pre">let-in</span></code>.</p>
<p>На крају дефинишемо и главну функцију сортирања. Листу делимо на две
половине функцијом <code class="docutils literal notranslate"><span class="pre">split</span></code>, сортирамо сваку половину рекурзивно и на
крају обједињујемо две добијене сортиране подлисте функцијом
<code class="docutils literal notranslate"><span class="pre">merge</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">merge_sort</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="nf">merge_sort</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
<span class="nf">merge_sort</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"></span>
<span class="nf">merge_sort</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="w">   </span><span class="kr">let</span><span class="w"> </span><span class="p">(</span><span class="n">ys</span><span class="p">,</span><span class="w"> </span><span class="n">zs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">split</span><span class="w"> </span><span class="n">xs</span><span class="w"></span>
<span class="w">    </span><span class="kr">in</span><span class="w"> </span><span class="n">merge</span><span class="w"> </span><span class="p">(</span><span class="n">merge_sort</span><span class="w"> </span><span class="n">ys</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">merge_sort</span><span class="w"> </span><span class="n">zs</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Приметимо да је једини механизам чистог функционалног програмирања
редукција израза на основу датих једнакости. Већ смо показали како се
на тај начин израчунавају врдности факторијела и НЗД. Ни ова,
компликованија, имплементација се не разликује.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">merge_sort</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="kr">let</span><span class="w"> </span><span class="p">(</span><span class="n">ys</span><span class="p">,</span><span class="w"> </span><span class="n">zs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">split</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">]</span><span class="w"></span>
<span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">merge</span><span class="w"> </span><span class="p">(</span><span class="n">merge_sort</span><span class="w"> </span><span class="n">ys</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">merge_sort</span><span class="w"> </span><span class="n">zs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="o">...</span><span class="w"></span>
<span class="nf">merge</span><span class="w"> </span><span class="p">(</span><span class="n">merge_sort</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w"> </span><span class="p">(</span><span class="n">merge_sort</span><span class="w"> </span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">])</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="nf">merge</span><span class="w"> </span><span class="p">(</span><span class="kr">let</span><span class="w"> </span><span class="p">(</span><span class="n">ys</span><span class="p">,</span><span class="w"> </span><span class="n">zs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">split</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"></span>
<span class="w">        </span><span class="kr">in</span><span class="w"> </span><span class="n">merge</span><span class="w"> </span><span class="p">(</span><span class="n">merge_sort</span><span class="w"> </span><span class="n">ys</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">merge_sort</span><span class="w"> </span><span class="n">zs</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="kr">let</span><span class="w"> </span><span class="p">(</span><span class="n">ys</span><span class="p">,</span><span class="w"> </span><span class="n">zs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">split</span><span class="w"> </span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">]</span><span class="w"></span>
<span class="w">        </span><span class="kr">in</span><span class="w"> </span><span class="n">merge</span><span class="w"> </span><span class="p">(</span><span class="n">merge_sort</span><span class="w"> </span><span class="n">ys</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">merge_sort</span><span class="w"> </span><span class="n">zs</span><span class="p">))</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="o">...</span><span class="w"></span>
<span class="nf">merge</span><span class="w"> </span><span class="p">(</span><span class="n">merge</span><span class="w"> </span><span class="p">(</span><span class="n">merge_sort</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">])</span><span class="w"> </span><span class="p">(</span><span class="n">merge_sort</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]))</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="n">merge</span><span class="w"> </span><span class="p">(</span><span class="n">merge_sort</span><span class="w"> </span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">])</span><span class="w"> </span><span class="p">(</span><span class="n">merge_sort</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">]))</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="o">...</span><span class="w"></span>
<span class="nf">merge</span><span class="w"> </span><span class="p">(</span><span class="n">merge</span><span class="w"> </span><span class="p">(</span><span class="n">merge</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="mi">6</span><span class="p">])</span><span class="w"> </span><span class="p">(</span><span class="n">merge</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="n">merge</span><span class="w"> </span><span class="p">(</span><span class="n">merge</span><span class="w"> </span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">])</span><span class="w"> </span><span class="p">(</span><span class="n">merge</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="mi">7</span><span class="p">]))</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="o">...</span><span class="w"></span>
<span class="nf">merge</span><span class="w"> </span><span class="p">(</span><span class="n">merge</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w"> </span><span class="p">(</span><span class="n">merge</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">])</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="o">...</span><span class="w"></span>
<span class="nf">merge</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"></span>
<span class="o">...</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>При том, није приказано како се корак-по-корак извршавају функције
<code class="docutils literal notranslate"><span class="pre">split</span></code> и <code class="docutils literal notranslate"><span class="pre">merge</span></code> (то вам остављамо за вежбу).</p>
<p>Сложеност ове функције је <span class="math notranslate nohighlight">\(O(n \log{n})\)</span>. Ипак, важна разлика у
односу на императивно сортирање низова је то што се у функционалном
програмирању листе не могу мењати и уместо измене оригиналне гради се
увек нова листа (што може узроковати одређену неефикасност). Додуше,
алгоритам сортирања обједињавањем и у императивној имплементацији
захтева коришћење помоћног низа.</p>

    <div class="note-wrapper questionnote-type">
        <div class="note-icon-holder"> </div>
        <img src="../_static/img/question-mark.png" class="note-image questionnote-image" /> 
        <div class="course-content">
<p>Имплементирати алгоритам брзог сортирања (енгл. quick sort).</p>

    </div></div>
<p>Основна идеја брзог сортирања је да се један елемент листе изабере за
тзв. пивотирајући елемент, да се остали елементи листе раздвоје на оне
који су мањи од пивота и оне који то нису, да се сваки од та два дела
листе рекурзивно сортира и да се резултат добије тако што се пивот
уметне између ова два сортирана дела. Та идеја се може веома
једноставно изразити у програмском језику Haskell (издвајање делова
листе који су мањи од пивота и који нису мањи од пивота се лако може
изразити помоћу компрехенсије или филтрирања).</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">qsort</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"></span>
<span class="nf">qsort</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w"></span>
<span class="nf">qsort</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">qsort</span><span class="w"> </span><span class="p">[</span><span class="n">y</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"></span>
<span class="w">               </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"></span>
<span class="w">               </span><span class="n">qsort</span><span class="w"> </span><span class="p">[</span><span class="n">y</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Сложеност ове функције је иста као и у императивној имплементацији,
међутим, ова имплементација није „у месту” тј. сортирање се не врши
само разменама елемената низа, тако да је ова функционална
имплементација мало неефикаснија, али је неупоредиво једноставнија и
разумљивија.</p>
</section>
</section>


    </div>
    
    <div>
<div class="lecture-prev-next-toggle">
  <a  href="02_haskell.html" id="prevLectureLink" class="lecture-toggler-arrows"><i class="fas fa-arrow-left fa"></i> <span> Претходна лекција </span> </a>
  
  <a id="nextLectureLink" class="lecture-toggler-arrows"><span> Следећа лекција</span>  <i class="fas fa-arrow-right fa"></i> </a>
</div>

<script type="text/javascript">
  $('#relations-prev').tooltip({'placement':'right', 'selector': '', 'delay': { show: 100, hide: 50}});
  $('#relations-next').tooltip({'placement':'left', 'selector': '', 'delay': { show: 100, hide: 50}});
</script>
</div>

    
  </div>
</div>

<div class="petljadoc-resources">
  <span class="pull-left">(Created using  <a href="https://pypi.org/project/Sphinx/">Swinx</a>, <a href="http://runestoneinteractive.org/">RunestoneComponents</a> and <a href="https://github.com/Petlja/PetljaDoc">PetljaDoc</a>) <br> © 2022 Petlja</span>
</div>


<div class="lectureToolbox">

  <label class="font-size-toggle" id="fontSizeToggle">

      <i class="fas fa-font"></i><label>Слова</label>
  </label>
  <div class="font-change d-none" id="fontChangeModal">
      <span class="dec-letter-icon" id="decLetterIcon">A-</span>
      <label id="currentFontSize">16</label>
      <span class="inc-letter-icon" id="incLetterIcon">A+</span>
  </div>
</div>

</div>

  </body>
</html>